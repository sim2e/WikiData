In logic and computer science, unification is an algorithmic process of solving equations between symbolic expressions. For example, using x,y,z as variables, the singleton equation set { cons(x,cons(x,nil)) = cons(2,y) } is a syntactic first-order unification problem that has the substitution { x ↦ 2, y ↦ cons(2,nil) } as its only solution.
A unification algorithm was first discovered by Jacques Herbrand, while a first formal investigation can be attributed to John Alan Robinson, who used first-order syntactical unification as a basic building block of his resolution procedure for first-order logic, a great step forward in automated reasoning technology, as it eliminated one source of combinatorial explosion: searching for instantiation of terms. Today, automated reasoning is still the main application area of unification.
Syntactical first-order unification is used in logic programming and programming language type system implementation, especially in Hindley–Milner based type inference algorithms.
Semantic unification is used in SMT solvers, term rewriting algorithms and cryptographic protocol analysis.
Higher-order unification is used in proof assistants, for example Isabelle and Twelf, and restricted forms of higher-order unification (higher-order pattern unification) are used in some programming language implementations, such as lambdaProlog, as higher-order patterns are expressive, yet their associated unification procedure retains theoretical properties closer to first-order unification.

Formal definition
A unification problem is a finite set E={ l1 ≐ r1, ..., ln ≐ rn } of equations to solve, where li, ri are in the set 
  
    
      
        T
      
    
    {\displaystyle T}
   of terms or expressions. Depending on which expressions or terms are allowed to occur in an equation set or unification problem, and which expressions are considered equal, several frameworks of unification are distinguished. If higher-order variables, that is, variables representing functions, are allowed in an expression, the process is called higher-order unification, otherwise first-order unification. If a solution is required to make both sides of each equation literally equal, the process is called syntactic or free unification, otherwise semantic or equational unification, or E-unification, or unification modulo theory.
If the right side of each equation is closed (no free variables), the problem is called (pattern) matching. The left side (with variables) of each equation is called the pattern.

Prerequisites
Formally, a unification approach presupposes

An infinite set 
  
    
      
        V
      
    
    {\displaystyle V}
   of variables. For higher-order unification, it is convenient to choose 
  
    
      
        V
      
    
    {\displaystyle V}
   disjoint from the set of lambda-term bound variables.
A set 
  
    
      
        T
      
    
    {\displaystyle T}
   of terms such that 
  
    
      
        V
        ⊆
        T
      
    
    {\displaystyle V\subseteq T}
  . For first-order unification, 
  
    
      
        T
      
    
    {\displaystyle T}
   is usually the set of first-order terms (terms built from variable and function symbols).  For higher-order unification 
  
    
      
        T
      
    
    {\displaystyle T}
   consists of first-order terms and lambda terms (terms containing some higher-order variables).
A mapping vars: 
  
    
      
        T
        →
      
    
    {\displaystyle T\rightarrow }
   
  
    
      
        
          P
        
      
    
    {\displaystyle \mathbb {P} }
  
  
    
      
        (
        V
        )
      
    
    {\displaystyle (V)}
  , assigning to each term 
  
    
      
        t
      
    
    {\displaystyle t}
   the set 
  
    
      
        
          vars
        
        (
        t
        )
        ⊊
        V
      
    
    {\displaystyle {\text{vars}}(t)\subsetneq V}
   of free variables occurring in 
  
    
      
        t
      
    
    {\displaystyle t}
  .
A theory or equivalence relation 
  
    
      
        ≡
      
    
    {\displaystyle \equiv }
   on 
  
    
      
        T
      
    
    {\displaystyle T}
  , indicating which terms are considered equal. For first-order E-unification, 
  
    
      
        ≡
      
    
    {\displaystyle \equiv }
   reflects the background knowledge about certain function symbols; for example, if 
  
    
      
        ⊕
      
    
    {\displaystyle \oplus }
   is considered commutative, 
  
    
      
        t
        ≡
        u
      
    
    {\displaystyle t\equiv u}
   if 
  
    
      
        u
      
    
    {\displaystyle u}
   results from 
  
    
      
        t
      
    
    {\displaystyle t}
   by swapping the arguments of 
  
    
      
        ⊕
      
    
    {\displaystyle \oplus }
   at some (possibly all) occurrences.  In the most typical case that there is no background knowledge at all, then only literally, or syntactically, identical terms are considered equal. In this case, ≡ is called the free theory (because it is a free object), the empty theory (because the set of equational sentences, or the background knowledge, is empty), the theory of uninterpreted functions (because unification is done on uninterpreted terms), or the theory of constructors (because all function symbols just build up data terms, rather than operating on them). For higher-order unification, usually 
  
    
      
        t
        ≡
        u
      
    
    {\displaystyle t\equiv u}
   if 
  
    
      
        t
      
    
    {\displaystyle t}
   and 
  
    
      
        u
      
    
    {\displaystyle u}
   are alpha equivalent.As an example of how the set of terms and theory affects the set of solutions, the syntactic first-order unification problem { y = cons(2,y) } has no solution over the set of finite terms. However, it has the single solution { y ↦ cons(2,cons(2,cons(2,...))) } over the set of infinite tree terms. Similarly, the semantic first-order unification problem { a⋅x = x⋅a } has each substitution of the form { x ↦ a⋅...⋅a } as a solution in a semigroup, i.e. if (⋅) is considered associative. But the same problem, viewed in an abelian group, where  (⋅) is considered also commutative, has any substitution at all as a solution.
As an example of higher-order unification, the singleton set { a = y(x) } is a syntactic second-order unification problem, since y is a function variable. One solution is { x ↦ a, y ↦ (identity function) }; another one is { y ↦ (constant function mapping each value to a), x ↦ (any value) }.

Substitution
A substitution is a mapping 
  
    
      
        σ
        :
        V
        →
        T
      
    
    {\displaystyle \sigma :V\rightarrow T}
   from variables to terms; the notation 
  
    
      
        {
        
          x
          
            1
          
        
        ↦
        
          t
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            k
          
        
        ↦
        
          t
          
            k
          
        
        }
      
    
    {\displaystyle \{x_{1}\mapsto t_{1},...,x_{k}\mapsto t_{k}\}}
   refers to a substitution mapping each variable 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
   to the term 
  
    
      
        
          t
          
            i
          
        
      
    
    {\displaystyle t_{i}}
  , for 
  
    
      
        i
        =
        1
        ,
        .
        .
        .
        ,
        k
      
    
    {\displaystyle i=1,...,k}
  , and every other variable to itself; the 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
   must be pairwise distinct. Applying that substitution to a term 
  
    
      
        t
      
    
    {\displaystyle t}
   is written in postfix notation as 
  
    
      
        t
        {
        
          x
          
            1
          
        
        ↦
        
          t
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            k
          
        
        ↦
        
          t
          
            k
          
        
        }
      
    
    {\displaystyle t\{x_{1}\mapsto t_{1},...,x_{k}\mapsto t_{k}\}}
  ; it means to (simultaneously) replace every occurrence of each variable 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
   in the term 
  
    
      
        t
      
    
    {\displaystyle t}
   by 
  
    
      
        
          t
          
            i
          
        
      
    
    {\displaystyle t_{i}}
  . The result 
  
    
      
        t
        τ
      
    
    {\displaystyle t\tau }
   of applying a substitution 
  
    
      
        τ
      
    
    {\displaystyle \tau }
   to a term 
  
    
      
        t
      
    
    {\displaystyle t}
   is called an instance of that term 
  
    
      
        t
      
    
    {\displaystyle t}
  .
As a first-order example, applying the substitution { x ↦ h(a,y), z ↦ b } to the term

Generalization, specialization
If a term 
  
    
      
        t
      
    
    {\displaystyle t}
   has an instance equivalent to a term 
  
    
      
        u
      
    
    {\displaystyle u}
  , that is, if 
  
    
      
        t
        σ
        ≡
        u
      
    
    {\displaystyle t\sigma \equiv u}
   for some substitution 
  
    
      
        σ
      
    
    {\displaystyle \sigma }
  , then 
  
    
      
        t
      
    
    {\displaystyle t}
   is called more general than 
  
    
      
        u
      
    
    {\displaystyle u}
  , and 
  
    
      
        u
      
    
    {\displaystyle u}
   is called more special than, or subsumed by, 
  
    
      
        t
      
    
    {\displaystyle t}
  . For example, 
  
    
      
        x
        ⊕
        a
      
    
    {\displaystyle x\oplus a}
   is more general than 
  
    
      
        a
        ⊕
        b
      
    
    {\displaystyle a\oplus b}
   if ⊕ is commutative, since then 
  
    
      
        (
        x
        ⊕
        a
        )
        {
        x
        ↦
        b
        }
        =
        b
        ⊕
        a
        ≡
        a
        ⊕
        b
      
    
    {\displaystyle (x\oplus a)\{x\mapsto b\}=b\oplus a\equiv a\oplus b}
  .
If ≡ is literal (syntactic) identity of terms, a term may be both more general and more special than another one only if both terms differ just in their variable names, not in their syntactic structure; such terms are called variants, or renamings of each other.
For example, 

  
    
      
        f
        (
        
          x
          
            1
          
        
        ,
        a
        ,
        g
        (
        
          z
          
            1
          
        
        )
        ,
        
          y
          
            1
          
        
        )
      
    
    {\displaystyle f(x_{1},a,g(z_{1}),y_{1})}
  
is a variant of 

  
    
      
        f
        (
        
          x
          
            2
          
        
        ,
        a
        ,
        g
        (
        
          z
          
            2
          
        
        )
        ,
        
          y
          
            2
          
        
        )
      
    
    {\displaystyle f(x_{2},a,g(z_{2}),y_{2})}
  ,
since

and

However, 
  
    
      
        f
        (
        
          x
          
            1
          
        
        ,
        a
        ,
        g
        (
        
          z
          
            1
          
        
        )
        ,
        
          y
          
            1
          
        
        )
      
    
    {\displaystyle f(x_{1},a,g(z_{1}),y_{1})}
   is not a variant of  
  
    
      
        f
        (
        
          x
          
            2
          
        
        ,
        a
        ,
        g
        (
        
          x
          
            2
          
        
        )
        ,
        
          x
          
            2
          
        
        )
      
    
    {\displaystyle f(x_{2},a,g(x_{2}),x_{2})}
  , since no substitution can transform the latter term into the former one.
The latter term is therefore properly more special than the former one.
For arbitrary 
  
    
      
        ≡
      
    
    {\displaystyle \equiv }
  , a term may be both more general and more special than a structurally different term.
For example, if ⊕ is idempotent, that is, if always 
  
    
      
        x
        ⊕
        x
        ≡
        x
      
    
    {\displaystyle x\oplus x\equiv x}
  , then the term 
  
    
      
        x
        ⊕
        y
      
    
    {\displaystyle x\oplus y}
   is more general than 
  
    
      
        z
      
    
    {\displaystyle z}
  , and vice versa, although 
  
    
      
        x
        ⊕
        y
      
    
    {\displaystyle x\oplus y}
   and 
  
    
      
        z
      
    
    {\displaystyle z}
   are of different structure.
A substitution 
  
    
      
        σ
      
    
    {\displaystyle \sigma }
   is more special than, or subsumed by, a substitution 
  
    
      
        τ
      
    
    {\displaystyle \tau }
   if 
  
    
      
        t
        σ
      
    
    {\displaystyle t\sigma }
   is subsumed by 
  
    
      
        t
        τ
      
    
    {\displaystyle t\tau }
   for each term 
  
    
      
        t
      
    
    {\displaystyle t}
  .  We also say that 
  
    
      
        τ
      
    
    {\displaystyle \tau }
   is more general than 
  
    
      
        σ
      
    
    {\displaystyle \sigma }
  . More formally, take a nonempty infinite set 
  
    
      
        V
      
    
    {\displaystyle V}
   of auxiliary variables such that no equation 
  
    
      
        
          l
          
            i
          
        
        ≐
        
          r
          
            i
          
        
      
    
    {\displaystyle l_{i}\doteq r_{i}}
   in the unification problem contains variables from 
  
    
      
        V
      
    
    {\displaystyle V}
  . Then a substitution 
  
    
      
        σ
      
    
    {\displaystyle \sigma }
   is subsumed by another substitution 
  
    
      
        τ
      
    
    {\displaystyle \tau }
   if there is a substitution 
  
    
      
        θ
      
    
    {\displaystyle \theta }
   such that for all terms 
  
    
      
        X
        ∉
        V
      
    
    {\displaystyle X\notin V}
  , 
  
    
      
        X
        σ
        ≡
        X
        τ
        θ
      
    
    {\displaystyle X\sigma \equiv X\tau \theta }
  .
For instance 
  
    
      
        {
        x
        ↦
        a
        ,
        y
        ↦
        a
        }
      
    
    {\displaystyle \{x\mapsto a,y\mapsto a\}}
   is subsumed by 
  
    
      
        τ
        =
        {
        x
        ↦
        y
        }
      
    
    {\displaystyle \tau =\{x\mapsto y\}}
  , using 
  
    
      
        θ
        =
        {
        y
        ↦
        a
        }
      
    
    {\displaystyle \theta =\{y\mapsto a\}}
  , but 

  
    
      
        σ
        =
        {
        x
        ↦
        a
        }
      
    
    {\displaystyle \sigma =\{x\mapsto a\}}
   is not subsumed by 
  
    
      
        τ
        =
        {
        x
        ↦
        y
        }
      
    
    {\displaystyle \tau =\{x\mapsto y\}}
  , as 
  
    
      
        f
        (
        x
        ,
        y
        )
        σ
        =
        f
        (
        a
        ,
        y
        )
      
    
    {\displaystyle f(x,y)\sigma =f(a,y)}
   is not an instance of

  
    
      
        f
        (
        x
        ,
        y
        )
        τ
        =
        f
        (
        y
        ,
        y
        )
      
    
    {\displaystyle f(x,y)\tau =f(y,y)}
  .

Solution set
A substitution σ is a solution of the unification problem E if liσ ≡ riσ for 
  
    
      
        i
        =
        1
        ,
        .
        .
        .
        ,
        n
      
    
    {\displaystyle i=1,...,n}
  . Such a substitution is also called a unifier of E.
For example, if ⊕ is associative, the unification problem { x ⊕ a ≐ a ⊕ x } has the solutions {x ↦ a}, {x ↦ a ⊕ a}, {x ↦ a ⊕ a ⊕ a}, etc., while the problem { x ⊕ a ≐ a } has no solution.
For a given unification problem E, a set S of unifiers is called complete if each solution substitution is subsumed by some substitution in S. A complete substitution set always exists (e.g. the set of all solutions), but in some frameworks (such as unrestricted higher-order unification) the problem of determining whether any solution exists (i.e., whether the complete substitution set is nonempty) is undecidable.
The set S is called minimal if none of its members subsumes another one. Depending on the framework, a complete and minimal substitution set may have zero, one, finitely many, or infinitely many members, or may not exist at all due to an infinite chain of redundant members. Thus, in general, unification algorithms compute a finite approximation of the complete set, which may or may not be minimal, although most algorithms avoid redundant unifiers when possible. For first-order syntactical unification, Martelli and Montanari gave an algorithm that reports unsolvability or computes a single unifier that by itself forms a complete and minimal substitution set, called the most general unifier.

Syntactic unification of first-order terms
Syntactic unification of first-order terms is the most widely used unification framework.
It is based on T being the set of first-order terms (over some given set V of variables, C of constants and Fn of n-ary function symbols) and on ≡ being syntactic equality.
In this framework, each solvable unification problem {l1 ≐ r1, ..., ln ≐ rn} has a complete, and obviously minimal, singleton solution set {σ}.
Its member σ is called the most general unifier (mgu) of the problem.
The terms on the left and the right hand side of each potential equation become syntactically equal when the mgu is applied i.e. l1σ = r1σ ∧ ... ∧ lnσ = rnσ.
Any unifier of the problem is subsumed by the mgu σ.
The mgu is unique up to variants: if S1 and S2 are both complete and minimal solution sets of the same syntactical unification problem, then S1 = { σ1 } and S2 = { σ2 } for some substitutions σ1 and σ2, and xσ1 is a variant of xσ2 for each variable x occurring in the problem.
For example, the unification problem { x ≐ z, y ≐ f(x) } has a unifier { x ↦ z, y ↦ f(z) }, because

This is also the most general unifier.
Other unifiers for the same problem are e.g. { x ↦ f(x1), y ↦ f(f(x1)), z ↦ f(x1) }, { x ↦ f(f(x1)), y ↦ f(f(f(x1))), z ↦ f(f(x1)) }, and so on; there are infinitely many similar unifiers.
As another example, the problem g(x,x) ≐ f(y) has no solution with respect to ≡ being literal identity, since any substitution applied to the left and right hand side will keep the outermost g and f, respectively, and terms with different outermost function symbols are syntactically different.

A unification algorithm
The first algorithm given by Robinson (1965) was rather inefficient; cf. box.
The following faster algorithm originated from Martelli, Montanari (1982).
This paper also lists preceding attempts to find an efficient syntactical unification algorithm, and states that linear-time algorithms were discovered independently by Martelli, Montanari (1976) and Paterson, Wegman (1976, 1978).Given a finite set 
  
    
      
        G
        =
        {
        
          s
          
            1
          
        
        ≐
        
          t
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          s
          
            n
          
        
        ≐
        
          t
          
            n
          
        
        }
      
    
    {\displaystyle G=\{s_{1}\doteq t_{1},...,s_{n}\doteq t_{n}\}}
   of potential equations,
the algorithm applies rules to transform it to an equivalent set of equations of the form
{ x1 ≐ u1, ..., xm ≐ um }
where x1, ..., xm are distinct variables and u1, ..., um are terms containing none of the xi.
A set of this form can be read as a substitution.
If there is no solution the algorithm terminates with ⊥; other authors use "Ω",  or "fail" in that case.
The operation of substituting all occurrences of variable x in problem G with term t is denoted G {x ↦ t}.
For simplicity, constant symbols are regarded as function symbols having zero arguments.

Occurs check
An attempt to unify a variable x with a term containing x as a strict subterm x ≐ f(..., x, ...) would lead to an infinite term as solution for x, since x would occur as a subterm of itself.
In the set of (finite) first-order terms as defined above, the equation x ≐ f(..., x, ...) has no solution; hence the eliminate rule may only be applied if x ∉ vars(t).
Since that additional check, called occurs check, slows down the algorithm, it is omitted e.g. in most Prolog systems.
From a theoretical point of view, omitting the check amounts to solving equations over infinite trees, see #Unification of infinite terms below.

Proof of termination
For the proof of termination of the algorithm consider a triple 
  
    
      
        ⟨
        
          n
          
            v
            a
            r
          
        
        ,
        
          n
          
            l
            h
            s
          
        
        ,
        
          n
          
            e
            q
            n
          
        
        ⟩
      
    
    {\displaystyle \langle n_{var},n_{lhs},n_{eqn}\rangle }
  
where nvar is the number of variables that occur more than once in the equation set, nlhs is the number of function symbols and constants
on the left hand sides of potential equations, and neqn is the number of equations.
When rule eliminate is applied, nvar decreases, since x is eliminated from G and kept only in { x ≐ t }.
Applying any other rule can never increase nvar again.
When rule decompose, conflict, or swap is applied, nlhs decreases, since at least the left hand side's outermost f disappears.
Applying any of the remaining rules delete or check can't increase nlhs, but decreases neqn.
Hence, any rule application decreases the triple 
  
    
      
        ⟨
        
          n
          
            v
            a
            r
          
        
        ,
        
          n
          
            l
            h
            s
          
        
        ,
        
          n
          
            e
            q
            n
          
        
        ⟩
      
    
    {\displaystyle \langle n_{var},n_{lhs},n_{eqn}\rangle }
   with respect to the lexicographical order, which is possible only a finite number of times.
Conor McBride observes that "by expressing the structure which unification exploits" in a dependently typed language such as Epigram, Robinson's unification algorithm can be made recursive on the number of variables, in which case a separate termination proof becomes unnecessary.

Examples of syntactic unification of first-order terms
In the Prolog syntactical convention a symbol starting with an upper case letter is a variable name; a symbol that starts with a lowercase letter is a function symbol; the comma is used as the logical and operator.
For mathematical notation, x,y,z are used as variables, f,g as function symbols, and a,b as constants.

The most general unifier of a syntactic first-order unification problem of size n may have a size of 2n. For example, the problem 
  
    
      
        (
        (
        (
        a
        ∗
        z
        )
        ∗
        y
        )
        ∗
        x
        )
        ∗
        w
        ≐
        w
        ∗
        (
        x
        ∗
        (
        y
        ∗
        (
        z
        ∗
        a
        )
        )
        )
      
    
    {\displaystyle (((a*z)*y)*x)*w\doteq w*(x*(y*(z*a)))}
   has the most general unifier 
  
    
      
        {
        z
        ↦
        a
        ,
        y
        ↦
        a
        ∗
        a
        ,
        x
        ↦
        (
        a
        ∗
        a
        )
        ∗
        (
        a
        ∗
        a
        )
        ,
        w
        ↦
        (
        (
        a
        ∗
        a
        )
        ∗
        (
        a
        ∗
        a
        )
        )
        ∗
        (
        (
        a
        ∗
        a
        )
        ∗
        (
        a
        ∗
        a
        )
        )
        }
      
    
    {\displaystyle \{z\mapsto a,y\mapsto a*a,x\mapsto (a*a)*(a*a),w\mapsto ((a*a)*(a*a))*((a*a)*(a*a))\}}
  , cf. picture. In order to avoid exponential time complexity caused by such blow-up, advanced unification algorithms work on directed acyclic graphs (dags) rather than trees.

Application: unification in logic programming
The concept of unification is one of the main ideas behind logic programming, best known through the language Prolog. It represents the mechanism of binding the contents of variables and can be viewed as a kind of one-time assignment. In Prolog, this operation is denoted by the equality symbol =, but is also done when instantiating variables (see below). It is also used in other languages by the use of the equality symbol =, but also in conjunction with many operations including +, -, *, /. Type inference algorithms are typically based on unification.
In Prolog:

A variable which is uninstantiated—i.e. no previous unifications were performed on it—can be unified with an atom, a term, or another uninstantiated variable, thus effectively becoming its alias. In many modern Prolog dialects and in first-order logic, a variable cannot be unified with a term that contains it; this is the so-called occurs check.
Two atoms can only be unified if they are identical.
Similarly, a term can be unified with another term if the top function symbols and arities of the terms are identical and if the parameters can be unified simultaneously. Note that this is a recursive behavior.

Application: type inference
Unification is used during type inference for languages with type systems based on Hindley-Milner, including the functional languages Haskell and ML. On one hand, the programmer does not need to provide type information for every function, on the other hand it is used to detect typing errors. The Haskell expression True : ['x', 'y', 'z'] is not correctly typed. The list construction function (:) is of type a -> [a] -> [a], and for the first argument True the polymorphic type variable a has to be unified with True's type, Bool. The second argument, ['x', 'y', 'z'], is of type [Char], but a cannot be both Bool and Char at the same time.
Like for Prolog, an algorithm for type inference can be given:

Any type variable unifies with any type expression, and is instantiated to that expression.  A specific theory might restrict this rule with an occurs check.
Two type constants unify only if they are the same type.
Two type constructions unify only if they are applications of the same type constructor and all of their component types recursively unify.Due to its declarative nature, the order in a sequence of unifications is (usually) unimportant.
Note that in the terminology of first-order logic, an atom is a basic proposition and is unified similarly to a Prolog term.

Application: Feature Structure Unification
Unification has been used in different research areas of computational linguistics.

Order-sorted unification
Order-sorted logic allows one to assign a sort, or type, to each term, and to declare a sort s1 a subsort of another sort s2, commonly written as s1 ⊆ s2. For example, when reаsoning about biological creatures, it is useful to declare a sort dog to be a subsort of a sort animal. Wherever a term of some sort s is required, a term of any subsort of s may be supplied instead.
For example, assuming a function declaration mother: animal → animal, and a constant declaration lassie: dog, the term  mother(lassie) is perfectly valid and has the sort animal. In order to supply the information that the mother of a dog is a dog in turn, another declaration mother: dog → dog may be issued; this is called function overloading, similar to overloading in programming languages.
Walther gave a unification algorithm for terms in order-sorted logic, requiring for any two declared sorts s1, s2 their intersection s1 ∩ s2 to be declared, too: if x1 and x2 is a variable of sort s1 and s2, respectively, the equation x1 ≐ x2 has the solution { x1 = x, x2 = x }, where x: s1 ∩ s2.

After incorporating this algorithm into a clause-based automated theorem prover, he could solve a benchmark problem by translating it into order-sorted logic, thereby boiling it down an order of magnitude, as many unary predicates turned into sorts.
Smolka generalized order-sorted logic to allow for parametric polymorphism.

In his framework, subsort declarations are propagated to complex type expressions.
As a programming example, a parametric sort list(X) may be declared (with X being a type parameter as in a C++ template), and from a subsort declaration int ⊆ float the relation list(int) ⊆ list(float) is automatically inferred, meaning that each list of integers is also a list of floats.
Schmidt-Schauß generalized order-sorted logic to allow for term declarations.

As an example, assuming subsort declarations even ⊆ int and odd ⊆ int, a term declaration like ∀ i : int. (i + i) : even allows to declare a property of integer addition that could not be expressed by ordinary overloading.

Unification of infinite terms
Background on infinite trees:

B. Courcelle (1983). "Fundamental Properties of Infinite Trees". Theoret. Comput. Sci. 25 (2): 95–169. doi:10.1016/0304-3975(83)90059-2.
Michael J. Maher (Jul 1988). "Complete Axiomatizations of the Algebras of Finite, Rational and Infinite Trees". Proc. IEEE 3rd Annual Symp. on Logic in Computer Science, Edinburgh. pp. 348–357.
Joxan Jaffar; Peter J. Stuckey (1986). "Semantics of Infinite Tree Logic Programming". Theoretical Computer Science. 46: 141–158. doi:10.1016/0304-3975(86)90027-7.Unification algorithm, Prolog II:

A. Colmerauer (1982). K.L. Clark; S.-A. Tarnlund (eds.). Prolog and Infinite Trees. Academic Press.
Alain Colmerauer (1984). "Equations and Inequations on Finite and Infinite Trees". In ICOT (ed.). Proc. Int. Conf. on Fifth Generation Computer Systems. pp. 85–99.Applications:

Francis Giannesini; Jacques Cohen (1984). "Parser Generation and Grammar Manipulation using Prolog's Infinite Trees". Journal of Logic Programming. 1 (3): 253–265. doi:10.1016/0743-1066(84)90013-X.

E-unification
E-unification is the problem of finding solutions to a given set of equations,
taking into account some equational background knowledge E.
The latter is given as a set of universal equalities.
For some particular sets E, equation solving algorithms (a.k.a. E-unification algorithms) have been devised;
for others it has been proven that no such algorithms can exist.
For example, if a and b are distinct constants,
the equation 
  
    
      
        x
        ∗
        a
        ≐
        y
        ∗
        b
      
    
    {\displaystyle x*a\doteq y*b}
   has no solution
with respect to purely syntactic unification,
where nothing is known about the operator 
  
    
      
        ∗
      
    
    {\displaystyle *}
  .
However, if the 
  
    
      
        ∗
      
    
    {\displaystyle *}
   is known to be commutative,
then the substitution {x ↦ b, y ↦ a} solves the above equation,
since

The background knowledge E could state the commutativity of 
  
    
      
        ∗
      
    
    {\displaystyle *}
   by the universal equality
"
  
    
      
        u
        ∗
        v
        =
        v
        ∗
        u
      
    
    {\displaystyle u*v=v*u}
   for all u, v".

Particular background knowledge sets E
It is said that unification is decidable for a theory, if a unification algorithm has been devised for it that terminates for any input problem.
It is said that unification is semi-decidable for a theory, if a unification algorithm has been devised for it that terminates for any solvable input problem, but may keep searching forever for solutions of an unsolvable input problem.
Unification is decidable for the following theories:

A
A,C
A,C,I
A,C,Nl
A,I
A,Nl,Nr (monoid)
C
Boolean rings
Abelian groups, even if the signature is expanded by arbitrary additional symbols (but not axioms)
K4 modal algebrasUnification is semi-decidable for the following theories:

A,Dl,Dr
A,C,Dl
Commutative rings

One-sided paramodulation
If there is a convergent term rewriting system R available for E,
the one-sided paramodulation algorithm
can be used to enumerate all solutions of given equations.

Starting with G being the unification problem to be solved and S being the identity substitution, rules are applied nondeterministically until the empty set appears as the actual G, in which case the actual S is a unifying substitution. Depending on the order the paramodulation rules are applied, on the choice of the actual equation from G, and on the choice of R's rules in mutate, different computations paths are possible. Only some lead to a solution, while others end at a G ≠ {} where no further rule is applicable (e.g. G = { f(...) ≐ g(...) }).

For an example, a term rewrite system R is used defining the append operator of lists built from cons and nil; where cons(x,y) is written in infix notation as x.y for brevity; e.g. app(a.b.nil,c.d.nil) → a.app(b.nil,c.d.nil) → a.b.app(nil,c.d.nil) → a.b.c.d.nil demonstrates the concatenation of the lists a.b.nil and c.d.nil, employing the rewrite rule 2,2, and 1. The equational theory E corresponding to R is the congruence closure of R, both viewed as binary relations on terms.
For example, app(a.b.nil,c.d.nil) ≡ a.b.c.d.nil ≡ app(a.b.c.d.nil,nil). The paramodulation algorithm enumerates solutions to equations with respect to that E when fed with the example R.
A successful example computation path for the unification problem { app(x,app(y,x)) ≐ a.a.nil } is shown below. To avoid variable name clashes, rewrite rules are consistently renamed each time before their use by rule mutate; v2, v3, ... are computer-generated variable names for this purpose. In each line, the chosen equation from G is highlighted in red. Each time the mutate rule is applied, the chosen rewrite rule (1 or 2) is indicated in parentheses. From the last line, the unifying substitution S = { y ↦ nil, x ↦  a.nil } can be obtained. In fact,
app(x,app(y,x)) {y↦nil, x↦ a.nil } = app(a.nil,app(nil,a.nil)) ≡ app(a.nil,a.nil) ≡ a.app(nil,a.nil) ≡ a.a.nil solves the given problem.
A second successful computation path, obtainable by choosing "mutate(1), mutate(2), mutate(2), mutate(1)" leads to the substitution S = { y ↦ a.a.nil, x ↦ nil }; it is not shown here. No other path leads to a success.

Narrowing
If R is a convergent term rewriting system for E,
an approach alternative to the previous section consists in successive application of "narrowing steps";
this will eventually enumerate all solutions of a given equation.
A narrowing step (cf. picture) consists in

choosing a nonvariable subterm of the current term,
syntactically unifying it with the left hand side of a rule from R, and
replacing the instantiated rule's right hand side into the instantiated term.Formally, if l → r is a renamed copy of a rewrite rule from R, having no variables in common with a term s, and the subterm s|p is not a variable and is unifiable with l via the mgu σ, then s can be narrowed to the term t = sσ[rσ]p, i.e. to the term sσ, with the subterm at p replaced by rσ. The situation that s can be narrowed to t is commonly denoted as s ↝ t.
Intuitively, a sequence of narrowing steps t1 ↝ t2 ↝ ... ↝ tn can be thought of as a sequence of rewrite steps t1 → t2 → ... → tn, but with the initial term t1 being further and further instantiated, as necessary to make each of the used rules applicable.
The above example paramodulation computation corresponds to the following narrowing sequence ("↓" indicating instantiation here):

The last term, v2.v2.nil can be syntactically unified with the original right hand side term a.a.nil.
The narrowing lemma ensures that whenever an instance of a term s can be rewritten to a term t by a convergent term rewriting system, then s and t can be narrowed and rewritten to a term s′ and t′, respectively, such that t′ is an instance of s′.
Formally: whenever sσ →∗ t holds for some substitution σ, then there exist terms s′, t′ such that s ↝∗ s′ and t →∗ t′ and s′ τ = t′ for some substitution τ.

Higher-order unification
Many applications require one to consider the unification of typed lambda-terms instead of first-order terms.  Such unification is often called higher-order unification. Higher-order unification is undecidable, and such unification problems do not have most general unifiers. For example, the unification problem { f(a,b,a) ≐ d(b,a,c) }, where the only variable is f, has the
solutions {f ↦ λx.λy.λz. d(y,x,c)  }, {f ↦ λx.λy.λz. d(y,z,c)  },
{f ↦ λx.λy.λz. d(y,a,c)  }, {f ↦ λx.λy.λz. d(b,x,c)  },
{f ↦ λx.λy.λz. d(b,z,c)  } and {f ↦ λx.λy.λz. d(b,a,c)  }. A well studied branch of higher-order unification is the problem of unifying simply typed lambda terms modulo the equality determined by αβη conversions. Gérard Huet gave a semi-decidable (pre-)unification algorithm that allows a systematic search of the space of unifiers (generalizing the unification algorithm of Martelli-Montanari with rules for terms containing higher-order variables) that seems to work sufficiently well in practice.  Huet and Gilles Dowek have written articles surveying this topic.
Several subsets of higher-order unification are well-behaved, in that they are decidable and have a most-general unifier for solvable problems. One such subset is the previously described first-order terms. Higher-order pattern unification, due to Dale Miller, is another such subset. The higher-order logic programming languages λProlog and Twelf have switched from full higher-order unification to implementing only the pattern fragment; surprisingly pattern unification is sufficient for almost all programs, if each non-pattern unification problem is suspended until a subsequent substitution puts the unification into the pattern fragment. A superset of pattern unification called functions-as-constructors unification is also well-behaved. The Zipperposition theorem prover has an algorithm integrating these well-behaved subsets into a full higher-order unification algorithm.In computational linguistics, one of the most influential theories of elliptical construction is that ellipses are represented by free variables whose values are then determined using Higher-Order Unification. For instance, the semantic representation of "Jon likes Mary and Peter does too" is   like(j, m) ∧ R(p)  and the value of R (the semantic representation of the ellipsis) is determined by the equation  like(j, m) = R(j)  . The process of solving such equations is called Higher-Order Unification.Wayne Snyder gave a generalization of both higher-order unification and E-unification, i.e. an algorithm to unify lambda-terms modulo an equational theory.

See also
Rewriting
Admissible rule
Explicit substitution in lambda calculus
Mathematical equation solving
Dis-unification: solving inequations between symbolic expression
Anti-unification: computing a least general generalization (lgg) of two terms, dual to computing a most general instance (mgu)
Subsumption lattice, a lattice having unification as meet and anti-unification as join
Ontology alignment (use unification with semantic equivalence)

Notes
References
Further reading
Franz Baader and Wayne Snyder (2001). "Unification Theory" Archived 2015-06-08 at the Wayback Machine. In John Alan Robinson and Andrei Voronkov, editors, Handbook of Automated Reasoning, volume I, pages 447–533. Elsevier Science Publishers.
Gilles Dowek (2001). "Higher-order Unification and Matching". In Handbook of Automated Reasoning.
Franz Baader and Tobias Nipkow (1998). Term Rewriting and All That. Cambridge University Press.
Franz Baader and Jörg H. Siekmann (1993). "Unification Theory". In Handbook of Logic in Artificial Intelligence and Logic Programming.
Jean-Pierre Jouannaud and Claude Kirchner (1991). "Solving Equations in Abstract Algebras: A Rule-Based Survey of Unification". In Computational Logic: Essays in Honor of Alan Robinson.
Nachum Dershowitz and Jean-Pierre Jouannaud, Rewrite Systems, in: Jan van Leeuwen (ed.), Handbook of Theoretical Computer Science, volume B Formal Models and Semantics, Elsevier, 1990, pp. 243–320
Jörg H. Siekmann (1990). "Unification Theory". In Claude Kirchner (editor) Unification. Academic Press.
Kevin Knight (Mar 1989). "Unification: A Multidisciplinary Survey" (PDF). ACM Computing Surveys. 21 (1): 93–124. CiteSeerX 10.1.1.64.8967. doi:10.1145/62029.62030. S2CID 14619034.
Gérard Huet and Derek C. Oppen (1980). "Equations and Rewrite Rules: A Survey". Technical report. Stanford University.
Raulefs, Peter; Siekmann, Jörg; Szabó, P.; Unvericht, E. (1979). "A short survey on the state of the art in matching and unification problems". ACM SIGSAM Bulletin. 13 (2): 14–20. doi:10.1145/1089208.1089210. S2CID 17033087.
Claude Kirchner and Hélène Kirchner. Rewriting, Solving, Proving. In preparation.