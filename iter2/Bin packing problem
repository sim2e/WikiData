The bin packing problem is an optimization problem, in which items of different sizes must be packed into a finite number of bins or containers, each of a fixed given capacity, in a way that minimizes the number of bins used. The problem has many applications, such as filling up containers, loading trucks with weight capacity constraints, creating file backups in media, and technology mapping in FPGA semiconductor chip design.
Computationally, the problem is NP-hard, and the corresponding decision problem, deciding if items can fit into a specified number of bins, is NP-complete. Despite its worst-case hardness, optimal solutions to very large instances of the problem can be produced with sophisticated algorithms. In addition, many approximation algorithms exist. For example, the first fit algorithm provides a fast but often non-optimal solution, involving placing each item into the first bin in which it will fit. It requires Θ(n log n) time, where n is the number of items to be packed. The algorithm can be made much more effective by first sorting the list of items into decreasing order (sometimes known as the first-fit decreasing algorithm), although this still does not guarantee an optimal solution and for longer lists may increase the running time of the algorithm. It is known, however, that there always exists at least one ordering of items that allows first-fit to produce an optimal solution.There are many variations of this problem, such as 2D packing, linear packing, packing by weight, packing by cost, and so on. The bin packing problem can also be seen as a special case of the cutting stock problem. When the number of bins is restricted to 1 and each item is characterized by both a volume and a value, the problem of maximizing the value of items that can fit in the bin is known as the knapsack problem.
A variant of bin packing that occurs in practice is when items can share space when packed into a bin. Specifically,  a set of items could occupy less space when packed together than the sum of their individual sizes. This variant is known as VM packing since when virtual machines (VMs) are packed in a server, their total memory requirement could decrease due to pages shared by the VMs that need only be stored once. If items can share space in arbitrary ways, the bin packing problem is hard to even approximate. However, if space sharing fits into a hierarchy, as is the case with memory sharing in virtual machines, the bin packing problem can be efficiently approximated.
Another variant of bin packing of interest in practice is the so-called online bin packing. Here the items of different volume are supposed to arrive sequentially, and the decision maker has to decide whether to select and pack the currently observed item, or else to let it pass. Each decision is without recall. In contrast, offline bin packing allows rearranging the items in the hope of achieving a better packing once additional items arrive. This of course requires additional storage for holding the items to be rearranged.

Formal statement
In Computers and Intractability: 226  Garey and Johnson list the bin packing problem under the reference [SR1]. They define its decision variant as follows.
Instance: Finite set 
  
    
      
        I
      
    
    {\displaystyle I}
   of items, a size 
  
    
      
        s
        (
        i
        )
        ∈
        
          
            Z
          
          
            +
          
        
      
    
    {\displaystyle s(i)\in \mathbb {Z} ^{+}}
   for each 
  
    
      
        i
        ∈
        I
      
    
    {\displaystyle i\in I}
  , a positive integer bin capacity 
  
    
      
        B
      
    
    {\displaystyle B}
  , and a positive integer 
  
    
      
        K
      
    
    {\displaystyle K}
  .
Question: Is there a partition of 
  
    
      
        I
      
    
    {\displaystyle I}
   into disjoint sets 
  
    
      
        
          I
          
            1
          
        
        ,
        …
        ,
        
          I
          
            K
          
        
      
    
    {\displaystyle I_{1},\dots ,I_{K}}
   such that the sum of the sizes of the items in each 
  
    
      
        
          I
          
            j
          
        
      
    
    {\displaystyle I_{j}}
   is 
  
    
      
        B
      
    
    {\displaystyle B}
   or less?
Note that in the literature often an equivalent notation is used, where 
  
    
      
        B
        =
        1
      
    
    {\displaystyle B=1}
   and 
  
    
      
        s
        (
        i
        )
        ∈
        
          Q
        
        ∩
        (
        0
        ,
        1
        ]
      
    
    {\displaystyle s(i)\in \mathbb {Q} \cap (0,1]}
   for each 
  
    
      
        i
        ∈
        I
      
    
    {\displaystyle i\in I}
  . Furthermore, research is mostly interested in the optimization variant, which asks for the smallest possible value of 
  
    
      
        K
      
    
    {\displaystyle K}
  . A solution is optimal if it has minimal 
  
    
      
        K
      
    
    {\displaystyle K}
  . The 
  
    
      
        K
      
    
    {\displaystyle K}
  -value for an optimal solution for a set of items 
  
    
      
        I
      
    
    {\displaystyle I}
   is denoted by 
  
    
      
        
          O
          P
          T
        
        (
        I
        )
      
    
    {\displaystyle \mathrm {OPT} (I)}
   or just 
  
    
      
        
          O
          P
          T
        
      
    
    {\displaystyle \mathrm {OPT} }
   if the set of items is clear from the context.
A possible integer linear programming formulation of the problem is:

where 
  
    
      
        
          y
          
            j
          
        
        =
        1
      
    
    {\displaystyle y_{j}=1}
   if bin 
  
    
      
        j
      
    
    {\displaystyle j}
   is used and 
  
    
      
        
          x
          
            i
            j
          
        
        =
        1
      
    
    {\displaystyle x_{ij}=1}
   if item 
  
    
      
        i
      
    
    {\displaystyle i}
   is put into bin 
  
    
      
        j
      
    
    {\displaystyle j}
  .

Hardness of bin packing
The bin packing problem is strongly NP-complete. This can be proven by reducing the strongly NP-complete 3-partition problem to bin packing.Furthermore, there can be no approximation algorithm with absolute approximation ratio smaller than 
  
    
      
        
          
            
              3
              2
            
          
        
      
    
    {\displaystyle {\tfrac {3}{2}}}
   unless 
  
    
      
        
          
            P
          
        
        =
        
          
            N
            P
          
        
      
    
    {\displaystyle {\mathsf {P}}={\mathsf {NP}}}
  . This can be proven by a reduction from the partition problem: given an instance of Partition where the sum of all input numbers is 
  
    
      
        2
        T
      
    
    {\displaystyle 2T}
  ,  construct an instance of bin-packing in which the bin size is T. If there exists an equal partition of the inputs, then the optimal packing needs 2 bins; therefore, every algorithm with an approximation ratio smaller than 3/2 must return less than 3 bins, which must be 2 bins. In contrast, if there is no equal partition of the inputs, then the optimal packing needs at least 3 bins.
On the other hand, bin packing is solvable in pseudo-polynomial time for any fixed number of bins K, and solvable in polynomial time for any fixed bin capacity B.

Approximation algorithms for bin packing
To measure the performance of an approximation algorithm there are two approximation ratios considered in the literature. For a given list of items 
  
    
      
        L
      
    
    {\displaystyle L}
   the number 
  
    
      
        A
        (
        L
        )
      
    
    {\displaystyle A(L)}
   denotes the number of bins used when algorithm 
  
    
      
        A
      
    
    {\displaystyle A}
   is applied to list 
  
    
      
        L
      
    
    {\displaystyle L}
  , while 
  
    
      
        
          O
          P
          T
        
        (
        L
        )
      
    
    {\displaystyle \mathrm {OPT} (L)}
   denotes the optimum number for this list. The absolute worst-case performance ratio 
  
    
      
        
          R
          
            A
          
        
      
    
    {\displaystyle R_{A}}
   for an algorithm 
  
    
      
        A
      
    
    {\displaystyle A}
   is defined as

  
    
      
        
          R
          
            A
          
        
        ≡
        inf
        {
        r
        ≥
        1
        :
        A
        (
        L
        )
        
          /
        
        
          O
          P
          T
        
        (
        L
        )
        ≤
        r
        
           for all lists 
        
        L
        }
        .
      
    
    {\displaystyle R_{A}\equiv \inf\{r\geq 1:A(L)/\mathrm {OPT} (L)\leq r{\text{ for all lists }}L\}.}
  On the other hand, the asymptotic worst-case ratio 
  
    
      
        
          R
          
            A
          
          
            ∞
          
        
      
    
    {\displaystyle R_{A}^{\infty }}
   is defined as

  
    
      
        
          R
          
            A
          
          
            ∞
          
        
        ≡
        inf
        {
        r
        ≥
        1
        :
        ∃
        N
        >
        0
        ,
        A
        (
        L
        )
        
          /
        
        
          O
          P
          T
        
        (
        L
        )
        ≤
        r
        
           for all lists 
        
        L
        
           with 
        
        
          O
          P
          T
        
        (
        L
        )
        ≥
        N
        }
        .
      
    
    {\displaystyle R_{A}^{\infty }\equiv \inf\{r\geq 1:\exists N>0,A(L)/\mathrm {OPT} (L)\leq r{\text{ for all lists }}L{\text{ with }}\mathrm {OPT} (L)\geq N\}.}
  Equivalently, 
  
    
      
        
          R
          
            A
          
          
            ∞
          
        
      
    
    {\displaystyle R_{A}^{\infty }}
   is the smallest number such that there exists some constant K, such that for all lists L:

  
    
      
        A
        (
        L
        )
        ≤
        
          R
          
            A
          
          
            ∞
          
        
        ⋅
        
          O
          P
          T
        
        (
        L
        )
        +
        K
      
    
    {\displaystyle A(L)\leq R_{A}^{\infty }\cdot \mathrm {OPT} (L)+K}
  .Additionally, one can restrict the lists to those for which all items have a size of at most 
  
    
      
        α
      
    
    {\displaystyle \alpha }
  .  For such lists, the bounded size performance ratios are denoted as 
  
    
      
        
          R
          
            A
          
        
        (
        
          size
        
        ≤
        α
        )
      
    
    {\displaystyle R_{A}({\text{size}}\leq \alpha )}
   and 
  
    
      
        
          R
          
            A
          
          
            ∞
          
        
        (
        
          size
        
        ≤
        α
        )
      
    
    {\displaystyle R_{A}^{\infty }({\text{size}}\leq \alpha )}
  .
Approximation algorithms for bin packing can be classified into two categories:

Online heuristics, that consider the items in a given order and place them one by one inside the bins.  These heuristics are also applicable to the offline version of this problem.
Offline heuristics, that modify the given list of items e.g. by sorting the items by size. These algorithms are no longer applicable to the online variant of this problem. However, they have an improved approximation guarantee while maintaining the advantage of their small time-complexity. A sub-category of offline heuristics is asymptotic approximation schemes. These algorithms have an approximation guarantee of the form 
  
    
      
        (
        1
        +
        ε
        )
        
          O
          P
          T
        
        (
        L
        )
        +
        C
      
    
    {\displaystyle (1+\varepsilon )\mathrm {OPT} (L)+C}
   for some constant that may depend on 
  
    
      
        1
        
          /
        
        ε
      
    
    {\displaystyle 1/\varepsilon }
  . For an arbitrarily large 
  
    
      
        
          O
          P
          T
        
        (
        L
        )
      
    
    {\displaystyle \mathrm {OPT} (L)}
   these algorithms get arbitrarily close to 
  
    
      
        
          O
          P
          T
        
        (
        L
        )
      
    
    {\displaystyle \mathrm {OPT} (L)}
  . However, this comes at the cost of a (drastically) increased time complexity compared to the heuristical approaches.

Online heuristics
In the online version of the bin packing problem, the items arrive one after another and the (irreversible) decision where to place an item has to be made before knowing the next item or even if there will be another one. A diverse set of offline and online heuristics for bin-packing have been studied by David S. Johnson on his Ph.D. thesis.

Single-class algorithms
There are many simple algorithms that use the following general scheme:

For each item in the input list:
If the item fits into one of the currently open bins, then put it in one of these bins;
Otherwise, open a new bin and put the new item in it.The algorithms differ in the criterion by which they choose the open bin for the new item in step 1 (see the linked pages for more information):

Next Fit (NF) always keeps a single open bin. When the new item does not fit into it, it closes the current bin and opens a new bin. Its advantage is that it is a bounded-space algorithm since it only needs to keep a single open bin in memory. Its disadvantage is that its asymptotic approximation ratio is 2. In particular, 
  
    
      
        N
        F
        (
        L
        )
        ≤
        2
        ⋅
        
          O
          P
          T
        
        (
        L
        )
        −
        1
      
    
    {\displaystyle NF(L)\leq 2\cdot \mathrm {OPT} (L)-1}
  , and for each 
  
    
      
        N
        ∈
        
          N
        
      
    
    {\displaystyle N\in \mathbb {N} }
   there exists a list L such that 
  
    
      
        
          O
          P
          T
        
        (
        L
        )
        =
        N
      
    
    {\displaystyle \mathrm {OPT} (L)=N}
   and 
  
    
      
        N
        F
        (
        L
        )
        =
        2
        ⋅
        
          O
          P
          T
        
        (
        L
        )
        −
        2
      
    
    {\displaystyle NF(L)=2\cdot \mathrm {OPT} (L)-2}
  . Its asymptotic approximation ratio can be somewhat improved based on the item sizes: 
  
    
      
        
          R
          
            N
            F
          
          
            ∞
          
        
        (
        
          size
        
        ≤
        α
        )
        ≤
        2
      
    
    {\displaystyle R_{NF}^{\infty }({\text{size}}\leq \alpha )\leq 2}
   for all 
  
    
      
        α
        ≥
        1
        
          /
        
        2
      
    
    {\displaystyle \alpha \geq 1/2}
   and 
  
    
      
        
          R
          
            N
            F
          
          
            ∞
          
        
        (
        
          size
        
        ≤
        α
        )
        ≤
        1
        
          /
        
        (
        1
        −
        α
        )
      
    
    {\displaystyle R_{NF}^{\infty }({\text{size}}\leq \alpha )\leq 1/(1-\alpha )}
   for all 
  
    
      
        α
        ≤
        1
        
          /
        
        2
      
    
    {\displaystyle \alpha \leq 1/2}
  . For each algorithm A that is an AnyFit-algorithm it holds that 
  
    
      
        
          R
          
            A
          
          
            ∞
          
        
        (
        
          size
        
        ≤
        α
        )
        ≤
        
          R
          
            N
            F
          
          
            ∞
          
        
        (
        
          size
        
        ≤
        α
        )
      
    
    {\displaystyle R_{A}^{\infty }({\text{size}}\leq \alpha )\leq R_{NF}^{\infty }({\text{size}}\leq \alpha )}
  .
Next-k-Fit (NkF) is a variant of Next-Fit, but instead of keeping only one bin open, the algorithm keeps the last k bins open and chooses the first bin in which the item fits. Therefore, it is called a k-bounded space algorithm. For 
  
    
      
        k
        ≥
        2
      
    
    {\displaystyle k\geq 2}
   the NkF delivers results that are improved compared to the results of NF, however, increasing k to constant values larger than 2 improves the algorithm no further in its worst-case behavior.  If algorithm A is an AlmostAnyFit-algorithm and 
  
    
      
        m
        =
        ⌊
        1
        
          /
        
        α
        ⌋
        ≥
        2
      
    
    {\displaystyle m=\lfloor 1/\alpha \rfloor \geq 2}
   then 
  
    
      
        
          R
          
            A
          
          
            ∞
          
        
        (
        
          size
        
        ≤
        α
        )
        ≤
        
          R
          
            N
            2
            F
          
          
            ∞
          
        
        (
        
          size
        
        ≤
        α
        )
        =
        1
        +
        1
        
          /
        
        m
      
    
    {\displaystyle R_{A}^{\infty }({\text{size}}\leq \alpha )\leq R_{N2F}^{\infty }({\text{size}}\leq \alpha )=1+1/m}
  .
First-Fit (FF) keeps all bins open, in the order in which they were opened. It attempts to place each new item into the first bin in which it fits. Its approximation ratio is 
  
    
      
        F
        F
        (
        L
        )
        ≤
        ⌊
        1.7
        
          O
          P
          T
        
        ⌋
      
    
    {\displaystyle FF(L)\leq \lfloor 1.7\mathrm {OPT} \rfloor }
  , and there is a family of input lists L for which 
  
    
      
        F
        F
        (
        L
        )
      
    
    {\displaystyle FF(L)}
   matches this bound.
Best-Fit (BF), too, keeps all bins open, but attempts to place each new item into the bin with the maximum load in which it fits. Its approximation ratio is identical to that of FF, that is: 
  
    
      
        B
        F
        (
        L
        )
        ≤
        ⌊
        1.7
        
          O
          P
          T
        
        ⌋
      
    
    {\displaystyle BF(L)\leq \lfloor 1.7\mathrm {OPT} \rfloor }
  , and there is a family of input lists L for which 
  
    
      
        B
        F
        (
        L
        )
      
    
    {\displaystyle BF(L)}
   matches this bound.
Worst-Fit (WF) attempts to place each new item into the bin with the minimum load. It can behave as badly as Next-Fit, and will do so on the worst-case list for that 
  
    
      
        N
        F
        (
        L
        )
        =
        2
        ⋅
        
          O
          P
          T
        
        (
        L
        )
        −
        2
      
    
    {\displaystyle NF(L)=2\cdot \mathrm {OPT} (L)-2}
  . Furthermore, it holds that 
  
    
      
        
          R
          
            W
            F
          
          
            ∞
          
        
        (
        
          size
        
        ≤
        α
        )
        =
        
          R
          
            N
            F
          
          
            ∞
          
        
        (
        
          size
        
        ≤
        α
        )
      
    
    {\displaystyle R_{WF}^{\infty }({\text{size}}\leq \alpha )=R_{NF}^{\infty }({\text{size}}\leq \alpha )}
  . Since WF is an AnyFit-algorithm, there exists an AnyFit-algorithm such that 
  
    
      
        
          R
          
            A
            F
          
          
            ∞
          
        
        (
        α
        )
        =
        
          R
          
            N
            F
          
          
            ∞
          
        
        (
        α
        )
      
    
    {\displaystyle R_{AF}^{\infty }(\alpha )=R_{NF}^{\infty }(\alpha )}
  .
Almost Worst-Fit (AWF) attempts to place each new item inside the second most empty open bin (or emptiest bin if there are two such bins). If it does not fit, it tries the most empty one. It has an asymptotic worst-case ratio of 
  
    
      
        
          
            
              17
              10
            
          
        
      
    
    {\displaystyle {\tfrac {17}{10}}}
  .In order to generalize these results, Johnson introduced two classes of online heuristics called any-fit algorithm and almost-any-fit algorithm:: 470 
In an AnyFit (AF) algorithm, if the current nonempty bins are B1,...,Bj, then the current item will not be packed into Bj+1 unless it does not fit in any of B1,...,Bj. The FF, WF, BF and AWF algorithms satisfy this condition. Johnson proved that, for any AnyFit algorithm A and any 
  
    
      
        α
      
    
    {\displaystyle \alpha }
  :

  
    
      
        
          R
          
            F
            F
          
          
            ∞
          
        
        (
        α
        )
        ≤
        
          R
          
            A
          
          
            ∞
          
        
        (
        α
        )
        ≤
        
          R
          
            W
            F
          
          
            ∞
          
        
        (
        α
        )
      
    
    {\displaystyle R_{FF}^{\infty }(\alpha )\leq R_{A}^{\infty }(\alpha )\leq R_{WF}^{\infty }(\alpha )}
  .
In an AlmostAnyFit (AAF) algorithm, if the current nonempty bins are B1,...,Bj, and of these bins, Bk is the unique bin with the smallest load, then the current item will not be packed into Bk, unless it does not fit into any of the bins to its left. The FF, BF and AWF algorithms satisfy this condition, but WF does not. Johnson proved that, for any AAF algorithm A and any α:

  
    
      
        
          R
          
            A
          
          
            ∞
          
        
        (
        α
        )
        =
        
          R
          
            F
            F
          
          
            ∞
          
        
        (
        α
        )
      
    
    {\displaystyle R_{A}^{\infty }(\alpha )=R_{FF}^{\infty }(\alpha )}
    In particular: 
  
    
      
        
          R
          
            A
          
          
            ∞
          
        
        =
        1.7
      
    
    {\displaystyle R_{A}^{\infty }=1.7}
  .

Refined algorithms
Better approximation ratios are possible with heuristics that are not AnyFit. These heuristics usually keep several classes of open bins, devoted to items of different size ranges (see the linked pages for more information):

Refined-first-fit bin packing (RFF) partitions the item sizes into four ranges: 
  
    
      
        
          (
          
            
              
                1
                2
              
            
            ,
            1
          
          ]
        
      
    
    {\displaystyle \left({\frac {1}{2}},1\right]}
  , 
  
    
      
        
          (
          
            
              
                2
                5
              
            
            ,
            
              
                1
                2
              
            
          
          ]
        
      
    
    {\displaystyle \left({\frac {2}{5}},{\frac {1}{2}}\right]}
  , 
  
    
      
        
          (
          
            
              
                1
                3
              
            
            ,
            
              
                2
                5
              
            
          
          ]
        
      
    
    {\displaystyle \left({\frac {1}{3}},{\frac {2}{5}}\right]}
  , and 
  
    
      
        
          (
          
            0
            ,
            
              
                1
                3
              
            
          
          ]
        
      
    
    {\displaystyle \left(0,{\frac {1}{3}}\right]}
  . Similarly, the bins are categorized into four classes. The next item 
  
    
      
        i
        ∈
        L
      
    
    {\displaystyle i\in L}
   is first assigned to its corresponding class. Inside that class, it is assigned to a bin using first-fit. Note that this algorithm is not an Any-Fit algorithm since it may open a new bin despite the fact that the current item fits inside an open bin. This algorithm was first presented by Andrew Chi-Chih Yao, who proved that it has an approximation guarantee of 
  
    
      
        R
        F
        F
        (
        L
        )
        ≤
        (
        5
        
          /
        
        3
        )
        ⋅
        
          O
          P
          T
        
        (
        L
        )
        +
        5
      
    
    {\displaystyle RFF(L)\leq (5/3)\cdot \mathrm {OPT} (L)+5}
   and presented a family of lists 
  
    
      
        
          L
          
            k
          
        
      
    
    {\displaystyle L_{k}}
   with 
  
    
      
        R
        F
        F
        (
        
          L
          
            k
          
        
        )
        =
        (
        5
        
          /
        
        3
        )
        
          O
          P
          T
        
        (
        
          L
          
            k
          
        
        )
        +
        1
        
          /
        
        3
      
    
    {\displaystyle RFF(L_{k})=(5/3)\mathrm {OPT} (L_{k})+1/3}
   for 
  
    
      
        
          O
          P
          T
        
        (
        L
        )
        =
        6
        k
        +
        1
      
    
    {\displaystyle \mathrm {OPT} (L)=6k+1}
  .
Harmonic-k partitions the interval of sizes 
  
    
      
        (
        0
        ,
        1
        ]
      
    
    {\displaystyle (0,1]}
   based on a Harmonic progression into 
  
    
      
        k
        −
        1
      
    
    {\displaystyle k-1}
   pieces 
  
    
      
        
          I
          
            j
          
        
        :=
        
          (
          
            
              
                1
                
                  j
                  +
                  1
                
              
            
            ,
            
              
                1
                j
              
            
          
          ]
        
      
    
    {\displaystyle I_{j}:=\left({\frac {1}{j+1}},{\frac {1}{j}}\right]}
   for 
  
    
      
        1
        ≤
        j
        <
        k
      
    
    {\displaystyle 1\leq j<k}
   and 
  
    
      
        
          I
          
            k
          
        
        :=
        
          (
          
            0
            ,
            
              
                1
                k
              
            
          
          ]
        
      
    
    {\displaystyle I_{k}:=\left(0,{\frac {1}{k}}\right]}
   such that 
  
    
      
        
          ⋃
          
            j
            =
            1
          
          
            k
          
        
        
          I
          
            j
          
        
        =
        (
        0
        ,
        1
        ]
      
    
    {\displaystyle \bigcup _{j=1}^{k}I_{j}=(0,1]}
  . This algorithm was first described by Lee and Lee.  It has a time complexity of 
  
    
      
        
          
            O
          
        
        (
        
          |
        
        L
        
          |
        
        log
        ⁡
        (
        
          |
        
        L
        
          |
        
        )
        )
      
    
    {\displaystyle {\mathcal {O}}(|L|\log(|L|))}
   and at each step, there are at most k open bins that can be potentially used to place items, i.e., it is a k-bounded space algorithm. For 
  
    
      
        k
        →
        ∞
      
    
    {\displaystyle k\rightarrow \infty }
  , its approximation ratio satisfies 
  
    
      
        
          R
          
            H
            k
          
          
            ∞
          
        
        ≈
        1.6910
      
    
    {\displaystyle R_{Hk}^{\infty }\approx 1.6910}
  , and it is asymptotically tight.
Refined-harmonic combines ideas from Harmonic-k with ideas from Refined-First-Fit. It places the items larger than 
  
    
      
        
          
            
              1
              3
            
          
        
      
    
    {\displaystyle {\tfrac {1}{3}}}
   similar as in Refined-First-Fit, while the smaller items are placed using Harmonic-k. The intuition for this strategy is to reduce the huge waste for bins containing pieces that are just larger than 
  
    
      
        
          
            
              1
              2
            
          
        
      
    
    {\displaystyle {\tfrac {1}{2}}}
  . This algorithm was first described by Lee and Lee.  They proved that for 
  
    
      
        k
        =
        20
      
    
    {\displaystyle k=20}
   it holds that 
  
    
      
        
          R
          
            R
            H
          
          
            ∞
          
        
        ≤
        373
        
          /
        
        228
      
    
    {\displaystyle R_{RH}^{\infty }\leq 373/228}
  .

General lower bounds for online algorithms
Yao proved in 1980 that there can be no online algorithm with an asymptotic competitive ratio smaller than 
  
    
      
        
          
            
              3
              2
            
          
        
      
    
    {\displaystyle {\tfrac {3}{2}}}
  . Brown and Liang improved this bound to 1.53635. Afterward, this bound was improved to 1.54014 by Vliet.  In 2012, this lower bound was again improved by Békési and Galambos to 
  
    
      
        
          
            
              248
              161
            
          
        
        ≈
        1.54037
      
    
    {\displaystyle {\tfrac {248}{161}}\approx 1.54037}
  .

Comparison table
Offline algorithms
In the offline version of bin packing, the algorithm can see all the items before starting to place them into bins. This allows to attain improved approximation ratios.

Multiplicative approximation
The simplest technique used by offline approximation schemes is the following:

Ordering the input list by descending size;
Run an online algorithm on the ordered list.
Johnson proved that any AnyFit scheme A that runs on a list ordered by descending size has an asymptotic approximation ratio of
  
    
      
        1.22
        ≈
        
          
            11
            9
          
        
        ≤
        
          R
          
            A
          
          
            ∞
          
        
        ≤
        
          
            5
            4
          
        
        =
        1.25
      
    
    {\displaystyle 1.22\approx {\frac {11}{9}}\leq R_{A}^{\infty }\leq {\frac {5}{4}}=1.25}
  .Some methods in this family are (see the linked pages for more information):
First-fit-decreasing (FFD) orders the items by descending size, then calls First-Fit. Its approximation ratio is 
  
    
      
        F
        F
        D
        (
        I
        )
        =
        
          
            11
            9
          
        
        
          O
          P
          T
        
        (
        I
        )
        +
        
          
            6
            9
          
        
      
    
    {\displaystyle FFD(I)={\frac {11}{9}}\mathrm {OPT} (I)+{\frac {6}{9}}}
  , and this is tight.
Next-fit-decreasing (NFD) orders the items by descending size, then calls Next-Fit.  Its approximate ratio is slightly less than 1.7 in the worst case. It has also been analyzed probabilistically. Next-Fit packs a list and its inverse into the same number of bins. Therefore, Next-Fit-Increasing has the same performance as Next-Fit-Decreasing.
Modified first-fit-decreasing (MFFD), improves on FFD for items larger than half a bin by classifying items by size into four size classes large, medium, small, and tiny, corresponding to items with size > 1/2 bin, > 1/3 bin, > 1/6 bin, and smaller items respectively.  Its approximation guarantee is 
  
    
      
        M
        F
        F
        D
        (
        I
        )
        ≤
        
          
            71
            60
          
        
        
          O
          P
          T
        
        (
        I
        )
        +
        1
      
    
    {\displaystyle MFFD(I)\leq {\frac {71}{60}}\mathrm {OPT} (I)+1}
  .Fernandez de la Vega and Lueker presented a PTAS for bin packing. For every 
  
    
      
        ε
        >
        0
      
    
    {\displaystyle \varepsilon >0}
  , their algorithm finds a solution with size at most 
  
    
      
        (
        1
        +
        ε
        )
        
          O
          P
          T
        
        +
        1
      
    
    {\displaystyle (1+\varepsilon )\mathrm {OPT} +1}
   and runs in time  
  
    
      
        
          
            O
          
        
        (
        n
        log
        ⁡
        (
        1
        
          /
        
        ε
        )
        )
        +
        
          
            
              O
            
          
          
            ε
          
        
        (
        1
        )
      
    
    {\displaystyle {\mathcal {O}}(n\log(1/\varepsilon ))+{\mathcal {O}}_{\varepsilon }(1)}
  , where 
  
    
      
        
          
            
              O
            
          
          
            ε
          
        
        (
        1
        )
      
    
    {\displaystyle {\mathcal {O}}_{\varepsilon }(1)}
   denotes a function only dependent on 
  
    
      
        1
        
          /
        
        ε
      
    
    {\displaystyle 1/\varepsilon }
  . For this algorithm, they invented the method of adaptive input rounding: the input numbers are grouped and rounded up to the value of the maximum in each group. This yields an instance with a small number of different sizes, which can be solved exactly using the configuration linear program.

Additive approximation
The Karmarkar-Karp bin packing algorithm finds a solution with size at most 
  
    
      
        
          O
          P
          T
        
        +
        
          
            O
          
        
        (
        
          log
          
            2
          
        
        ⁡
        (
        
          O
          P
          T
        
        )
        )
      
    
    {\displaystyle \mathrm {OPT} +{\mathcal {O}}(\log ^{2}(\mathrm {OPT} ))}
  , and runs in time polynomial in n (the polynomial has a high degree, at least 8).
Rothvoss presented an algorithm that generates a solution with at most 
  
    
      
        
          O
          P
          T
        
        +
        
          
            O
          
        
        (
        log
        ⁡
        (
        
          O
          P
          T
        
        )
        ⋅
        log
        ⁡
        log
        ⁡
        (
        
          O
          P
          T
        
        )
        )
      
    
    {\displaystyle \mathrm {OPT} +{\mathcal {O}}(\log(\mathrm {OPT} )\cdot \log \log(\mathrm {OPT} ))}
   bins.
Hoberg and Rothvoss improved this algorithm to generate a solution with at most 
  
    
      
        
          O
          P
          T
        
        +
        
          
            O
          
        
        (
        log
        ⁡
        (
        
          O
          P
          T
        
        )
        )
      
    
    {\displaystyle \mathrm {OPT} +{\mathcal {O}}(\log(\mathrm {OPT} ))}
   bins. The algorithm is randomized, and its running-time is polynomial in n.

Comparison table
Exact algorithms
Martello and Toth developed an exact algorithm for the 1-dimensional bin-packing problem, called MTP. A faster alternative is the Bin Completion algorithm proposed by Korf in 2002 and later improved.A further improvement was presented by Schreiber and Korf in 2013. The new Improved Bin Completion algorithm is shown to be up to five orders of magnitude faster than Bin Completion on non-trivial problems with 100 items, and outperforms the BCP (branch-and-cut-and-price) algorithm by Belov and Scheithauer on problems that have fewer than 20 bins as the optimal solution. Which algorithm performs best depends on problem properties like the number of items, the optimal number of bins, unused space in the optimal solution and value precision.

Small number of different sizes
A special case of bin packing is when there is a small number d of different item sizes. There can be many different items of each size. This case is also called high-multiplicity bin packing, and It admits more efficient algorithms than the general problem.

Bin-packing with fragmentation
Bin-packing with fragmentation or fragmentable object bin-packing is a variant of the bin packing problem in which it is allowed to break items into parts and put each part separately on a different bin. Breaking items into parts may allow for improving the overall performance, for example, minimizing the number of total bin. Moreover, the computational problem of finding an optimal schedule may become easier, as some of the optimization variables become continuous. On the other hand, breaking items apart might be costly. The problem was first introduced by Mandal, Chakrabary and Ghose.

Variants
The problem has two main variants.

In the first variant, called bin-packing with size-increasing fragmentation (BP-SIF), each item may be fragmented; overhead units are added to the size of every fragment.
In the second variant, called bin-packing with size-preserving fragmentation (BP-SPF) each item has a size and a cost; fragmenting an item increases its cost but does not change its size.

Computational complexity
Mandal, Chakrabary and Ghose proved that BP-SPF is NP-hard.
Menakerman and Rom showed that BP-SIF and BP-SPF are both strongly NP-hard. Despite the hardness, they present several algorithms and investigate their performance. Their algorithms use classic algorithms for bin-packing, like next-fit and first-fit decreasing, as a basis for their algorithms.
Bertazzi, Golden and Wang introduced a variant of BP-SIF with 
  
    
      
        1
        −
        x
      
    
    {\displaystyle 1-x}
   split rule: an item is allowed to be split in only one way according to its size. It is useful for the vehicle routing problem for example. In their paper, they provide the worst-case performance bound of the variant.
Shachnai, Tamir and Yehezkeli developed approximation schemes for BP-SIF and BP-SPF; a dual PTAS (a PTAS for the dual version of the problem), an asymptotic PTAS called APTAS, and a dual asymptotic FPTAS called AFPTAS for both versions.
Ekici introduced a variant of BP-SPF in which some items are in conflict, and it is forbidden to pack fragments of conflicted items into the same bin. They proved that this variant, too, is NP-hard.
Cassazza and Ceselli introduced a variant with no cost and no overhead, and the number of bins is fixed. However, the number of fragmentations should be minimized. They present mathematical programming algorithms for both exact and approximate solutions.

Related problems
The problem of fractional knapsack with penalties was introduced by Malaguti, Monaci, Paronuzzi and Pferschy. They developed an FPTAS and a dynamic program for the problem, and they showed an extensive computational study comparing the performance of their models. See also: Fractional job scheduling.

Cardinality constraints on the bins
There is a variant of bin packing in which there are cardinality constraints on the bins: each bin can contain at most k items, for some fixed integer k.

Krause, Shen and Schwetman introduce this problem as a variant of optimal job scheduling: a computer has some k processors. There are some n jobs that take unit time (1), but have different memory requirements. Each time-unit is considered a single bin. The goal is to use as few bins (=time units) as possible, while ensuring that in each bin, at most k jobs run. They present several heuristic algorithms that find a solution with at most 
  
    
      
        2
        
          O
          P
          T
        
      
    
    {\displaystyle 2\mathrm {OPT} }
   bins.
Kellerer and Pferschy present an algorithm with run-time 
  
    
      
        O
        (
        
          n
          
            2
          
        
        log
        ⁡
        
          n
        
        )
      
    
    {\displaystyle O(n^{2}\log {n})}
  , that finds a solution with at most 
  
    
      
        
          ⌈
          
            
              
                3
                2
              
            
            
              O
              P
              T
            
          
          ⌉
        
      
    
    {\displaystyle \left\lceil {\frac {3}{2}}\mathrm {OPT} \right\rceil }
   bins. Their algorithm performs a binary search for OPT. For every searched value m, it tries to pack the items into 3m/2 bins.

Non-additive functions
There are various ways to extend the bin-packing model to more general cost and load functions:

Anily, Bramel and Simchi-Levi study a setting where the cost of a bin is a concave function of the number of items in the bin. The objective is to minimize the total cost rather than the number of bins. They show that next-fit-increasing bin packing attains an absolute worst-case approximation ratio of at most 7/4, and an asymptotic worst-case ratio of 1.691 for any concave and monotone cost function.
Cohen, Keller, Mirrokni and Zadimoghaddam study a setting where the size of the items is not known in advance, but it is a random variable. This is particularly common in cloud computing environments. While there is an upper bound on the amount of resources a certain user needs, most users use much less than the capacity. Therefore, the cloud manager may gain a lot by slight overcommitment. This induces a variant of bin packing with chance constraints: the probability that the sum of sizes in each bin is at most B should be at least p, where p is a fixed constant (standard bin packing corresponds to p=1). They show that, under mild assumptions, this problem is equivalent to a submodular bin packing problem, in which the "load" in each bin is not equal to the sum of items, but to a certain submodular function of it.

Related problems
In the bin packing problem, the size of the bins is fixed and their number can be enlarged (but should be as small as possible).
In contrast, in the multiway number partitioning problem, the number of bins is fixed and their size can be enlarged. The objective is to find a partition in which the bin sizes are as nearly equal is possible (in the variant called multiprocessor scheduling problem or minimum makespan problem, the goal is specifically to minimize the size of the largest bin).
In the inverse bin packing problem, both the number of bins and their sizes are fixed, but the item sizes can be changed. The objective is to achieve the minimum perturbation to the item size vector so that all the items can be packed into the prescribed number of bins.
In the maximum resource bin packing problem, the goal is to maximize the number of bins used, such that, for some ordering of the bins, no item in a later bin fits in an earlier bin. In a dual problem, the number of bins is fixed, and the goal is to minimize the total number or the total size of items placed into the bins, such that no remaining item fits into an unfilled bin.
In the bin covering problem, the bin size is bounded from below: the goal is to maximize the number of bins used such that the total size in each bin is at least a given threshold.
In the fair indivisible chore allocation problem (a variant of fair item allocation), the items represent chores, and there are different people each of whom attributes a different difficulty-value to each chore. The goal is to allocate to each person a set of chores with an upper bound on its total difficulty-value (thus, each person corresponds to a bin). Many techniques from bin packing are used in this problem too.In the guillotine cutting problem, both the items and the "bins" are two-dimensional rectangles rather than one-dimensional numbers, and the items have to be cut from the bin using end-to-end cuts.
In the selfish bin packing problem, each item is a player who wants to minimize its cost.There is also a variant of bin packing in which the cost that should be minimized is not the number of bins, but rather a certain concave function of the number of items in each bin.Other variants are two-dimensional bin packing, three-dimensional bin packing, bin packing with delivery,

Resources
BPPLIB - a library of surveys, codes, benchmarks, generators, solvers, and bibliography.

Implementations
Online:  visualization of heuristics for 1D and 2D bin packing
Python: The prtpy package contains code for various number-partitioning, bin-packing and bin-covering algorithms. The binpacking package contains greedy algorithms for solving two typical bin packing problems.
C++: The bin-packing package contains various greedy algorithms as well as test data. The OR-tools package contains bin packing algorithms in C++, with wrappers in Python, C# and Java.
C: Implementation of 7 classic approximate bin packing algorithms in C with results and images
PHP: PHP Class to pack files without exceeding a given size limit
Haskell: An implementation of several bin packing heuristics, including FFD and MFFD.
C: Fpart : open-source command-line tool to pack files (C, BSD-licensed)
C#: Bin Packing and Cutting Stock Solver
Java: caparf - Cutting And Packing Algorithms Research Framework, including a number of bin packing algorithms and test data.


== References ==