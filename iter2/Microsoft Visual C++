Microsoft Visual C++ (MSVC) is a compiler for the C, C++, C++/CLI and C++/CX programming languages by Microsoft. MSVC is proprietary software; it was originally a standalone product but later became a part of Visual Studio and made available in both trialware and freeware forms. It features tools for developing and debugging C++ code, especially code written for the Windows API, DirectX and .NET.
Many applications require redistributable Visual C++ runtime library packages to function correctly. These packages are frequently installed separately from the applications they support, enabling multiple applications to use the package with only a single installation. These Visual C++ redistributable and runtime packages are mostly installed for standard libraries that many applications use.

History
The predecessor to Visual C++ was called Microsoft C/C++. There was also a Microsoft QuickC 2.5 and a Microsoft QuickC for Windows 1.0. The Visual C++ compiler is still known as Microsoft C/C++ and as of the release of Visual C++ 2015 Update 2, is on version 14.0.23918.0.

16-bit versions
Microsoft C 1.0, based on Lattice C, was Microsoft's first C product in 1983. It was not K&R C compliant.
C 2.0 added large model support, allowing up to 1MiB for both the Code Segment and Data Segment.
C 3.0 was the first version developed inside Microsoft. This version intended compatibility with K&R and the later ANSI standard. It was being used inside Microsoft (for Windows and Xenix development) in early 1984. It shipped as a product in 1985.
C 4.0 added optimizations and CodeView, a source-level debugger.
C 5.0 added loop optimizations and ‘huge memory model’ (arrays bigger than 64 KB) support. Microsoft Fortran and the first 32-bit compiler for 80386 were also part of this project.
C 5.1 released in 1988 allowed compiling programs for OS/2 1.x. The fourteen 5.25" disk (two of which were 1.2 MB, the others 360k) version included QuickC. The eleven 720k 3.5" disk version included with the OS/2 Software Development Kit included MASM 5.1 (a single executable that worked under both MSDOS and OS/2 1.x).
C 6.0 released in 1989. It added the Programmer's Workbench IDE, global flow analysis, a source browser, and a new debugger, and included an optional C++ front end.
C/C++ 7.0 was released in 1992. Dropped OS/2 support. Requires a 386 processor and uses the provided 386-Max dos extender (dosx32). Added built-in support for C++ and MFC (Microsoft Foundation Class Library) 1.0.
Visual C++ 1.0, which included MFC 2.0, was the first version of ‘Visual’ C++, released in February 1993. It was Cfront 2.1 compliant and available in two editions:Standard: replaced QuickC for Windows.
Professional: replaced C/C++ 7.0. Included the ability to build both DOS and Windows applications, an optimizing compiler, a source profiler, and the Windows 3.1 SDK. The Phar Lap 286 DOS Extender Lite was also included.
Visual C++ 1.5 was released in December 1993, included MFC 2.5, and added OLE 2.0 and ODBC support to MFC. It was the first version of Visual C++ that came only on CD-ROM.
Visual C++ 1.51 and 1.52 were available as part of a subscription service.
Visual C++ 1.52b is similar to 1.52, but does not include the Control Development Kit.
Visual C++ 1.52c was a patched version of 1.5. It is the last, and arguably most popular, development platform for Microsoft Windows 3.x. It is available through Microsoft Developer Network.

Strictly 32-bit versions
Visual C++ 1.0 (original name: Visual C++ 32-bit Edition) released in 1993 was the first version for 32-bit development for the Intel 386 architecture. Although released when 16-bit version 1.5 was available, it did not include support for OLE2 and ODBC. It was also available in a bundle called Visual C++ 16/32-bit Suite, which included Visual C++ 1.5.
Visual C++ 2.0, which included MFC 3.0, was the first version to be 32-bit only. In many ways, this version was ahead of its time, since Windows 95, then codenamed "Chicago", was not yet released, and Windows NT had only a small market share. Microsoft included and updated Visual C++ 1.5 as part of the 2.x releases up to 2.1, which included Visual C++ 1.52, and both 16-bit and 32-bit version of the Control Development Kit (CDK) were included. Visual C++ 2.x also supported Win32s development. It is available through Microsoft Developer Network. There was a Visual C++ 2.0 RISC Edition for MIPS and Alpha processors, as well as a cross-platform edition for the Macintosh (68000 instruction set).Visual C++ 2.1 and 2.2 were updates for 2.0 available through subscription.
Visual C++ 4.0, released on 1995-12-11, introduced the Developer Studio IDE. Its then-novel tiled layout of non-overlapping panels—navigation panel, combination editor/source level debugger panel, and console output panel—continues through the Visual Studio product line (as of 2013). Visual C++ 4.0 included MFC 4.0, was designed for Windows 95 and Windows NT. To allow support of legacy (Windows 3.x/DOS) projects, 4.0 came bundled with the Visual C++ 1.52 installation CD. Updates available through subscription included Visual C++ 4.1, which came with the Microsoft Game SDK (later released separately as the DirectX SDK), and Visual C++ 4.2. Version number 3.0 was skipped to achieve version number parity between Visual C++ 4.0 and MFC 4.0.
Visual C++ 4.2 did not support Windows 3.x (Win32s) development. This was the final version with a cross-platform edition for the Mac available and it differed from the 2.x version in that it also allowed compilation for the PowerPC instruction set.
Visual C++ 5.0 (bundled with Visual Studio 97) which included MFC 4.21 and was released 1997-04-28, was a major upgrade from 4.2. Available in four editions: Learning, Professional, Enterprise, and RISC.
Visual C++ 6.0 (commonly known as VC6, and available standalone in Standard, Professional and Enterprise editions, as well as bundled with Visual Studio 6.0), which included MFC 6.0, was released in 1998. The release was somewhat controversial since it did not include an expected update to MFC. Visual C++ 6.0 is still quite popular and often used to maintain legacy projects. There are, however, issues with this version under Windows XP, especially under the debugging mode (for example, the values of static variables do not display). The debugging issues can be solved with a patch called the "Visual C++ 6.0 Processor Pack". Version number: 12.00.8804
Visual C++ .NET 2002 (also known as Visual C++ 7.0), which included MFC 7.0, was released in 2002 with support for link time code generation and debugging runtime checks, .NET 1.0, and Visual C# and Managed C++. The new user interface used many of the hot keys and conventions of Visual Basic, which accounted for some of its unpopularity among C++ developers. Version number: 13.00.9466
Visual C++ .NET 2003 (also known as Visual C++ 7.1), which included MFC 7.1, was released in 2003 along with .NET 1.1 and was a major upgrade to Visual C++ .NET 2002, and was the first version to support the C99 "long long" construct. It was considered a patch to Visual C++ .NET 2002. Accordingly, the English language upgrade version of Visual Studio .NET 2003 shipped for minimal cost to owners of the English-language version of Visual Studio .NET 2002. Windows 98 is the lowest officially supported version. Although simple programs will work on Windows 95 and NT 4.0, more complex programs may cause things like ws2_32.dll to be referenced, or functions missing in kernel32.dll. In later versions (Visual C++ 2005) of the compiler even simple programs won't work (unless you replace the C library) because they have a reference to function IsDebuggerPresent in kernel32.dll which only exists in Windows 98 and later. Version number: 13.10.3077
eMbedded Visual C++ in various versions was used to develop for some versions of the Windows CE operating system. Initially it replaced a development environment consisting of tools added onto Visual C++ 6.0. eMbedded Visual C++ was replaced as a separate development environment by Microsoft Visual Studio 2005.

32-bit and 64-bit versions
Visual C++ 2005 (also known as Visual C++ 8.0), which included MFC 8.0, was released in November 2005. This version supports .NET 2.0 and includes a new version of C++ targeted to the .NET framework (C++/CLI) with the purpose of replacing the previous version (Managed C++). Managed C++ for CLI is still available via compiler options, though. It also introduced OpenMP. With Visual C++ 2005, Microsoft also introduced Team Foundation Server. Visual C++ 8.0 has problems compiling MFC AppWizard projects that were created using Visual Studio 6.0, so maintenance of legacy projects can be continued with the original IDE if rewriting is not feasible. Visual C++ 2005 is the last version able to target Windows 98 and Windows Me. SP1 version (14.00.50727.762) is also available in Microsoft Windows SDK Update for Windows Vista.
Visual C++ 2008 (also known as Visual C++ 9.0) was released in November 2007. This version supports .NET 3.5. Managed C++ for CLI is still available via compiler options. By default, all applications compiled against the Visual C++ 2008 Runtimes (static and dynamic linking) will only work on Windows 2000, Windows XP SP2 and later. A feature pack released for VC9, later included in SP1, added support for C++ TR1 library extensions. SP1 version (15.00.30729.01) is also available in Microsoft Windows SDK for Windows 7.
Some versions of Visual C++ supported Itanium 2.
Visual C++ 2010 (also known as Visual C++ 10.0) was released on April 12, 2010. It uses a SQL Server Compact database to store information about the source code, including IntelliSense information, for better IntelliSense and code-completion support. However, Visual C++ 2010 does not support Intellisense for C++/CLI. This version adds a C++ parallel computing library called the Parallel Patterns Library, partial support for C++11, significantly improved IntelliSense based on the Edison Design Group front end, and performance improvements to both the compiler and generated code. This version is built on .NET 4.0, but supports compiling to machine code. The partial C++11 support mainly consists of six compiler features: lambdas, rvalue references, auto, decltype, static_assert, and nullptr. C++11 also supports library features (e.g., moving the TR1 components from std::tr1 namespace directly to std namespace). Variadic templates were also considered, but delayed until some future version due to having a lower priority, which stemmed from the fact that, unlike other costly-to-implement features (lambda, rvalue references), variadic templates would benefit only a minority of library writers rather than the majority of compiler end users. By default, all applications compiled against Visual C++ 2010 Runtimes only work on Windows XP SP2 and later. The RTM version (16.00.30319) is also available in Windows SDK for Windows 7 and .NET Framework 4 (WinSDK v7.1). SP1 version (16.00.40219) is available as part of Visual Studio 2010 Service Pack 1 or through the Microsoft Visual C++ 2010 Service Pack 1 Compiler Update for the Windows SDK 7.1.
Visual C++ 2012 (also known as Visual C++ 11.0) was released on August 15, 2012. It features improved C++11 support, and support for Windows Runtime development.
Visual C++ 2013 (also known as Visual C++ 12.0) was released on October 17, 2013.  It features further C++11 and C99 support, and introduces a REST SDK.
Visual C++ 2015 (also known as Visual C++ 14.0) was released on July 20, 2015. It features improved C++11/14/17 support. Without any announcement from Microsoft, Visual Studio 2015 Update 2 started generating telemetry calls in compiled binaries. After some users contacted Microsoft about this problem, Microsoft said they would remove these telemetry calls when compiling with the future Visual Studio 2015 Update 3. The function in question was removed from the Visual C++ CRT static libraries in Visual Studio 2015 Update 3.
Visual C++ 2017 (also known as Visual C++ 14.1) was released on March 7, 2017.
Visual C++ 2019 (also known as Visual C++ 14.20) was released on April 2, 2019.
Visual C++ 2022 (also known as Visual C++ 14.30) was released on November 8, 2021.

Internal version numbering
There are several different version numbers to consider when working with Visual C or C++. The oldest and most original of these is the compiler version number, which has been monotonically increased since the early Microsoft C compiler days. This is the version returned by running the command cl.exe on its own without any options. By taking two digits after the decimal and dropping the decimal point, this also becomes the value of the C pre-processor macro: _MSC_VER, and the CMake variable: MSVC_VERSION. A longer version of the C macro is _MSC_FULL_VER to make more finely-grained distinctions between builds of the compiler. An example of _MSC_VER is '1933' to represent version 19.33 of the Microsoft C/C++ compiler, and of _MSC_FULL_VER is '193331630'. You should use the >= operator to test the value of _MSC_VER or _MSC_FULL_VER instead of equality.
The Visual product version, such as '17.3.4', designates the version of Visual Studio with which version 19.33 of the compiler was packaged. Then there is the Microsoft Visual C/C++ Runtime Library version, e.g. '14.3'. From this, one can deduce also the toolset version, which can be obtained by taking the first three digits of the runtime library version and dropping the decimal, e.g. '143'. It includes the Visual C/C++ runtime library, as well as compilers, linkers, assemblers, other build tools, and matching libraries and header files. The following is a (scrapeable) table of the known correlated version numbers.

Compatibility
ABI
The Visual C++ compiler ABI have historically changed between major compiler releases. This is especially the case for STL containers, where container sizes have varied a lot between compiler releases. Microsoft therefore recommends against using C++ interfaces at module boundaries when one wants to enable client code compiled using a different compiler version. Instead of C++, Microsoft recommends using C or COM interfaces, which are designed to have a stable ABI between compiler releases.
All 14.x MSVC releases have a stable ABI, and binaries built with these versions can be mixed in a forwards-compatible manner, noting the following restrictions:

The toolset version used must be equal to or higher than the highest toolset version used to build any linked binaries.
The MSVC Redistributable version must be equal to or higher than the toolset version used by any application component.
Static libraries or object files compiled with /GL (Whole program optimisation) are not binary compatible between versions and must use the exact same toolset.

C runtime libraries
Visual C++ ships with different versions of C runtime libraries. This means users can compile their code with any of the available libraries. However, this can cause some problems when using different components (DLLs, EXEs) in the same program. A typical example is a program using different libraries. The user should use the same C Run-Time for all the program's components unless the implications are understood. Microsoft recommends using the multithreaded, dynamic link library (/MD or /MDd compiler option) to avoid possible problems.

POSIX
Although Microsoft's CRT implements a large subset of POSIX interfaces, the Visual C++ compiler will emit a warning on every use of such functions by default. The rationale is that C and C++ standards require an underscore prefix before implementation-defined interfaces, so the use of these functions are non-standard. However, systems that are actually POSIX-compliant would not accept these underscored names, and it is more portable to just turn off the warning instead.

C
Although the product originated as an IDE for the C programming language, for many years the compiler's support for that language conformed only to the original edition of the C standard, dating from 1989, but not the C99 revision of the standard. There had been no plans to support C99 even in 2011, more than a decade after its publication.Visual C++ 2013 finally added support for various C99 features in its C mode (including designated initializers, compound literals, and the _Bool type), though it was still not complete. Visual C++ 2015 further improved the C99 support, with full support of the C99 Standard Library, except for features that require C99 language features not yet supported by the compiler.Most of the changes from the C11 revision of the standard were still not supported by Visual C++ 2017. For example, generic selections via the _Generic keyword are not supported by the compiler and result in a syntax error.The preprocessor was overhauled in 2018, with C11 in sight:
Full C11 conformance is on our roadmap, and updating the preprocessor is just the first step in that process. The C11 _Generic feature is not actually part of the preprocessor, so it has not yet been implemented. When implemented I expect the feature to work independently of if the traditional or updated preprocessor logic is used.
_Generic support has been committed to MSVC as of February 2020.In September 2020, Microsoft announced C11 and C17 standards support in MSVC. This does not include optional features but as of 2022, experimental support for some of those features has been added.

C++
With default settings MSVC does not do two-phase name lookup which prevents it from flagging a wide range of invalid code.  Most checks are deferred to template instantiation.  More recent versions remedy this behavior, but it needs to be enabled by the command-line option /permissive-.

References
Further reading
External links
Official website
C++ Tools and Features in Visual Studio Editions
Microsoft C++ Build Tools
C9::GoingNative on Microsoft Channel 9