A modified Harvard architecture is a variation of the Harvard computer architecture that, unlike the pure Harvard architecture, allows memory that contains instructions to be accessed as data. Most modern computers that are documented as Harvard architecture are, in fact, modified Harvard architecture.

Harvard architecture
The original Harvard architecture computer, the Harvard Mark I, employed entirely separate memory systems to store instructions and data. The CPU fetched the next instruction and loaded or stored data simultaneously and independently. This is in contrast to a von Neumann architecture computer, in which both instructions and data are stored in the same memory system and (without the complexity of a CPU cache) must be accessed in turn. 
The physical separation of instruction and data memory is sometimes held to be the distinguishing feature of modern Harvard architecture computers. With microcontrollers (entire computer systems integrated onto single chips), the use of different memory technologies for instructions (e.g. flash memory) and data (typically read/write memory) in von Neumann machines is becoming popular. The true distinction of a Harvard machine is that instruction and data memory occupy different address spaces. In other words, a memory address does not uniquely identify a storage location (as it does in a von Neumann machine); it is also necessary to know the memory space (instruction or data) to which the address belongs.

Von Neumann architecture
A computer with a von Neumann architecture has the advantage over Harvard machines as described above in that code can also be accessed and treated the same as data, and vice versa. This allows, for example, data to be read from disk storage into memory and then executed as code, or self-optimizing software systems using technologies such as just-in-time compilation to write machine code into their own memory and then later execute it. Another example is self-modifying code, which allows a program to modify itself. 
A disadvantage of these methods are issues with executable space protection, which increase the risks from malware and software defects.

Modified Harvard architecture
Accordingly, some pure Harvard machines are specialty products. Most modern computers instead implement a modified Harvard architecture. Those modifications are various ways to loosen the strict separation between code and data, while still supporting the higher performance concurrent data and instruction access of the Harvard architecture.

Split-cache (or almost-von-Neumann) architecture
The most common modification builds a memory hierarchy with separate CPU caches for instructions and data at lower levels of the hierarchy. There is a single address space for instructions and data, providing the von Neumann model, but the CPU fetches instructions from the instruction cache and fetches data from the data cache. Most programmers never need to be aware of the fact that the processor core implements a (modified) Harvard architecture, although they benefit from its speed advantages. Only programmers who generate and store instructions into memory need to be aware of issues such as cache coherency, if the store doesn't modify or invalidate a cached copy of the instruction in an instruction cache.

Instruction-memory-as-data architecture
Another change preserves the "separate address space" nature of a Harvard machine, but provides special machine operations to access the contents of the instruction memory as data. Because data is not directly executable as instructions, such machines are not always viewed as "modified" Harvard architecture:

Read access: initial data values can be copied from the instruction memory into the data memory when the program starts. Or, if the data is not to be modified (it might be a constant value, such as pi, or a text string), it can be accessed by the running program directly from instruction memory without taking up space in data memory (which is often at a premium).
Write access: a capability for reprogramming is generally required; few computers are purely ROM-based. For example, a microcontroller usually has operations to write to the flash memory used to hold its instructions. This capability may be used for purposes including software updates.  EEPROM/PROM replacement is an alternative method.

Data-memory-as-instruction architecture
A few Harvard architecture processors, such as the Maxim Integrated MAXQ, can execute instructions fetched from any memory segment – unlike the original Harvard processor, which can only execute instructions fetched from the program memory segment.
Such processors, like other Harvard architecture processors – and unlike pure von Neumann architecture – can read an instruction and read a data value simultaneously, if they're in separate memory segments, since the processor has (at least) two separate memory segments with independent data buses.
The most obvious programmer-visible difference between this kind of modified Harvard architecture and a pure von Neumann architecture is that – when executing an instruction from one memory segment – the same memory segment cannot be simultaneously accessed as data.

Comparisons
Three characteristics may be used to distinguish modified Harvard machines from pure Harvard and von Neumann machines:

Instruction and data memories occupy different address spacesFor pure Harvard machines, there is an address "zero" in instruction space that refers to an instruction storage location and a separate address "zero" in data space that refers to a distinct data storage location. By contrast, von Neumann and split-cache modified Harvard machines store both instructions and data in a single address space, so address "zero" refers to only one location and whether the binary pattern in that location is interpreted as an instruction or data is defined by how the program is written. However, just like pure Harvard machines, instruction-memory-as-data modified Harvard machines have separate address spaces, so have separate addresses "zero" for instruction and data space, so this does not distinguish that type of modified Harvard machines from pure Harvard machines.

Instruction and data memories have separate hardware pathways to the central processing unit (CPU)This is the point of pure or modified Harvard machines, and why they co-exist with the more flexible and general von Neumann architecture: separate memory pathways to the CPU allow instructions to be fetched and data to be accessed at the same time, improving throughput. The pure Harvard machines have separate pathways with separate address spaces. Split-cache modified Harvard machines have such separate access paths for CPU caches or other tightly coupled memories, but a unified access path covers the rest of the memory hierarchy. A von Neumann processor has only that unified access path. From a programmer's point of view, a modified Harvard processor in which instruction and data memories share an address space is usually treated as a von Neumann machine until cache coherency becomes an issue, as with self-modifying code and program loading. This can be confusing, but such issues are usually visible only to systems programmers and integrators. Other modified Harvard machines are like pure Harvard machines in this regard.

Instruction and data memories may be accessed in different waysThe original Harvard machine, the Mark I, stored instructions on a punched paper tape and data in electro-mechanical counters. This, however, was entirely due to the limitations of technology available at the time. Today a Harvard machine such as the PIC microcontroller might use 12-bit wide flash memory for instructions, and 8-bit wide SRAM for data. In contrast, a von Neumann microcontroller such as an ARM7TDMI, or a modified Harvard ARM9 core, necessarily provides uniform access to flash memory and SRAM (as 8 bit bytes, in those cases).

Modern uses of the modified Harvard architecture
Outside of applications where a cacheless DSP or microcontroller is required, most modern processors have a CPU cache which partitions instruction and data.
There are also processors which are Harvard machines by the most rigorous definition (that program and data memory occupy different address spaces), and are only modified in the weak sense that there are operations to read and/or write program memory as data. For example, LPM (Load Program Memory) and SPM (Store Program Memory) instructions in the Atmel AVR implement such a modification. Similar solutions are found in other microcontrollers such as the PIC and Z8Encore!, many families of digital signal processors such as the TI C55x cores, and more. Because instruction execution is still restricted to the program address space, these processors are very unlike von Neumann machines. External wiring can also convert a strictly Harvard CPU core into an modified Harvard one, for example by simply combining `PSEN#` (program space read) and `RD#` (external data space read) signals externally through an AND gate on a Intel 8051 family microcontroller, the microcontroller are said to be "von Neumann connected," as the external data and program address spaces become unified.
Having separate address spaces creates certain difficulties in programming with high-level languages that do not directly support the notion that tables of read-only data might be in a different address space from normal writable data (and thus need to be read using different instructions). The C programming language can support multiple address spaces either through non-standard extensions or through the now standardized extensions to support embedded processors.

See also
Harvard architecture
Von Neumann architecture

Notes


== References ==