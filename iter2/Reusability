In computer science and software engineering, reusability is the use of existing assets in some form within the software product development process; these assets are products and by-products of the software development life cycle and include code, software components, test suites, designs and documentation. The opposite concept of reusability is leverage, which modifies existing assets as needed to meet specific system requirements. Because reuse implies the creation of a separately maintained version of the assets, it is preferred over leverage.Subroutines or functions are the simplest form of reuse. A chunk of code is regularly organized using modules or namespaces into layers. Proponents claim that objects and software components offer a more advanced form of reusability, although it has been tough to objectively measure and define levels or scores of reusability.
The ability to reuse relies in an essential way on the ability to build larger things from smaller parts, and being able to identify commonality among those parts. Reusability is often a required characteristic of platform software. Reusability brings several aspects to software development that do not need to be considered when reusability is not required.
Reusability implies some explicit management of build, packaging, distribution, installation, configuration, deployment, maintenance and upgrade issues. If these issues are not considered, software may appear to be reusable from design point of view, but will not be reused in practice.
Software reusability more specifically refers to design features of a software element (or collection of software elements) that enhance its suitability for reuse.
Many reuse design principles were developed at the WISR workshops.Candidate design features for software reuse include:

Adaptable
Brief: small size
Consistency
Correctness
Extensibility
Fast
Flexible
Generic
Localization of volatile (changeable) design assumptions (David Parnas)
Modularity
Orthogonality
Parameterization
Simple: low complexity
Stability under changing requirementsConsensus has not yet been reached on this list on the relative importance of the entries nor on the issues which make each one important for a particular class of applications.

See also
Code reuse


== References ==