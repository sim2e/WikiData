Computation tree logic (CTL) is a branching-time logic, meaning that its model of time is a tree-like structure in which the future is not determined; there are different paths in the future, any one of which might be an actual path that is realized. It is used in formal verification of software or hardware artifacts, typically by software applications known as model checkers, which determine if a given artifact possesses safety or liveness properties. For example, CTL can specify that when some initial condition is satisfied (e.g., all program variables are positive or no cars on a highway straddle two lanes), then all possible executions of a program avoid some undesirable condition (e.g., dividing a number by zero or two cars colliding on a highway). In this example, the safety property could be verified by a model checker that explores all possible transitions out of program states satisfying the initial condition and ensures that all such executions satisfy the property. Computation tree logic belongs to a class of temporal logics that includes linear temporal logic (LTL). Although there are properties expressible only in CTL and properties expressible only in LTL, all properties expressible in either logic can also be expressed in CTL*.
CTL was first proposed by Edmund M. Clarke and E. Allen Emerson in 1981, who used it to synthesize so-called synchronisation skeletons, i.e abstractions of concurrent programs.

Syntax of CTL
The language of well-formed formulas for CTL is generated by the following grammar:

  
    
      
        
          
            
              
                ϕ
              
              
                
                ::=
                ⊥
                ∣
                ⊤
                ∣
                p
                ∣
                (
                ¬
                ϕ
                )
                ∣
                (
                ϕ
                ∧
                ϕ
                )
                ∣
                (
                ϕ
                ∨
                ϕ
                )
                ∣
                (
                ϕ
                ⇒
                ϕ
                )
                ∣
                (
                ϕ
                ⇔
                ϕ
                )
              
            
            
              
              
                
                ∣
                
                
                  
                    AX 
                  
                
                ϕ
                ∣
                
                  
                    EX 
                  
                
                ϕ
                ∣
                
                  
                    AF 
                  
                
                ϕ
                ∣
                
                  
                    EF 
                  
                
                ϕ
                ∣
                
                  
                    AG 
                  
                
                ϕ
                ∣
                
                  
                    EG 
                  
                
                ϕ
                ∣
                
                  
                    A 
                  
                
                [
                ϕ
                
                  
                     U 
                  
                
                ϕ
                ]
                ∣
                
                  
                    E 
                  
                
                [
                ϕ
                
                  
                     U 
                  
                
                ϕ
                ]
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\phi &::=\bot \mid \top \mid p\mid (\neg \phi )\mid (\phi \land \phi )\mid (\phi \lor \phi )\mid (\phi \Rightarrow \phi )\mid (\phi \Leftrightarrow \phi )\\&\mid \quad {\mbox{AX }}\phi \mid {\mbox{EX }}\phi \mid {\mbox{AF }}\phi \mid {\mbox{EF }}\phi \mid {\mbox{AG }}\phi \mid {\mbox{EG }}\phi \mid {\mbox{A }}[\phi {\mbox{ U }}\phi ]\mid {\mbox{E }}[\phi {\mbox{ U }}\phi ]\end{aligned}}}
  where 
  
    
      
        p
      
    
    {\displaystyle p}
   ranges over a set of atomic formulas. It is not necessary to use all connectives – for example,

  
    
      
        {
        ¬
        ,
        ∧
        ,
        
          
            AX
          
        
        ,
        
          
            AU
          
        
        ,
        
          
            EU
          
        
        }
      
    
    {\displaystyle \{\neg ,\land ,{\mbox{AX}},{\mbox{AU}},{\mbox{EU}}\}}
   comprises a complete set of connectives, and the others can be defined using them.

  
    
      
        
          
            A
          
        
      
    
    {\displaystyle {\mbox{A}}}
   means 'along All paths' (inevitably)

  
    
      
        
          
            E
          
        
      
    
    {\displaystyle {\mbox{E}}}
   means 'along at least (there Exists) one path' (possibly)For example, the following is a well-formed CTL formula:

  
    
      
        
          
            EF 
          
        
        (
        
          
            EG 
          
        
        p
        ⇒
        
          
            AF 
          
        
        r
        )
      
    
    {\displaystyle {\mbox{EF }}({\mbox{EG }}p\Rightarrow {\mbox{AF }}r)}
  The following is not a well-formed CTL formula:

  
    
      
        
          
            EF 
          
        
        
          
            (
          
        
        r
        
          
             U 
          
        
        q
        
          
            )
          
        
      
    
    {\displaystyle {\mbox{EF }}{\big (}r{\mbox{ U }}q{\big )}}
  The problem with this string is that 
  
    
      
        
          U
        
      
    
    {\displaystyle \mathrm {U} }
   can occur only when paired with an 
  
    
      
        
          A
        
      
    
    {\displaystyle \mathrm {A} }
   or an 
  
    
      
        
          E
        
      
    
    {\displaystyle \mathrm {E} }
  . 
CTL uses atomic propositions as its building blocks to make statements about the states of a system.  These propositions are then combined into formulas using logical operators and temporal operators.

Operators
Logical operators
The logical operators are the usual ones: ¬, ∨, ∧, ⇒ and ⇔. Along with these operators CTL formulas can also make use of the boolean constants true and false.

Temporal operators
The temporal operators are the following:

Quantifiers over paths
A Φ – All: Φ has to hold on all paths starting from the current state.
E Φ – Exists: there exists at least one path starting from the current state where Φ holds.
Path-specific quantifiers
X φ – Next: φ has to hold at the next state (this operator is sometimes noted N instead of X).
G φ – Globally: φ has to hold on the entire subsequent path.
F φ – Finally: φ eventually has to hold (somewhere on the subsequent path).
φ U ψ – Until: φ has to hold at least until at some position ψ holds. This implies that ψ will be verified in the future.
φ W ψ – Weak until: φ has to hold until ψ holds. The difference with U is that there is no guarantee that ψ will ever be verified. The W operator is sometimes called "unless".In CTL*, the temporal operators can be freely mixed. In CTL, operators must always be grouped in pairs: one path operator followed by a state operator. See the examples below. CTL* is strictly more expressive than CTL.

Minimal set of operators
In CTL there are minimal sets of operators. All CTL formulas can be transformed to use only those operators. This is useful in model checking. One minimal set of operators is: {true, ∨, ¬, EG, EU, EX}.
Some of the transformations used for temporal operators are:

EFφ == E[trueU(φ)]   ( because Fφ == [trueU(φ)] )
AXφ == ¬EX(¬φ)
AGφ == ¬EF(¬φ) == ¬ E[trueU(¬φ)]
AFφ == A[trueUφ] == ¬EG(¬φ)
A[φUψ] == ¬( E[(¬ψ)U¬(φ∨ψ)] ∨ EG(¬ψ) )

Semantics of CTL
Definition
CTL formulae are interpreted over transition systems.  A transition system is a triple 
  
    
      
        
          
            M
          
        
        =
        (
        S
        ,
        
          →
        
        ,
        L
        )
      
    
    {\displaystyle {\mathcal {M}}=(S,{\rightarrow },L)}
  , where 
  
    
      
        S
      
    
    {\displaystyle S}
   is a set of states, 
  
    
      
        
          →
        
        ⊆
        S
        ×
        S
      
    
    {\displaystyle {\rightarrow }\subseteq S\times S}
   is a transition relation, assumed to be serial, i.e. every state has at least one successor, and 
  
    
      
        L
      
    
    {\displaystyle L}
   is a labelling function, assigning propositional letters to states.  Let 
  
    
      
        
          
            M
          
        
        =
        (
        S
        ,
        →
        ,
        L
        )
      
    
    {\displaystyle {\mathcal {M}}=(S,\rightarrow ,L)}
   be such a transition model, with 
  
    
      
        s
        ∈
        S
      
    
    {\displaystyle s\in S}
  , and 
  
    
      
        ϕ
        ∈
        F
      
    
    {\displaystyle \phi \in F}
  , where 
  
    
      
        F
      
    
    {\displaystyle F}
   is the set of well-formed formulas over the language of 
  
    
      
        
          
            M
          
        
      
    
    {\displaystyle {\mathcal {M}}}
  .
Then the relation of semantic entailment 
  
    
      
        (
        
          
            M
          
        
        ,
        s
        ⊨
        ϕ
        )
      
    
    {\displaystyle ({\mathcal {M}},s\models \phi )}
   is defined recursively on 
  
    
      
        ϕ
      
    
    {\displaystyle \phi }
  :

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        ⊤
        
          
            )
          
        
        ∧
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊭
        ⊥
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models \top {\Big )}\land {\Big (}({\mathcal {M}},s)\not \models \bot {\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        p
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        p
        ∈
        L
        (
        s
        )
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models p{\Big )}\Leftrightarrow {\Big (}p\in L(s){\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        ¬
        ϕ
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊭
        ϕ
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models \neg \phi {\Big )}\Leftrightarrow {\Big (}({\mathcal {M}},s)\not \models \phi {\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            1
          
        
        ∧
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            1
          
        
        
          
            )
          
        
        ∧
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models \phi _{1}\land \phi _{2}{\Big )}\Leftrightarrow {\Big (}{\big (}({\mathcal {M}},s)\models \phi _{1}{\big )}\land {\big (}({\mathcal {M}},s)\models \phi _{2}{\big )}{\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            1
          
        
        ∨
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            1
          
        
        
          
            )
          
        
        ∨
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models \phi _{1}\lor \phi _{2}{\Big )}\Leftrightarrow {\Big (}{\big (}({\mathcal {M}},s)\models \phi _{1}{\big )}\lor {\big (}({\mathcal {M}},s)\models \phi _{2}{\big )}{\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            1
          
        
        ⇒
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊭
        
          ϕ
          
            1
          
        
        
          
            )
          
        
        ∨
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models \phi _{1}\Rightarrow \phi _{2}{\Big )}\Leftrightarrow {\Big (}{\big (}({\mathcal {M}},s)\not \models \phi _{1}{\big )}\lor {\big (}({\mathcal {M}},s)\models \phi _{2}{\big )}{\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            1
          
        
        ⇔
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        
          
            (
          
        
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            1
          
        
        
          
            )
          
        
        ∧
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        
          
            )
          
        
        ∨
        
          
            (
          
        
        ¬
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            1
          
        
        
          
            )
          
        
        ∧
        ¬
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\bigg (}({\mathcal {M}},s)\models \phi _{1}\Leftrightarrow \phi _{2}{\bigg )}\Leftrightarrow {\bigg (}{\Big (}{\big (}({\mathcal {M}},s)\models \phi _{1}{\big )}\land {\big (}({\mathcal {M}},s)\models \phi _{2}{\big )}{\Big )}\lor {\Big (}\neg {\big (}({\mathcal {M}},s)\models \phi _{1}{\big )}\land \neg {\big (}({\mathcal {M}},s)\models \phi _{2}{\big )}{\Big )}{\bigg )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        A
        X
        ϕ
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        ∀
        ⟨
        s
        →
        
          s
          
            1
          
        
        ⟩
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        
          s
          
            1
          
        
        )
        ⊨
        ϕ
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models AX\phi {\Big )}\Leftrightarrow {\Big (}\forall \langle s\rightarrow s_{1}\rangle {\big (}({\mathcal {M}},s_{1})\models \phi {\big )}{\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        E
        X
        ϕ
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        ∃
        ⟨
        s
        →
        
          s
          
            1
          
        
        ⟩
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        
          s
          
            1
          
        
        )
        ⊨
        ϕ
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models EX\phi {\Big )}\Leftrightarrow {\Big (}\exists \langle s\rightarrow s_{1}\rangle {\big (}({\mathcal {M}},s_{1})\models \phi {\big )}{\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        A
        G
        ϕ
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        ∀
        ⟨
        
          s
          
            1
          
        
        →
        
          s
          
            2
          
        
        →
        …
        ⟩
        (
        s
        =
        
          s
          
            1
          
        
        )
        ∀
        i
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        
          s
          
            i
          
        
        )
        ⊨
        ϕ
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models AG\phi {\Big )}\Leftrightarrow {\Big (}\forall \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\forall i{\big (}({\mathcal {M}},s_{i})\models \phi {\big )}{\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        E
        G
        ϕ
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        ∃
        ⟨
        
          s
          
            1
          
        
        →
        
          s
          
            2
          
        
        →
        …
        ⟩
        (
        s
        =
        
          s
          
            1
          
        
        )
        ∀
        i
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        
          s
          
            i
          
        
        )
        ⊨
        ϕ
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models EG\phi {\Big )}\Leftrightarrow {\Big (}\exists \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\forall i{\big (}({\mathcal {M}},s_{i})\models \phi {\big )}{\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        A
        F
        ϕ
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        ∀
        ⟨
        
          s
          
            1
          
        
        →
        
          s
          
            2
          
        
        →
        …
        ⟩
        (
        s
        =
        
          s
          
            1
          
        
        )
        ∃
        i
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        
          s
          
            i
          
        
        )
        ⊨
        ϕ
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models AF\phi {\Big )}\Leftrightarrow {\Big (}\forall \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\exists i{\big (}({\mathcal {M}},s_{i})\models \phi {\big )}{\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        E
        F
        ϕ
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        ∃
        ⟨
        
          s
          
            1
          
        
        →
        
          s
          
            2
          
        
        →
        …
        ⟩
        (
        s
        =
        
          s
          
            1
          
        
        )
        ∃
        i
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        
          s
          
            i
          
        
        )
        ⊨
        ϕ
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\Big (}({\mathcal {M}},s)\models EF\phi {\Big )}\Leftrightarrow {\Big (}\exists \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\exists i{\big (}({\mathcal {M}},s_{i})\models \phi {\big )}{\Big )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        A
        [
        
          ϕ
          
            1
          
        
        U
        
          ϕ
          
            2
          
        
        ]
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        ∀
        ⟨
        
          s
          
            1
          
        
        →
        
          s
          
            2
          
        
        →
        …
        ⟩
        (
        s
        =
        
          s
          
            1
          
        
        )
        ∃
        i
        
          
            (
          
        
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        
          s
          
            i
          
        
        )
        ⊨
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        ∧
        
          
            (
          
        
        ∀
        (
        j
        <
        i
        )
        (
        
          
            M
          
        
        ,
        
          s
          
            j
          
        
        )
        ⊨
        
          ϕ
          
            1
          
        
        
          
            )
          
        
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\bigg (}({\mathcal {M}},s)\models A[\phi _{1}U\phi _{2}]{\bigg )}\Leftrightarrow {\bigg (}\forall \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\exists i{\Big (}{\big (}({\mathcal {M}},s_{i})\models \phi _{2}{\big )}\land {\big (}\forall (j<i)({\mathcal {M}},s_{j})\models \phi _{1}{\big )}{\Big )}{\bigg )}}
  

  
    
      
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        s
        )
        ⊨
        E
        [
        
          ϕ
          
            1
          
        
        U
        
          ϕ
          
            2
          
        
        ]
        
          
            )
          
        
        ⇔
        
          
            (
          
        
        ∃
        ⟨
        
          s
          
            1
          
        
        →
        
          s
          
            2
          
        
        →
        …
        ⟩
        (
        s
        =
        
          s
          
            1
          
        
        )
        ∃
        i
        
          
            (
          
        
        
          
            (
          
        
        (
        
          
            M
          
        
        ,
        
          s
          
            i
          
        
        )
        ⊨
        
          ϕ
          
            2
          
        
        
          
            )
          
        
        ∧
        
          
            (
          
        
        ∀
        (
        j
        <
        i
        )
        (
        
          
            M
          
        
        ,
        
          s
          
            j
          
        
        )
        ⊨
        
          ϕ
          
            1
          
        
        
          
            )
          
        
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\bigg (}({\mathcal {M}},s)\models E[\phi _{1}U\phi _{2}]{\bigg )}\Leftrightarrow {\bigg (}\exists \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\exists i{\Big (}{\big (}({\mathcal {M}},s_{i})\models \phi _{2}{\big )}\land {\big (}\forall (j<i)({\mathcal {M}},s_{j})\models \phi _{1}{\big )}{\Big )}{\bigg )}}

Characterisation of CTL
Rules 10–15 above refer to computation paths in models and are what ultimately characterise the "Computation Tree";
they are assertions about the nature of the infinitely deep computation tree rooted at the given state 
  
    
      
        s
      
    
    {\displaystyle s}
  .

Semantic equivalences
The formulae 
  
    
      
        ϕ
      
    
    {\displaystyle \phi }
   and 
  
    
      
        ψ
      
    
    {\displaystyle \psi }
   are said to be semantically equivalent if any state in any model that satisfies one also satisfies the other.
This is denoted 
  
    
      
        ϕ
        ≡
        ψ
      
    
    {\displaystyle \phi \equiv \psi }
  
It can be seen that 
  
    
      
        
          A
        
      
    
    {\displaystyle \mathrm {A} }
   and 
  
    
      
        
          E
        
      
    
    {\displaystyle \mathrm {E} }
   are duals, being universal and existential computation path quantifiers respectively:

  
    
      
        ¬
        
          A
        
        Φ
        ≡
        
          E
        
        ¬
        Φ
      
    
    {\displaystyle \neg \mathrm {A} \Phi \equiv \mathrm {E} \neg \Phi }
  .
Furthermore, so are 
  
    
      
        
          G
        
      
    
    {\displaystyle \mathrm {G} }
   and 
  
    
      
        
          F
        
      
    
    {\displaystyle \mathrm {F} }
  .
Hence an instance of De Morgan's laws can be formulated in CTL:

  
    
      
        ¬
        A
        F
        ϕ
        ≡
        E
        G
        ¬
        ϕ
      
    
    {\displaystyle \neg AF\phi \equiv EG\neg \phi }
  

  
    
      
        ¬
        E
        F
        ϕ
        ≡
        A
        G
        ¬
        ϕ
      
    
    {\displaystyle \neg EF\phi \equiv AG\neg \phi }
  

  
    
      
        ¬
        A
        X
        ϕ
        ≡
        E
        X
        ¬
        ϕ
      
    
    {\displaystyle \neg AX\phi \equiv EX\neg \phi }
  It can be shown using such identities that a subset of the CTL temporal connectives is adequate if it contains 
  
    
      
        E
        U
      
    
    {\displaystyle EU}
  , at least one of 
  
    
      
        {
        A
        X
        ,
        E
        X
        }
      
    
    {\displaystyle \{AX,EX\}}
   and at least one of 
  
    
      
        {
        E
        G
        ,
        A
        F
        ,
        A
        U
        }
      
    
    {\displaystyle \{EG,AF,AU\}}
   and the boolean connectives.
The important equivalences below are called the expansion laws; they allow unfolding the verification of a CTL connective towards its successors in time.

  
    
      
        A
        G
        ϕ
        ≡
        ϕ
        ∧
        A
        X
        A
        G
        ϕ
      
    
    {\displaystyle AG\phi \equiv \phi \land AXAG\phi }
  

  
    
      
        E
        G
        ϕ
        ≡
        ϕ
        ∧
        E
        X
        E
        G
        ϕ
      
    
    {\displaystyle EG\phi \equiv \phi \land EXEG\phi }
  

  
    
      
        A
        F
        ϕ
        ≡
        ϕ
        ∨
        A
        X
        A
        F
        ϕ
      
    
    {\displaystyle AF\phi \equiv \phi \lor AXAF\phi }
  

  
    
      
        E
        F
        ϕ
        ≡
        ϕ
        ∨
        E
        X
        E
        F
        ϕ
      
    
    {\displaystyle EF\phi \equiv \phi \lor EXEF\phi }
  

  
    
      
        A
        [
        ϕ
        U
        ψ
        ]
        ≡
        ψ
        ∨
        (
        ϕ
        ∧
        A
        X
        A
        [
        ϕ
        U
        ψ
        ]
        )
      
    
    {\displaystyle A[\phi U\psi ]\equiv \psi \lor (\phi \land AXA[\phi U\psi ])}
  

  
    
      
        E
        [
        ϕ
        U
        ψ
        ]
        ≡
        ψ
        ∨
        (
        ϕ
        ∧
        E
        X
        E
        [
        ϕ
        U
        ψ
        ]
        )
      
    
    {\displaystyle E[\phi U\psi ]\equiv \psi \lor (\phi \land EXE[\phi U\psi ])}

Examples
Let "P" mean "I like chocolate" and Q mean "It's warm outside."

AG.P"I will like chocolate from now on, no matter what happens."EF.P"It's possible I may like chocolate some day, at least for one day."AF.EG.P"It's always possible (AF) that I will suddenly start liking chocolate for the rest of time." (Note: not just the rest of my life, since my life is finite, while G is infinite).EG.AF.P"Depending on what happens in the future (E), it's possible that for the rest of time (G), I'll be guaranteed at least one (AF) chocolate-liking day still ahead of me. However, if something ever goes wrong, then all bets are off and there's no guarantee about whether I'll ever like chocolate."The two following examples show the difference between CTL and CTL*, as they allow for the until operator to not be qualified with any path operator (A or E):

AG(PUQ)"From now until it's warm outside, I will like chocolate every single day.  Once it's warm outside, all bets are off as to whether I'll like chocolate anymore.  Oh, and it's guaranteed to be warm outside eventually, even if only for a single day."EF((EX.P)U(AG.Q))"It's possible that: there will eventually come a time when it will be warm forever (AG.Q) and that before that time there will always be some way to get me to like chocolate the next day (EX.P)."

Relations with other logics
Computation tree logic (CTL) is a subset of CTL* as well as of the modal μ calculus. CTL is also a fragment of Alur, Henzinger and Kupferman's alternating-time temporal logic (ATL).
Computation tree logic (CTL) and linear temporal logic (LTL) are both a subset of CTL*. CTL and LTL are not equivalent and they have a common subset, which is a proper subset of both CTL and LTL.

FG.P exists in LTL but not in CTL.
AG(P⇒((EX.Q)∧(EX¬Q))) and AG.EF.P exist in CTL but not in LTL.

Extensions
CTL has been extended with second-order quantification 
  
    
      
        ∃
        p
      
    
    {\displaystyle \exists p}
   and 
  
    
      
        ∀
        p
      
    
    {\displaystyle \forall p}
   to quantified computational tree logic (QCTL). There are two semantics:

the tree semantics. We label nodes of the computation tree. QCTL* = QCTL = MSO over trees. Model checking and satisfiability are tower complete.
the structure semantics. We label states. QCTL* = QCTL = MSO over graphs. Model checking is PSPACE-complete but satisfiability is undecidable.A reduction from the model-checking problem of QCTL with the structure semantics, to TQBF (true quantified Boolean formulae) has been proposed, in order to take advantage of the QBF solvers.

See also
Probabilistic CTL
Fair computational tree logic
Linear temporal logic

References
E.M. Clarke; E.A. Emerson (1981). "Design and synthesis of synchronisation skeletons using branching time temporal logic" (PDF). Logic of Programs, Proceedings of Workshop, Lecture Notes in Computer Science. Lecture Notes in Computer Science. Springer, Berlin. 131: 52–71. doi:10.1007/BFb0025774. ISBN 3-540-11212-X.
Michael Huth; Mark Ryan (2004). Logic in Computer Science (Second ed.). Cambridge University Press. p. 207. ISBN 978-0-521-54310-1.
Emerson, E. A.; Halpern, J. Y. (1985). "Decision procedures and expressiveness in the temporal logic of branching time". Journal of Computer and System Sciences. 30 (1): 1–24. doi:10.1016/0022-0000(85)90001-7.
Clarke, E. M.; Emerson, E. A. & Sistla, A. P. (1986). "Automatic verification of finite-state concurrent systems using temporal logic specifications". ACM Transactions on Programming Languages and Systems. 8 (2): 244–263. doi:10.1145/5397.5399. S2CID 52853200.
Emerson, E. A. (1990). "Temporal and modal logic". In Jan van Leeuwen (ed.). Handbook of Theoretical Computer Science, vol. B. MIT Press. pp. 955–1072. ISBN 978-0-262-22039-2.

External links
Teaching slides of CTL