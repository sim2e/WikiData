In computer architecture, 16-bit integers, memory addresses, or other data units are those that are  16 bits (2 octets) wide.  Also, 16-bit central processing unit (CPU) and arithmetic logic unit (ALU) architectures are those that are based on registers, address buses, or data buses of that size. 16-bit microcomputers are microcomputers that use 16-bit microprocessors.
A 16-bit register can store 216 different values. The range of integer values that can be stored in 16 bits depends on the integer representation used. With the two most common representations, the range is 0 through 65,535 (216 − 1) for representation as an (unsigned) binary number, and −32,768 (−1 × 215) through 32,767 (215 − 1) for representation as two's complement. Since 216 is 65,536, a processor with 16-bit memory addresses can directly access 64 KB (65,536 bytes) of byte-addressable memory. If a system uses segmentation with 16-bit segment offsets, more can be accessed.

16-bit architecture
The MIT Whirlwind (c. 1951) was quite possibly the first-ever 16-bit computer. It was an unusual word size for the era; most systems used six-bit character code and used a word length of some multiple of 6-bits. This changed with the effort to introduce ASCII, which used a 7-bit code and naturally led to the use of an 8-bit multiple which could store a single ASCII character or two binary coded decimal digits.
The 16-bit word length thus became more common in the 1960s, especially on minicomputer systems. Early 16-bit computers (c. 1965–70) include the IBM 1130, the HP 2100, the Data General Nova, and the DEC PDP-11. Early 16-bit microprocessors, often modeled on one of the mini platforms, began to appear in the 1970s.  Examples (c. 1973–76) include the five-chip National Semiconductor IMP-16 (1973), the two-chip NEC μCOM-16 (1974), the three-chip Western Digital MCP-1600 (1975), and the five-chip Toshiba T-3412 (1976).Early single-chip 16-bit microprocessors (c. 1975–76) include the Panafacom MN1610 (1975), National Semiconductor PACE (1975), General Instrument CP1600 (1975), Texas Instruments TMS9900 (1976), Ferranti F100-L, and the HP BPC. Other notable 16-bit processors include the Intel 8086, the Intel 80286, the WDC 65C816, and the Zilog Z8000. The Intel 8088 was binary compatible with the Intel 8086, and was 16-bit in that its registers were 16 bits wide, and arithmetic instructions could operate on 16-bit quantities, even though its external bus was 8 bits wide.
16-bit processors have been almost entirely supplanted in the personal computer industry, and are used less than 32-bit (or 8-bit) CPUs in embedded applications.

16/32-bit Motorola 68000 and Intel 386SX
The Motorola 68000 is sometimes called 16-bit because of the way it handles basic arithmetic. The instruction set was based on 32-bit numbers and the internal registers were 32 bits wide, so by common definitions, the 68000 is a 32-bit design. Internally, 32-bit arithmetic is performed using two 16-bit operations, and this leads to some descriptions of the system as 16-bit, or "16/32".
Such solutions have a long history in the computer field, with various designs performing math even 1-bit at a time, known as "serial arithmetic", while most designs by the 1970s processed at least a few bits at a time. A common example is the Data General Nova, which was a 16-bit design that performed 16-bit math as a series of four 4-bit operations. 4-bits was the word size of a widely available single-chip ALU and thus allowed for inexpensive implementation. Using the definition being applied to the 68000, the Nova would be a 4-bit computer, or 4/16. Not long after the introduction of the Nova a second version was introduced, the SuperNova, which included four of the 4-bit ALUs running in parallel to perform math 16 bits at a time and therefore offer higher performance. This was invisible to the user and the programs, which always used 16-bit instructions and data. In a similar fashion, later 68000-family members, like the Motorola 68020, had 32-bit ALUs.
One may also see references to systems being, or not being, 16-bit based on some other measure. One common one is when the address space is not the same size of bits as the internal registers. Most 8-bit CPUs of the 1970s fall into this category; the MOS 6502, Intel 8080, Zilog Z80 and most others had 16-bit address space which provided 64 KB of address space. This also meant address manipulation required two instruction cycles. For this reason, most processors had special 8-bit addressing modes, the zero page, improving speed. This sort of difference between internal register size and external address size remained in the 1980s, although often reversed, as memory costs of the era made a machine with 32-bit addressing, 2 or 4 GB, a practical impossibility. For example, the 68000 exposed only 24 bits of addressing on the DIP, limiting it to a still huge (for the era) 16 MB.A similar analysis applies to Intel's 80286 CPU replacement, called the 386SX, which is a 32-bit processor with 32-bit ALU and internal 32-bit data paths with a 16-bit external bus and 24-bit addressing of the processor it replaced.

16-bit application
In the context of IBM PC compatible and Wintel platforms, a 16-bit application is any software written for MS-DOS, OS/2 1.x or early versions of Microsoft Windows which originally ran on the 16-bit Intel 8088 and Intel 80286 microprocessors. Such applications used a 20-bit or 24-bit segment or selector-offset address representation to extend the range of addressable memory locations beyond what was possible using only 16-bit addresses. Programs containing more than 216 bytes (65,536 bytes) of instructions and data therefore required special instructions to switch between their 64-kilobyte segments, increasing the complexity of programming 16-bit applications.

List of 16-bit CPUs
See also
Microprocessor § 16-bit designs
Influence of the IBM PC on the personal computer market § Before the IBM PC's introduction
74181 (key component of some early 16-bit and other CPUs)
Audio bit depth – as 16-bit is the most common bit depth used, e.g. on CD audio.


== References ==