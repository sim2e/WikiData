Geometry processing, or mesh processing, is an area of research that uses concepts from applied mathematics, computer science and engineering to design efficient algorithms for the acquisition, reconstruction, analysis, manipulation, simulation and transmission of complex 3D models.  As the name implies, many of the concepts, data structures, and algorithms are directly analogous to signal processing and image processing. For example, where image smoothing might convolve an intensity signal with a blur kernel formed using the Laplace operator, geometric smoothing might be achieved by convolving a surface geometry with a blur kernel formed using the Laplace-Beltrami operator.
Applications of geometry processing algorithms already cover a wide range of areas from multimedia, entertainment and classical computer-aided design, to biomedical computing, reverse engineering, and scientific computing.Geometry processing is a common research topic at SIGGRAPH, the premier computer graphics academic conference, and the main topic of the annual Symposium on Geometry Processing.

Geometry processing as a life cycle
Geometry processing involves working with a shape, usually in 2D or 3D, although the shape can live in a space of arbitrary dimensions. The processing of a shape involves three stages, which is known as its life cycle. At its "birth," a shape can be instantiated through one of three methods: a model, a mathematical representation, or a scan. After a shape is born, it can be analyzed and edited repeatedly in a cycle. This usually involves acquiring different measurements, such as the distances between the points of the shape, the smoothness of the shape, or its Euler characteristic. Editing may involve denoising, deforming, or performing rigid transformations. At the final stage of the shape's "life," it is consumed. This can mean it is consumed by a viewer as a rendered asset in a game or movie, for instance. The end of a shape's life can also be defined by a decision about the shape, like whether or not it satisfies some criteria. Or it can even be fabricated in the real world, through a method such as 3D printing or laser cutting.

Discrete Representation of a Shape
Like any other shape, the shapes used in geometry processing have properties pertaining to their geometry and topology. The geometry of a shape concerns the position of the shape's points in space, tangents, normals, and curvature. It also includes the dimension in which the shape lives (ex. 
  
    
      
        
          R
          
            2
          
        
      
    
    {\displaystyle R^{2}}
   or 
  
    
      
        
          R
          
            3
          
        
      
    
    {\displaystyle R^{3}}
  ). The topology of a shape is a collection of properties that do not change even after smooth transformations have been applied to the shape. It concerns dimensions such as the number of holes and boundaries, as well as the orientability of the shape. One example of a non-orientable shape is the Mobius strip.
In computers, everything must be discretized. Shapes in geometry processing are usually represented as triangle meshes, which can be seen as a graph. Each node in the graph is a vertex (usually in 
  
    
      
        
          R
          
            3
          
        
      
    
    {\displaystyle R^{3}}
  ), which has a position. This encodes the geometry of the shape. Directed edges connect these vertices into triangles, which by the right hand rule, then have a direction called the normal. Each triangle forms a face of the mesh. These are combinatoric in nature and encode the topology of the shape. In addition to triangles, a more general class of polygon meshes can also be used to represent a shape. More advanced representations like progressive meshes encode a coarse representation along with a sequence of transformations, which produce a fine or high resolution representation of the shape once applied. These meshes are useful in a variety of applications, including geomorphs, progressive transmission, mesh compression, and selective refinement.

Properties of a shape
Euler Characteristic
One particularly important property of a 3D shape is its Euler characteristic, which can alternatively be defined in terms of its genus. The formula for this in the continuous sense is 
  
    
      
        χ
        =
        2
        c
        −
        2
        h
        −
        b
      
    
    {\displaystyle \chi =2c-2h-b}
  , where 
  
    
      
        c
      
    
    {\displaystyle c}
   is the number of connected components, 
  
    
      
        h
      
    
    {\displaystyle h}
   is number of holes (as in donut holes, see torus), and 
  
    
      
        b
      
    
    {\displaystyle b}
   is the number of connected components of the boundary of the surface. A concrete example of this is a mesh of a pair of pants. There is one connected component, 0 holes, and 3 connected components of the boundary (the waist and two leg holes). So in this case, the Euler characteristic is -1. To bring this into the discrete world, the Euler characteristic of a mesh is computed in terms of its vertices, edges, and faces. 
  
    
      
        χ
        =
        
          |
        
        V
        
          |
        
        −
        
          |
        
        E
        
          |
        
        +
        
          |
        
        F
        
          |
        
      
    
    {\displaystyle \chi =|V|-|E|+|F|}
  .

Surface reconstruction
Poisson reconstruction from surface points to mesh
Depending on how a shape is initialized or "birthed," the shape might exist only as a nebula of sampled points that represent its surface in space. To transform the surface points into a mesh, the Poisson reconstruction strategy can be employed. This method states that the indicator function, a function that determines which points in space belong to the surface of the shape, can actually be computed from the sampled points. The key concept is that gradient of the indicator function is 0 everywhere, except at the sampled points, where it is equal to the inward surface normal. More formally, suppose the collection of sampled points from the surface is denoted by 
  
    
      
        S
      
    
    {\displaystyle S}
  , each point in the space by 
  
    
      
        
          p
          
            i
          
        
      
    
    {\displaystyle p_{i}}
  , and the corresponding normal at that point by 
  
    
      
        
          n
          
            i
          
        
      
    
    {\displaystyle n_{i}}
  . Then the gradient of the indicator function is defined as:

  
    
      
        ▽
        g
        =
        
          
            {
            
              
                
                  
                    
                      
                        n
                      
                    
                    
                      i
                    
                  
                  ,
                
                
                  ∀
                  
                    p
                    
                      i
                    
                  
                  ∈
                  S
                
              
              
                
                  0
                  ,
                
                
                  
                    otherwise
                  
                
              
            
            
          
        
      
    
    {\displaystyle \triangledown g={\begin{cases}{\textbf {n}}_{i},&\forall p_{i}\in S\\0,&{\text{otherwise}}\end{cases}}}
  
The task of reconstruction then becomes a variational problem. To find the indicator function of the surface, we must find a function 
  
    
      
        χ
      
    
    {\displaystyle \chi }
   such that 
  
    
      
        ‖
        ▽
        χ
        −
        
          
            V
          
        
        ‖
      
    
    {\displaystyle \lVert \triangledown \chi -{\textbf {V}}\rVert }
   is minimized, where 
  
    
      
        
          
            V
          
        
      
    
    {\displaystyle {\textbf {V}}}
   is the vector field defined by the samples. As a variational problem, one can view the minimizer 
  
    
      
        χ
      
    
    {\displaystyle \chi }
  as a solution of Poisson's equation. After obtaining a good approximation for 
  
    
      
        χ
      
    
    {\displaystyle \chi }
   and a value 
  
    
      
        σ
      
    
    {\displaystyle \sigma }
    for which the points 
  
    
      
        (
        x
        ,
        y
        ,
        z
        )
      
    
    {\displaystyle (x,y,z)}
   with 
  
    
      
        χ
        (
        x
        ,
        y
        ,
        z
        )
        =
        σ
      
    
    {\displaystyle \chi (x,y,z)=\sigma }
   lie on the surface to be reconstructed, the marching cubes algorithm can be used to construct a triangle mesh from the function  
  
    
      
        χ
      
    
    {\displaystyle \chi }
   , which can then be applied in subsequent computer graphics applications.

Registration
One common problem encountered in geometry processing is how to merge multiple views of a single object captured from different angles or positions. This problem is known as registration. In registration, we wish to find an optimal rigid transformation that will align surface 
  
    
      
        X
      
    
    {\displaystyle X}
   with surface 
  
    
      
        Y
      
    
    {\displaystyle Y}
  . More formally, if 
  
    
      
        
          P
          
            Y
          
        
        (
        x
        )
      
    
    {\displaystyle P_{Y}(x)}
   is the projection of a point x from surface 
  
    
      
        X
      
    
    {\displaystyle X}
   onto surface 
  
    
      
        Y
      
    
    {\displaystyle Y}
  , we want to find the optimal rotation matrix 
  
    
      
        R
      
    
    {\displaystyle R}
   and translation vector 
  
    
      
        t
      
    
    {\displaystyle t}
   that minimize the following objective function:

  
    
      
        
          ∫
          
            x
            ∈
            X
          
        
        
          |
        
        
          |
        
        R
        x
        +
        t
        −
        
          P
          
            Y
          
        
        (
        x
        )
        
          |
        
        
          |
        
        d
        x
      
    
    {\displaystyle \int _{x\in X}||Rx+t-P_{Y}(x)||dx}
  
While rotations are non-linear in general, small rotations can be linearized as skew-symmetric matrices. Moreover, the distance function 
  
    
      
        x
        −
        
          P
          
            Y
          
        
        (
        x
        )
      
    
    {\displaystyle x-P_{Y}(x)}
   is non-linear, but is amenable to linear approximations if the change in 
  
    
      
        X
      
    
    {\displaystyle X}
   is small. An iterative solution such as Iterative Closest Point (ICP) is therefore employed to solve for small transformations iteratively, instead of solving for the potentially large transformation in one go. In ICP, n random sample points from 
  
    
      
        X
      
    
    {\displaystyle X}
   are chosen and projected onto 
  
    
      
        Y
      
    
    {\displaystyle Y}
  . In order to sample points uniformly at random across the surface of the triangle mesh, the random sampling is broken into two stages: uniformly sampling points within a triangle; and non-uniformly sampling triangles, such that each triangle's associated probability is proportional to its surface area. Thereafter, the optimal transformation is calculated based on the difference between each 
  
    
      
        x
      
    
    {\displaystyle x}
   and its projection. In the following iteration, the projections are calculated based on the result of applying the previous transformation on the samples. The process is repeated until convergence.

Smoothing
When shapes are defined or scanned, there may be accompanying noise, either to a signal acting upon the surface or to the actual surface geometry. Reducing noise on the former is known as data denoising, while noise reduction on the latter is known as surface fairing. The task of geometric smoothing is analogous to signal noise reduction, and consequently employs similar approaches.
The pertinent Lagrangian to be minimized is derived by recording the conformity to the initial signal 
  
    
      
        
          
            
              f
              ¯
            
          
        
      
    
    {\displaystyle {\bar {f}}}
   and the smoothness of the resulting signal, which approximated by the magnitude of the gradient with a weight 
  
    
      
        λ
      
    
    {\displaystyle \lambda }
  :

  
    
      
        
          
            L
          
        
        (
        f
        )
        =
        
          ∫
          
            Ω
          
        
        ‖
        f
        −
        
          
            
              f
              ¯
            
          
        
        
          ‖
          
            2
          
        
        +
        λ
        ‖
        ∇
        f
        
          ‖
          
            2
          
        
        d
        x
      
    
    {\displaystyle {\mathcal {L}}(f)=\int _{\Omega }\|f-{\bar {f}}\|^{2}+\lambda \|\nabla f\|^{2}dx}
  .
Taking a variation 
  
    
      
        δ
        f
      
    
    {\displaystyle \delta f}
   on 
  
    
      
        
          
            L
          
        
      
    
    {\displaystyle {\mathcal {L}}}
   emits the necessary condition

  
    
      
        0
        =
        δ
        
          
            L
          
        
        (
        f
        )
        =
        
          ∫
          
            Ω
          
        
        δ
        f
        (
        
          I
        
        +
        λ
        
          ∇
          
            2
          
        
        )
        f
        −
        δ
        f
        
          
            
              f
              ¯
            
          
        
        d
        x
      
    
    {\displaystyle 0=\delta {\mathcal {L}}(f)=\int _{\Omega }\delta f(\mathbf {I} +\lambda \nabla ^{2})f-\delta f{\bar {f}}dx}
  .
By discretizing this onto piecewise-constant elements with our signal on the vertices we obtain

  
    
      
        
          
            
              
                
                  ∑
                  
                    i
                  
                
                
                  M
                  
                    i
                  
                
                δ
                
                  f
                  
                    i
                  
                
                
                  
                    
                      
                        f
                        ¯
                      
                    
                  
                  
                    i
                  
                
              
              
                
                =
                
                  ∑
                  
                    i
                  
                
                
                  M
                  
                    i
                  
                
                δ
                
                  f
                  
                    i
                  
                
                
                  ∑
                  
                    j
                  
                
                (
                
                  I
                
                +
                λ
                
                  ∇
                  
                    2
                  
                
                )
                
                  f
                  
                    j
                  
                
                =
                
                  ∑
                  
                    i
                  
                
                δ
                
                  f
                  
                    i
                  
                
                
                  ∑
                  
                    j
                  
                
                (
                M
                +
                λ
                M
                
                  ∇
                  
                    2
                  
                
                )
                
                  f
                  
                    j
                  
                
                ,
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\sum _{i}M_{i}\delta f_{i}{\bar {f}}_{i}&=\sum _{i}M_{i}\delta f_{i}\sum _{j}(\mathbf {I} +\lambda \nabla ^{2})f_{j}=\sum _{i}\delta f_{i}\sum _{j}(M+\lambda M\nabla ^{2})f_{j},\end{aligned}}}
  where our choice of 
  
    
      
        
          ∇
          
            2
          
        
      
    
    {\displaystyle \nabla ^{2}}
   is chosen to be 
  
    
      
        
          M
          
            −
            1
          
        
        
          L
        
      
    
    {\displaystyle M^{-1}\mathbf {L} }
   for the cotangent Laplacian 
  
    
      
        
          L
        
      
    
    {\displaystyle \mathbf {L} }
   and the 
  
    
      
        
          M
          
            −
            1
          
        
      
    
    {\displaystyle M^{-1}}
   term is to map the image of the Laplacian from areas to points. Because the variation is free, this results in a self-adjoint linear problem to solve with a parameter 
  
    
      
        λ
      
    
    {\displaystyle \lambda }
  : 
  
    
      
        
          
            
              f
              ¯
            
          
        
        =
        (
        M
        +
        λ
        
          L
        
        )
        f
        .
      
    
    {\displaystyle {\bar {f}}=(M+\lambda \mathbf {L} )f.}
   When working with triangle meshes one way to determine the values of the Laplacian matrix 
  
    
      
        L
      
    
    {\displaystyle L}
   is through analyzing the geometry of connected triangles on the mesh.

  
    
      
        
          L
          
            i
            j
          
        
        =
        
          
            {
            
              
                
                  
                    
                      1
                      2
                    
                  
                  (
                  cot
                  ⁡
                  (
                  
                    α
                    
                      i
                      j
                    
                  
                  )
                  +
                  cot
                  ⁡
                  (
                  
                    β
                    
                      i
                      j
                    
                  
                  )
                  )
                
                
                  
                    edge ij exists
                  
                
              
              
                
                  −
                  
                    ∑
                    
                      i
                      ≠
                      j
                    
                  
                  
                    L
                    
                      i
                      j
                    
                  
                
                
                  i
                  =
                  j
                
              
              
                
                  0
                
                
                  
                    otherwise
                  
                
              
            
            
          
        
      
    
    {\displaystyle L_{ij}={\begin{cases}{\frac {1}{2}}(\cot(\alpha _{ij})+\cot(\beta _{ij}))&{\text{edge ij exists}}\\-\sum \limits _{i\neq j}L_{ij}&i=j\\0&{\text{otherwise}}\end{cases}}}
  
Where 
  
    
      
        
          α
          
            i
            j
          
        
      
    
    {\displaystyle \alpha _{ij}}
   and 
  
    
      
        
          β
          
            i
            j
          
        
      
    
    {\displaystyle \beta _{ij}}
   are the angles opposite the edge 
  
    
      
        (
        i
        ,
        j
        )
      
    
    {\displaystyle (i,j)}
  
The mass matrix M as an operator computes the local integral of a function's value and is often set for a mesh with m triangles as follows:

  
    
      
        
          M
          
            i
            j
          
        
        =
        
          
            {
            
              
                
                  
                    
                      1
                      3
                    
                  
                  
                    ∑
                    
                      t
                      =
                      1
                    
                    
                      m
                    
                  
                  
                    
                      {
                      
                        
                          
                            A
                            r
                            e
                            a
                            (
                            t
                            )
                          
                          
                            
                              if triangle t contains vertex i
                            
                          
                        
                        
                          
                            0
                          
                          
                            
                              otherwise
                            
                          
                        
                      
                      
                    
                  
                
                
                  
                    if i=j
                  
                
              
              
                
                  0
                
                
                  
                    otherwise
                  
                
              
            
            
          
        
      
    
    {\displaystyle M_{ij}={\begin{cases}{\frac {1}{3}}\sum \limits _{t=1}^{m}{\begin{cases}Area(t)&{\text{if triangle t contains vertex i}}\\0&{\text{otherwise}}\end{cases}}&{\text{if i=j}}\\0&{\text{otherwise}}\end{cases}}}

Parameterization
Occasionally, we need to flatten a 3D surface onto a flat plane. This process is known as parameterization. The goal is to find coordinates u and v onto which we can map the surface so that distortions are minimized. In this manner, parameterization can be seen as an optimization problem. One of the major applications of mesh parameterization is texture mapping.

Mass springs method
One way to measure the distortion accrued in the mapping process is to measure how much the length of the edges on the 2D mapping differs from their lengths in the original 3D surface. In more formal terms, the objective function can be written as:

  
    
      
        
          
            min
            U
          
        
        
          ∑
          
            i
            j
            ∈
            E
          
        
        
          |
        
        
          |
        
        
          u
          
            i
          
        
        −
        
          u
          
            j
          
        
        
          |
        
        
          
            |
          
          
            2
          
        
      
    
    {\displaystyle {\underset {U}{\text{min}}}\sum _{ij\in E}||u_{i}-u_{j}||^{2}}
  
Where 
  
    
      
        E
      
    
    {\displaystyle E}
   is the set of mesh edges and 
  
    
      
        U
      
    
    {\displaystyle U}
   is the set of vertices. However, optimizing this objective function would result in a solution that maps all of the vertices to a single vertex in the uv-coordinates. Borrowing an idea from graph theory, we apply the Tutte Mapping and restrict the boundary vertices of the mesh onto a unit circle or other convex polygon. Doing so prevents the vertices from collapsing into a single vertex when the mapping is applied. The non-boundary vertices are then positioned at the barycentric interpolation of their neighbours. The Tutte Mapping, however, still suffers from severe distortions as it attempts to make the edge lengths equal, and hence does not correctly account for the triangle sizes on the actual surface mesh.

Least-squares conformal mappings
Another way to measure the distortion is to consider the variations on the u and v coordinate functions. The wobbliness and distortion apparent in the mass springs methods are due to high variations in the u and v coordinate functions. With this approach, the objective function becomes the Dirichlet energy on u and v:

  
    
      
        
          
            min
            
              u
              ,
              v
            
          
        
        
          ∫
          
            S
          
        
        
          |
        
        
          |
        
        ∇
        u
        
          |
        
        
          
            |
          
          
            2
          
        
        +
        
          |
        
        
          |
        
        ∇
        v
        
          |
        
        
          
            |
          
          
            2
          
        
        d
        A
      
    
    {\displaystyle {\underset {u,v}{\text{min}}}\int _{S}||\nabla u||^{2}+||\nabla v||^{2}dA}
  
There are a few other things to consider. We would like to minimize the angle distortion to preserve orthogonality. That means we would like 
  
    
      
        ∇
        u
        =
        ∇
        
          v
          
            ⊥
          
        
      
    
    {\displaystyle \nabla u=\nabla v^{\perp }}
  . In addition, we would also like the mapping to have proportionally similar sized regions as the original. This results to setting the Jacobian of the u and v coordinate functions to 1.

  
    
      
        
          
            [
            
              
                
                  
                    
                      
                        
                          ∂
                          u
                        
                        
                          ∂
                          x
                        
                      
                    
                  
                
                
                  
                    
                      
                        
                          ∂
                          u
                        
                        
                          ∂
                          y
                        
                      
                    
                  
                
              
              
                
                  
                    
                      
                        
                          ∂
                          v
                        
                        
                          ∂
                          x
                        
                      
                    
                  
                
                
                  
                    
                      
                        
                          ∂
                          v
                        
                        
                          ∂
                          y
                        
                      
                    
                  
                
              
            
            ]
          
        
        =
        1
      
    
    {\displaystyle {\begin{bmatrix}{\dfrac {\partial u}{\partial x}}&{\dfrac {\partial u}{\partial y}}\\[1em]{\dfrac {\partial v}{\partial x}}&{\dfrac {\partial v}{\partial y}}\end{bmatrix}}=1}
  
Putting these requirements together, we can augment the Dirichlet energy so that our objective function becomes:
  
    
      
        
          
            min
            
              u
              ,
              v
            
          
        
        
          ∫
          
            S
          
        
        
          
            1
            2
          
        
        
          |
        
        
          |
        
        ∇
        u
        
          |
        
        
          
            |
          
          
            2
          
        
        +
        
          
            1
            2
          
        
        
          |
        
        
          |
        
        ∇
        v
        
          |
        
        
          
            |
          
          
            2
          
        
        −
        ∇
        u
        ⋅
        ∇
        
          v
          
            ⊥
          
        
      
    
    {\displaystyle {\underset {u,v}{\text{min}}}\int _{S}{\frac {1}{2}}||\nabla u||^{2}+{\frac {1}{2}}||\nabla v||^{2}-\nabla u\cdot \nabla v^{\perp }}
  
To avoid the problem of having all the vertices mapped to a single point, we also require that the solution to the optimization problem must have a non-zero norm and that it is orthogonal to the trivial solution.

Deformation
Deformation is concerned with transforming some rest shape to a new shape. Typically, these transformations are continuous and do not alter the topology of the shape. Modern mesh-based shape deformation methods satisfy user deformation constraints at handles (selected vertices or regions on the mesh) and propagate these handle deformations to the rest of shape smoothly and without removing or distorting details. Some common forms of interactive deformations are point-based, skeleton-based, and cage-based. In point-based deformation, a user can apply transformations to small set of points, called handles, on the shape. Skeleton-based deformation defines a skeleton for the shape, which allows a user to move the bones and rotate the joints. Cage-based deformation requires a cage to be drawn around all or part of a shape so that, when the user manipulates points on the cage, the volume it encloses changes accordingly.

Point-based deformation
Handles provide a sparse set of constraints for the deformation: as the user moves one point, the others must stay in place.
A rest surface 
  
    
      
        
          
            
              S
              ^
            
          
        
      
    
    {\displaystyle {\hat {S}}}
   immersed in 
  
    
      
        
          
            R
          
          
            3
          
        
      
    
    {\displaystyle \mathbb {R} ^{3}}
   can be described with a mapping 
  
    
      
        
          
            
              x
              ^
            
          
        
        :
        Ω
        →
        
          
            R
          
          
            3
          
        
      
    
    {\displaystyle {\hat {x}}:\Omega \rightarrow \mathbb {R} ^{3}}
  , where 
  
    
      
        Ω
      
    
    {\displaystyle \Omega }
   is a 2D parametric domain. The same can be done with another mapping 
  
    
      
        x
      
    
    {\displaystyle x}
   for the transformed surface 
  
    
      
        S
      
    
    {\displaystyle S}
  . Ideally, the transformed shape adds as little distortion as possible to the original. One way to model this distortion is in terms of displacements 
  
    
      
        d
        =
        x
        −
        
          
            
              x
              ^
            
          
        
      
    
    {\displaystyle d=x-{\hat {x}}}
   with a Laplacian-based energy. Applying the Laplace operator to these mappings allows us to measure how the position of a point changes relative to its neighborhood, which keeps the handles smooth. Thus, the energy we would like to minimize can be written as:

  
    
      
        
          min
          
            
              d
            
          
        
        
          ∫
          
            Ω
          
        
        
          |
        
        
          |
        
        Δ
        
          
            d
          
        
        
          |
        
        
          
            |
          
          
            2
          
        
        d
        A
      
    
    {\displaystyle \min _{\textbf {d}}\int _{\Omega }||\Delta {\textbf {d}}||^{2}dA}
  .
While this method is translation invariant, it is unable to account for rotations. The As-Rigid-As-Possible deformation scheme applies a rigid transformation 
  
    
      
        
          x
          
            i
          
        
        =
        R
        
          
            
              
                x
                
                  i
                
              
              ^
            
          
        
        +
        t
      
    
    {\displaystyle x_{i}=R{\hat {x_{i}}}+t}
   to each handle i, where 
  
    
      
        R
        ∈
        S
        O
        (
        3
        )
        ⊂
        
          
            R
          
          
            3
          
        
      
    
    {\displaystyle R\in SO(3)\subset \mathbb {R} ^{3}}
   is a rotation matrix and 
  
    
      
        t
        ∈
        
          
            R
          
          
            3
          
        
      
    
    {\displaystyle t\in \mathbb {R} ^{3}}
   is a translation vector. Unfortunately, there's no way to know the rotations in advance, so instead we pick a “best” rotation that minimizes displacements. To achieve local rotation invariance, however, requires a function 
  
    
      
        
          
            R
          
        
        :
        Ω
        →
        S
        O
        (
        3
        )
      
    
    {\displaystyle {\textbf {R}}:\Omega \rightarrow SO(3)}
   which outputs the best rotation for every point on the surface. The resulting energy, then, must optimize over both 
  
    
      
        
          
            x
          
        
      
    
    {\displaystyle {\textbf {x}}}
   and 
  
    
      
        
          
            R
          
        
      
    
    {\displaystyle {\textbf {R}}}
  :

  
    
      
        
          min
          
            
              
                x,R
              
            
            ∈
            S
            O
            (
            3
            )
          
        
        
          ∫
          
            Ω
          
        
        
          |
        
        
          |
        
        ∇
        
          
            x
          
        
        −
        
          
            R
          
        
        ∇
        
          
            
              
                x
              
              ^
            
          
        
        
          |
        
        
          
            |
          
          
            2
          
        
        d
        A
      
    
    {\displaystyle \min _{{\textbf {x,R}}\in SO(3)}\int _{\Omega }||\nabla {\textbf {x}}-{\textbf {R}}\nabla {\hat {\textbf {x}}}||^{2}dA}
  
Note that the translation vector is not present in the final objective function because translations have constant gradient.

Inside-Outside Segmentation
While seemingly trivial, in many cases, determining the inside from the outside of a triangle mesh is not an easy problem. In general, given a surface 
  
    
      
        S
      
    
    {\displaystyle S}
   we pose this problem as determining a function 
  
    
      
        i
        s
        I
        n
        s
        i
        d
        e
        (
        q
        )
      
    
    {\displaystyle isInside(q)}
   which will return 
  
    
      
        1
      
    
    {\displaystyle 1}
   if the point 
  
    
      
        q
      
    
    {\displaystyle q}
   is inside 
  
    
      
        S
      
    
    {\displaystyle S}
  , and 
  
    
      
        0
      
    
    {\displaystyle 0}
   otherwise.
In the simplest case, the shape is closed. In this case, to determine if a point 
  
    
      
        q
      
    
    {\displaystyle q}
   is inside or outside the surface, we can cast a ray 
  
    
      
        r
      
    
    {\displaystyle r}
   in any direction from a query point, and count the number of times 
  
    
      
        c
        o
        u
        n
        
          t
          
            r
          
        
      
    
    {\displaystyle count_{r}}
   it passes through the surface. If 
  
    
      
        q
      
    
    {\displaystyle q}
   was outside 
  
    
      
        S
      
    
    {\displaystyle S}
   then the ray must either not pass through 
  
    
      
        S
      
    
    {\displaystyle S}
   (in which case 
  
    
      
        c
        o
        u
        n
        
          t
          
            r
          
        
        =
        0
      
    
    {\displaystyle count_{r}=0}
  ) or, each time it enters 
  
    
      
        S
      
    
    {\displaystyle S}
   it must pass through twice, because S is bounded, so any ray entering it must exit. So if 
  
    
      
        q
      
    
    {\displaystyle q}
   is outside, 
  
    
      
        c
        o
        u
        n
        
          t
          
            r
          
        
      
    
    {\displaystyle count_{r}}
   is even. Likewise if 
  
    
      
        q
      
    
    {\displaystyle q}
   is inside, the same logic applies to the previous case, but the ray must intersect 
  
    
      
        S
      
    
    {\displaystyle S}
   one extra time for the first time it leaves 
  
    
      
        S
      
    
    {\displaystyle S}
  . So:

  
    
      
        i
        s
        I
        n
        s
        i
        d
        
          e
          
            r
          
        
        (
        q
        )
        =
        
          {
          
            
              
                
                  1
                
                
                  c
                  o
                  u
                  n
                  
                    t
                    
                      r
                    
                  
                   
                  i
                  s
                   
                  o
                  d
                  d
                
              
              
                
                  0
                
                
                  c
                  o
                  u
                  n
                  
                    t
                    
                      r
                    
                  
                   
                  i
                  s
                   
                  e
                  v
                  e
                  n
                
              
            
          
          
        
      
    
    {\displaystyle isInside_{r}(q)=\left\{{\begin{array}{ll}1&count_{r}\ is\ odd\\0&count_{r}\ is\ even\\\end{array}}\right.}
  
Now, oftentimes we cannot guarantee that the 
  
    
      
        S
      
    
    {\displaystyle S}
   is closed. Take the pair of pants example from the top of this article. This mesh clearly has a semantic inside-and-outside, despite there being holes at the waist and the legs.

The naive attempt to solve this problem is to shoot many rays in random directions, and classify 
  
    
      
        q
      
    
    {\displaystyle q}
   as being inside if and only if most of the rays intersected 
  
    
      
        S
      
    
    {\displaystyle S}
   an odd number of times. To quantify this, let us say we cast 
  
    
      
        k
      
    
    {\displaystyle k}
   rays, 
  
    
      
        
          r
          
            1
          
        
        ,
        
          r
          
            2
          
        
        ,
        …
        ,
        
          r
          
            k
          
        
      
    
    {\displaystyle r_{1},r_{2},\dots ,r_{k}}
  . We associate a number 
  
    
      
        r
        a
        y
        T
        e
        s
        t
        (
        q
        )
        =
        
          
            1
            k
          
        
        
          ∑
          
            i
            =
            1
          
          
            k
          
        
        i
        s
        I
        n
        s
        i
        d
        
          e
          
            
              r
              
                i
              
            
          
        
        (
        q
        )
      
    
    {\displaystyle rayTest(q)={\frac {1}{k}}\sum _{i=1}^{k}isInside_{r_{i}}(q)}
   which is the average value of 
  
    
      
        i
        s
        I
        n
        s
        i
        d
        
          e
          
            r
          
        
      
    
    {\displaystyle isInside_{r}}
   from each ray. Therefore:

  
    
      
        i
        s
        I
        n
        s
        i
        d
        e
        (
        q
        )
        =
        
          {
          
            
              
                
                  1
                
                
                  r
                  a
                  y
                  T
                  e
                  s
                  t
                  (
                  q
                  )
                  ≥
                  0.5
                
              
              
                
                  0
                
                
                  r
                  a
                  y
                  T
                  e
                  s
                  t
                  (
                  q
                  )
                  <
                  0.5
                
              
            
          
          
        
      
    
    {\displaystyle isInside(q)=\left\{{\begin{array}{ll}1&rayTest(q)\geq 0.5\\0&rayTest(q)<0.5\\\end{array}}\right.}
  
In the limit of shooting many, many rays, this method handles open meshes, however it in order to become accurate, far too many rays are required for this method to be computationally ideal. Instead, a more robust approach is the Generalized Winding Number. Inspired by the 2D winding number, this approach uses the solid angle at 
  
    
      
        q
      
    
    {\displaystyle q}
   of each triangle in the mesh to determine if 
  
    
      
        q
      
    
    {\displaystyle q}
   is inside or outside. The value of the Generalized Winding Number at 
  
    
      
        q
      
    
    {\displaystyle q}
  , 
  
    
      
        w
        n
        (
        q
        )
      
    
    {\displaystyle wn(q)}
   is proportional to the sum of the solid angle contribution from each triangle in the mesh:

  
    
      
        w
        n
        (
        q
        )
        =
        
          
            1
            
              4
              π
            
          
        
        
          ∑
          
            t
            ∈
            F
          
        
        s
        o
        l
        i
        d
        A
        n
        g
        l
        e
        (
        t
        )
      
    
    {\displaystyle wn(q)={\frac {1}{4\pi }}\sum _{t\in F}solidAngle(t)}
  
For a closed mesh, 
  
    
      
        w
        n
        (
        q
        )
      
    
    {\displaystyle wn(q)}
   is equivalent to the characteristic function for the volume represented by 
  
    
      
        S
      
    
    {\displaystyle S}
  . Therefore, we say:

  
    
      
        i
        s
        I
        n
        s
        i
        d
        e
        (
        q
        )
        =
        
          {
          
            
              
                
                  1
                
                
                  w
                  n
                  (
                  q
                  )
                  ≥
                  0.5
                
              
              
                
                  0
                
                
                  w
                  n
                  (
                  q
                  )
                  <
                  0.5
                
              
            
          
          
        
      
    
    {\displaystyle isInside(q)=\left\{{\begin{array}{ll}1&wn(q)\geq 0.5\\0&wn(q)<0.5\\\end{array}}\right.}
  
Because 
  
    
      
        w
        n
        (
        q
        )
      
    
    {\displaystyle wn(q)}
   is a harmonic function, it degrades gracefully, meaning the inside-outside segmentation would not change much if we poked holes in a closed mesh. For this reason, the Generalized Winding Number handles open meshes robustly. The boundary between inside and outside smoothly passes over holes in the mesh. In fact, in the limit, the Generalized Winding Number is equivalent to the ray-casting method as the number of rays goes to infinity.

Applications
Computer-aided design (CAD)
3D Surface Reconstruction, e.g. range scanners in airport security, autonomous vehicles, medical scanner data reconstruction
Image-to-world Registration, e.g. Image-guided surgery
Architecture, e.g. creating, reverse engineering
Physics simulations
Computer games e.g. collision detection
Geologic modelling
Visualization (graphics) e.g. Information visualizations, mathematical visualizations
Texture mapping
Modelling biological systems e.g. muscle and bone modelling, real-time hand tracking

See also
Calculus of variations
Computer graphics
3D computer graphics
Graphics processing unit (GPU)
Computer-aided design (CAD)
Digital image
Digital image processing
Discrete differential geometry
Glossary of differential geometry and topology
Industrial CT scanning
List of interactive geometry software
MeshLab
Signal processing
Digital signal processing
Digital signal processor (DSP)
Topology

References
External links

Symposium on Geometry Processing
Multi-Res Modeling Group, Caltech
Mathematical Geometry Processing Group, Free University of Berlin
Computer Graphics Group, RWTH Aachen University
Polygon Mesh Processing Book
Polygon Mesh Processing Library
Discrete Differential Geometry: An Applied Introduction, course notes by Keenan Crane et al.
Video tutorials from SGP 2017 grad school
libigl geometry processing library
CGAL The Computational Geometry Algorithms Library (see section on Polygon Mesh Processing)