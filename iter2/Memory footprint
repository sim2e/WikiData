Memory footprint refers to the amount of main memory that a program uses or references while running.The word footprint generally refers to the extent of physical dimensions that an object occupies, giving a sense of its size. In computing, the memory footprint of a software application indicates its runtime memory requirements, while the program executes. This includes all sorts of active memory regions like code segment containing (mostly) program instructions (and occasionally constants), data segment (both initialized and uninitialized), heap memory, call stack, plus memory required to hold any additional data structures, such as symbol tables, debugging data structures, open files, shared libraries mapped to the current process, etc., that the program ever needs while executing and will be loaded at least once during the entire run.Larger programs have larger memory footprints. An application's memory footprint is roughly proportionate to the number and sizes of shared libraries or classes it loads, whereas static libraries, executable programs and static data areas contribute to a fixed (constant) portion. Programs themselves often do not contribute the largest portions to their own memory footprints; rather, structures introduced by the run-time environment take up most of the memory. For example, a C++ compiler inserts vtables, type info objects and many temporary and anonymous objects that are active during a program's execution.  In a Java program, the memory footprint is predominantly made up of the runtime environment in the form of Java virtual machine (JVM) itself that is loaded indirectly when a Java application launches. In addition, on most operating systems, disk files opened by an application too are read into the application's address space, thereby, contributing to its footprint.

Usage trend
During the 1990s, computer memory became cheaper and programs with larger memory footprints became commonplace. This trend has been mostly due to the widespread use of computer software, from large enterprise-wide applications that consume vast amounts of memory (such as databases), to memory intensive multimedia authoring and editing software. To tackle the ever increasing memory needs, virtual memory systems were introduced that divide the available memory into equally sized portions and loads them from "pages" stored on the hard-disk on an as-and-when required basis.
This approach to support programs with huge-memory-footprints has been quite successful. Most modern operating systems including Microsoft Windows, Apple's macOS, and all versions of Linux and Unix provide virtual memory systems.

In embedded systems
Traditionally, low-memory-footprint programs were of importance to running applications on embedded platforms where memory would often be a constrained resource â€“ so much so that developers typically sacrificed efficiency (processing speeds) just to make program footprints small enough to fit into the available RAM. For example, Sun Microsystems brought out a version of its Java Virtual Machine (JVM) for such constrained devices; it goes by the name of KVM. The KVM works on platforms where memory is in kilobytes as opposed to the megabytes (or even gigabytes) of memory available on a regular home PC or more modern smart devices.

See also
Application footprint
Virtual memory, a memory management technique that virtualizes various forms of computer data storage (such as random-access memory and disk storage).


== References ==