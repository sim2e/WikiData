A transformer is a deep learning architecture, initially proposed in 2017, that relies on the parallel multi-head attention mechanism. It is notable for requiring less training time than previous recurrent neural architectures, such as long short-term memory (LSTM), and its later variation has been prevalently adopted for training large language models on large (language) datasets, such as the Wikipedia corpus and Common Crawl, by virtue of the parallelized processing of input sequence.
Input text is split into n-grams encoded as tokens and each token is converted into a vector via looking up from a word embedding table. At each layer, each token is then contextualized within the scope of the context window with other (unmasked) tokens via a parallel multi-head attention mechanism allowing the signal for key tokens to be amplified and less important tokens to be diminished. Though the transformer paper was published in 2017, the softmax-based attention mechanism was proposed in 2014 for machine translation, and the Fast Weight Controller, similar to a transformer, was proposed in 1992.
This architecture is now used not only in natural language processing and computer vision, but also in audio and multi-modal processing. It has also led to the development of pre-trained systems, such as generative pre-trained transformers (GPTs) and BERT (Bidirectional Encoder Representations from Transformers).

Timeline
In 1990, the Elman network, using a recurrent neural network, encoded each word in a training set as a vector, called a word embedding, and the whole vocabulary as a vector database, allowing it to perform such tasks as sequence-prediction that are beyond the power of a simple multilayer perceptron. A shortcoming of the static embeddings was that they didn't differentiate between multiple meanings of same-spelt words.
In 1992, the Fast Weight Controller was published by JÃ¼rgen Schmidhuber. It learns to answer queries by programming the attention weights of another neural network through outer products of key vectors and value vectors called FROM and TO. The Fast Weight Controller was later shown to be closely related to the Linear Transformer.  The terminology "learning internal spotlights of attention" was introduced in 1993. An advantage of the fast linear transformers is that their computational complexity grows linearly with sequence length, while modern transformers scale quadratically.In 1993, the IBM alignment models were used for statistical machine translation.In 1997, a precursor of large language model, using recurrent neural networks, such as long short-term memory, was proposed.In 2001, one-billion-word large text corpus, scraped from the Internet, referred to as "very very large" at the time, was used for word disambiguation.In 2012, AlexNet demonstrated the effectiveness of large neural networks for image recognition, encouraging large artificial neural networks approach instead of older, statistical approaches.In 2014, a 380M-parameter seq2seq model for machine translation using two LSTMs networks was proposed by Sutskever at al. The architecture consists of two parts. The encoder is an LSTM that takes in a sequence of tokens and turns it into a vector. The decoder is another LSTM that converts the vector into a sequence of tokens.In 2014, gating proved to be useful in a 130M-parameter seq2seq model, which used a simplified gated recurrent units (GRUs). Bahdanau et al showed that GRUs are neither better nor worse than gated LSTMs.In 2014,  Bahdanau et al. improved the previous seq2seq model by using an "additive" kind of attention mechanism in-between two LSTM networks. It was, however, not yet the parallelizable (scaled "dot product") kind of attention, later proposed in the 2017 transformer paper.
In 2015, the relative performance of Global and Local (widowed) attention model architectures were assessed by Luong et al, a mixed attention architecture found to improve on the translations offered by Bahdanau's architecture, while the use of a local attention architecture  reduced translation time. In 2016, Google Translate gradually replaced the older statistical machine translation approach with the newer neural-networks-based approach that included a seq2seq model combined by LSTM and the "additive" kind of attention mechanism. They achieved a higher level of performance than the statistical approach, which took ten years to develop, in only nine months.In 2017, the original (100M-sized) encoder-decoder transformer model with a faster (parallelizable or decomposable) attention mechanism was proposed in the "Attention is all you need" paper. As the model had difficulties converging, it was suggested that the learning rate should be linearly scaled up from 0 to maximal value for the first part of the training (i.e. 2% of the total number of training steps). The intent of the transformer model is to take a seq2seq model and remove its recurrent neural networks, but preserve its additive attention mechanism.In 2018, in the ELMo paper, an entire sentence was processed before an embedding vector was assigning to each word in the sentence. A bi-directional LSTM was used to calculate such, deep contextualized embeddings for each word, improving upon the line of research from bag of words and word2vec.In 2018, an encoder-only transformer was used in the (more than 1B-sized) BERT model, improving upon ELMo.In 2020, vision transformer and speech-processing convolution-augmented transformer outperformed recurrent neural networks, previously used for vision and speech.In 2020, difficulties with converging the original transformer were solved by normalizing layers before (instead of after) multiheaded attention by Xiong et al. This is called pre-LN Transformer.In 2023, uni-directional ("autoregressive") transformers were being used in the (more than 100B-sized) GPT-3 and other OpenAI GPT models.

Predecessors
Before transformers, predecessors of attention mechanism were added to gated recurrent neural networks, such as LSTMs and gated recurrent units (GRUs), which processed datasets sequentially. Dependency on previous token computations prevented them from being able to parallelize the attention mechanism. In 1992, fast weight controller was proposed as an alternative to recurrent neural networks that can learn "internal spotlights of attention". In theory, the information from one token can propagate arbitrarily far down the sequence, but in practice the vanishing-gradient problem leaves the model's state at the end of a long sentence without precise, extractable information about preceding tokens.
The performance of old models was enhanced by adding an attention mechanism, which allowed a model to access any preceding point along the sequence. The attention layer weighs all previous states according to a learned measure of relevance, providing relevant information about far-away tokens. This proved to be especially useful in language translation, where far-away context can be essential for the meaning of a word in a sentence. The state vector has been accessible only after the last English word was processed while, for example, translating it from French by a LSTM model. Although in theory such a vector retains the information about the whole original sentence, in practice the information is poorly preserved. If an attention mechanism is added, the decoder is given access to the state vectors of every input word, not just the last, and can learn attention weights that dictate how much to attend to each input state vector. The augmentation of seq2seq models with the attention mechanism was first implemented in the context of machine translation by Bahdanau, Cho, and Bengio in 2014.

Decomposable attention
In 2016, highly parallelizable decomposable attention was successfully combined with a feedforward network. This indicated that attention mechanisms were powerful in themselves and that sequential recurrent processing of data was not necessary to achieve the quality gains of recurrent neural networks with attention. In 2017, Vaswani et al. also proposed replacing recurrent neural networks with self-attention and started the effort to evaluate that idea. Transformers, using an attention mechanism, processing all tokens simultaneously, calculated "soft" weights between them in successive layers. Since the attention mechanism only uses information about other tokens from lower layers, it can be computed for all tokens in parallel, which leads to improved training speed.

Training
Methods for stabilizing training
The plain transformer architecture had difficulty converging. In the original paper the authors recommended using learning rate warmup. That is, the learning rate should linearly scale up from 0 to maximal value for the first part of the training (usually recommended to be 2% of the total number of training steps), before decaying again.
A 2020 paper found that using layer normalization before (instead of after) multiheaded attention and feedforward layers stabilizes training, not requiring learning rate warmup.The GT3 model integrates CWTE, SWTE, and TTE using a self-adaptive gate layer, enabling efficient and effective fusion of three types of features for end-to-end text-driven stock market prediction.

Pretrain-finetune
Transformers typically undergo self-supervised learning involving unsupervised pretraining followed by supervised fine-tuning. Pretraining is typically done on a larger dataset than fine-tuning, due to the limited availability of labeled training data. Tasks for pretraining and fine-tuning commonly include:

language modeling
next-sentence prediction
question answering
reading comprehension
sentiment analysis
paraphrasingThe T5 transformer paper documents a large number of pretraining tasks. Some examples are:

restoring corrupted text: Thank you <X> me to your party <Y> week. -> <X> for inviting <Y> last <Z> where the <Z> means "end of output".
translation: translate English to German: That is good." -> "Das ist gut.".
judging the grammatical acceptability of a sentence: cola sentence: "The course is jumping well." -> not acceptable .

Applications
The transformer has had great success in natural language processing (NLP), for example the tasks of machine translation and time series prediction. Many large language models such as GPT-2, GPT-3, GPT-4, Claude, BERT, XLNet, RoBERTa and ChatGPT demonstrate the ability of transformers to perform a wide variety of such NLP-related tasks, and have the potential to find real-world applications. These may include:

machine translation
document summarization
document generation
named entity recognition (NER)
biological sequence analysis
writing computer code based on requirements expressed in natural language.
video understanding.In addition to the NLP applications, it has also been successful in other fields, such as computer vision, or the protein folding applications (such as AlphaFold).
As an illustrative example, Ithaca is an encoder-only transformer with three output heads. It takes as input ancient Greek inscription as sequences of characters, but with illegible characters replaced with "-". Its three output heads respectively outputs probability distributions over Greek characters, location of inscription, and date of inscription.

Implementations
The transformer model has been implemented in standard deep learning frameworks such as TensorFlow and PyTorch.
Transformers is a library produced by Hugging Face that supplies transformer-based architectures and pretrained models.

Architecture
All transformers have the same primary components:

Tokenizers, which convert text into tokens.
A single embedding layer, which convert tokens and positions of the tokens into vector representations.
Transformer layers, which carry out repeated transformations on the vector representations, extracting more and more linguistic information. These consist of alternating attention and feedforward layers.
(optional) Un-embedding layer, which converts the final vector representations back to a probability distribution over the tokens.Transformer layers can be one of two types, encoder and decoder. In the original paper both of them were used, while later models included only one type of them. BERT is an example of encoder-only model; GPT are decoder-only models.

Input
The input text is parsed into tokens by a tokenizer, most often a byte pair encoding tokenizer, and each token is converted into a vector via looking up from a word embedding table. Then, positional information of the token is added to the word embedding.

Encoder-decoder architecture
Like earlier seq2seq models, the original transformer model used an encoder-decoder architecture. The encoder consists of encoding layers that process the input tokens iteratively one layer after another, while the decoder consists of decoding layers that iteratively process the encoder's output as well as the decoder output's tokens so far.
The function of each encoder layer is to generate contextualized token representations, where each representation corresponds to a token that "mixes" information from other input tokens via self-attention mechanism. Each decoder layer contains two attention sublayers: (1) cross-attention for incorporating the output of encoder (contextualized input token representations), and (2) self-attention for "mixing" information among the input tokens to the decoder (i.e., the tokens generated so far during inference time). Both the encoder and decoder layers have a feed-forward neural network for additional processing of the outputs and contain residual connections and layer normalization steps.

Scaled dot-product attention
The transformer building blocks are scaled dot-product attention units. For each attention unit, the transformer model learns three weight matrices: the query weights 
  
    
      
        
          W
          
            Q
          
        
      
    
    {\displaystyle W_{Q}}
  , the key weights 
  
    
      
        
          W
          
            K
          
        
      
    
    {\displaystyle W_{K}}
  , and the value weights 
  
    
      
        
          W
          
            V
          
        
      
    
    {\displaystyle W_{V}}
  . For each token 
  
    
      
        i
      
    
    {\displaystyle i}
  , the input token representation 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
   is multiplied with each of the three weight matrices to produce a query vector 
  
    
      
        
          q
          
            i
          
        
        =
        
          x
          
            i
          
        
        
          W
          
            Q
          
        
      
    
    {\displaystyle q_{i}=x_{i}W_{Q}}
  , a key vector 
  
    
      
        
          k
          
            i
          
        
        =
        
          x
          
            i
          
        
        
          W
          
            K
          
        
      
    
    {\displaystyle k_{i}=x_{i}W_{K}}
  , and a value vector 
  
    
      
        
          v
          
            i
          
        
        =
        
          x
          
            i
          
        
        
          W
          
            V
          
        
      
    
    {\displaystyle v_{i}=x_{i}W_{V}}
  . Attention weights are calculated using the query and key vectors: the attention weight 
  
    
      
        
          a
          
            i
            j
          
        
      
    
    {\displaystyle a_{ij}}
   from token 
  
    
      
        i
      
    
    {\displaystyle i}
   to token 
  
    
      
        j
      
    
    {\displaystyle j}
   is the dot product between 
  
    
      
        
          q
          
            i
          
        
      
    
    {\displaystyle q_{i}}
   and 
  
    
      
        
          k
          
            j
          
        
      
    
    {\displaystyle k_{j}}
  . The attention weights are divided by the square root of the dimension of the key vectors, 
  
    
      
        
          
            
              d
              
                k
              
            
          
        
      
    
    {\displaystyle {\sqrt {d_{k}}}}
  , which stabilizes gradients during training, and passed through a softmax which normalizes the weights. The fact that 
  
    
      
        
          W
          
            Q
          
        
      
    
    {\displaystyle W_{Q}}
   and 
  
    
      
        
          W
          
            K
          
        
      
    
    {\displaystyle W_{K}}
   are different matrices allows attention to be non-symmetric: if token 
  
    
      
        i
      
    
    {\displaystyle i}
   attends to token 
  
    
      
        j
      
    
    {\displaystyle j}
   (i.e. 
  
    
      
        
          q
          
            i
          
        
        â
        
          k
          
            j
          
        
      
    
    {\displaystyle q_{i}\cdot k_{j}}
   is large), this does not necessarily mean that token 
  
    
      
        j
      
    
    {\displaystyle j}
   will attend to token 
  
    
      
        i
      
    
    {\displaystyle i}
   (i.e. 
  
    
      
        
          q
          
            j
          
        
        â
        
          k
          
            i
          
        
      
    
    {\displaystyle q_{j}\cdot k_{i}}
   could be small). The output of the attention unit for token 
  
    
      
        i
      
    
    {\displaystyle i}
   is the weighted sum of the value vectors of all tokens, weighted by 
  
    
      
        
          a
          
            i
            j
          
        
      
    
    {\displaystyle a_{ij}}
  , the attention from token 
  
    
      
        i
      
    
    {\displaystyle i}
   to each token.
The attention calculation for all tokens can be expressed as one large matrix calculation using the softmax function, which is useful for training due to computational matrix operation optimizations that quickly compute matrix operations. The matrices 
  
    
      
        Q
      
    
    {\displaystyle Q}
  , 
  
    
      
        K
      
    
    {\displaystyle K}
   and 
  
    
      
        V
      
    
    {\displaystyle V}
   are defined as the matrices where the 
  
    
      
        i
      
    
    {\displaystyle i}
  th rows are vectors 
  
    
      
        
          q
          
            i
          
        
      
    
    {\displaystyle q_{i}}
  , 
  
    
      
        
          k
          
            i
          
        
      
    
    {\displaystyle k_{i}}
  , and 
  
    
      
        
          v
          
            i
          
        
      
    
    {\displaystyle v_{i}}
   respectively. Then we can represent the attention as

where softmax is taken over the horizontal axis.

Multi-head attention
One set of 
  
    
      
        
          (
          
            
              W
              
                Q
              
            
            ,
            
              W
              
                K
              
            
            ,
            
              W
              
                V
              
            
          
          )
        
      
    
    {\displaystyle \left(W_{Q},W_{K},W_{V}\right)}
   matrices is called an attention head, and each layer in a transformer model has multiple attention heads. While each attention head attends to the tokens that are relevant to each token, multiple attention heads allow the model to do this for different definitions of "relevance". In addition, the influence field representing relevance can become progressively dilated in successive layers. Many transformer attention heads encode relevance relations that are meaningful to humans. For example, some attention heads can attend mostly to the next word, while others mainly attend from verbs to their direct objects. The computations for each attention head can be performed in parallel, which allows for fast processing. The outputs for the attention layer are concatenated to pass into the feed-forward neural network layers.
Concretely, let the multiple attention heads be indexed by 
  
    
      
        i
      
    
    {\displaystyle i}
  , then we have where the matrix 
  
    
      
        X
      
    
    {\displaystyle X}
   is the concatenation of word embeddings, and the matrices 
  
    
      
        
          W
          
            i
          
          
            Q
          
        
        ,
        
          W
          
            i
          
          
            K
          
        
        ,
        
          W
          
            i
          
          
            V
          
        
      
    
    {\displaystyle W_{i}^{Q},W_{i}^{K},W_{i}^{V}}
   are "projection matrices" owned by individual attention head 
  
    
      
        i
      
    
    {\displaystyle i}
  , and 
  
    
      
        
          W
          
            O
          
        
      
    
    {\displaystyle W^{O}}
   is a final projection matrix owned by the whole multi-headed attention head.

Masked attention
It may be necessary to cut out attention links between some word-pairs. For example, the decoder for token position 
  
    
      
        t
      
    
    {\displaystyle t}
   should not have access to token position 
  
    
      
        t
        +
        1
      
    
    {\displaystyle t+1}
  . This may be accomplished before the softmax stage by adding a mask matrix 
  
    
      
        M
      
    
    {\displaystyle M}
   that is 
  
    
      
        â
        â
      
    
    {\displaystyle -\infty }
   at entries where the attention link must be cut, and 
  
    
      
        0
      
    
    {\displaystyle 0}
   at other places:

Encoder
Each encoder consists of two major components: a self-attention mechanism and a feed-forward neural network. The self-attention mechanism accepts input encodings from the previous encoder and weights their relevance to each other to generate output encodings. The feed-forward neural network further processes each output encoding individually. These output encodings are then passed to the next encoder as its input, as well as to the decoders.
The first encoder takes positional information and embeddings of the input sequence as its input, rather than encodings. The positional information is necessary for the transformer to make use of the order of the sequence, because no other part of the transformer makes use of this.The encoder is bidirectional. Attention can be placed on tokens before and after the current token. Tokens are used instead of words to account for polysemy.

Positional encoding
A positional encoding is a fixed-size vector representation that encapsulates the relative positions of tokens within a target sequence: it provides the transformer model with information about where the words are in the input sequence.
The positional encoding is defined as a function of type 
  
    
      
        f
        :
        
          R
        
        â
        
          
            R
          
          
            d
          
        
        ;
        d
        â
        
          Z
        
        ,
        d
        >
        0
      
    
    {\displaystyle f:\mathbb {R} \to \mathbb {R} ^{d};d\in \mathbb {Z} ,d>0}
  , where 
  
    
      
        d
      
    
    {\displaystyle d}
   is a positive even integer. The full positional encoding â as defined in the original paper â is given by the equation:where 
  
    
      
        Î¸
        =
        
          
            t
            
              r
              
                k
              
            
          
        
        ,
        r
        =
        
          N
          
            2
            
              /
            
            d
          
        
      
    
    {\displaystyle \theta ={\frac {t}{r^{k}}},r=N^{2/d}}
  .
Here, 
  
    
      
        N
      
    
    {\displaystyle N}
   is a free parameter that should be significantly larger than the biggest 
  
    
      
        k
      
    
    {\displaystyle k}
   that would be input into the positional encoding function. In the original paper, the authors chose 
  
    
      
        N
        =
        10000
      
    
    {\displaystyle N=10000}
  .
The function is in a simpler form when written as a complex function of type 
  
    
      
        f
        :
        
          R
        
        â
        
          
            C
          
          
            d
            
              /
            
            2
          
        
      
    
    {\displaystyle f:\mathbb {R} \to \mathbb {C} ^{d/2}}
  where 
  
    
      
        r
        =
        
          N
          
            2
            
              /
            
            d
          
        
      
    
    {\displaystyle r=N^{2/d}}
  .
The main reason the authors chose this as the positional encoding function is that it allows one to perform shifts as linear transformations:where 
  
    
      
        Î
        t
        â
        
          R
        
      
    
    {\displaystyle \Delta t\in \mathbb {R} }
   is the distance one wishes to shift. This allows the transformer to take any encoded position, and find the encoding of the position n-steps-ahead or n-steps-behind, by a matrix multiplication.
By taking a linear sum, any convolution can also be implemented as linear transformations:for any constants 
  
    
      
        
          c
          
            j
          
        
      
    
    {\displaystyle c_{j}}
  . This allows the transformer to take any encoded position and find a linear sum of the encoded locations of its neighbors. This sum of encoded positions, when fed into the attention mechanism, would create attention weights on its neighbors, much like what happens in a convolutional neural network language model. In the author's words, "we hypothesized it would allow the model to easily learn to attend by relative position".
In typical implementations, all operations are done over the real numbers, not the complex numbers, but since complex multiplication can be implemented as real 2-by-2 matrix multiplication, this is a mere notational difference.

Decoder
Each decoder consists of three major components: a self-attention mechanism, an attention mechanism over the encodings, and a feed-forward neural network. The decoder functions in a similar fashion to the encoder, but an additional attention mechanism is inserted which instead draws relevant information from the encodings generated by the encoders. This mechanism can also be called the encoder-decoder attention.Like the first encoder, the first decoder takes positional information and embeddings of the output sequence as its input, rather than encodings. The transformer must not use the current or future output to predict an output, so the output sequence must be partially masked to prevent this reverse information flow. This allows for autoregressive text generation. For all attention heads, attention can't be placed on following tokens. The last decoder is followed by a final linear transformation and softmax layer, to produce the output probabilities over the vocabulary.
All members of OpenAI's GPT series have a decoder-only architecture.

Terminology
In large language model, the terminology is somewhat different than the terminology used in the original Transformer paper:
"encoder only": full encoder, full decoder."encoder-decoder": full encoder, autoregressive decoder.
"decoder only": autoregressive encoder, autoregressive decoder.Here "autoregressive" means that a mask is inserted in the attention head to zero out all attention from one token to all tokens following it, as described in the "masked attention" section.
Generally, Transformer-based language models are of two types: causal (or "autoregressive") and masked. The GPT series is causal and decoder only. BERT is masked and encoder only. The T5 series is encoder-decoder, with a full encoder and autoregressive decoder.

Subsequent work
Alternative functions
The original transformer uses ReLU activation function. Other activation functions were developed, such as SwiGLU.

Alternative positional encodings
Transformers may use other positional encoding methods than sinusoidal.RoPE (rotary positional embedding), is best explained by considering a list of 2-dimensional vectors 
  
    
      
        [
        (
        
          x
          
            1
          
          
            (
            1
            )
          
        
        ,
        
          x
          
            1
          
          
            (
            2
            )
          
        
        )
        ,
        (
        
          x
          
            2
          
          
            (
            1
            )
          
        
        ,
        
          x
          
            2
          
          
            (
            2
            )
          
        
        )
        ,
        (
        
          x
          
            3
          
          
            (
            1
            )
          
        
        ,
        
          x
          
            3
          
          
            (
            2
            )
          
        
        )
        ,
        .
        .
        .
        ]
      
    
    {\displaystyle [(x_{1}^{(1)},x_{1}^{(2)}),(x_{2}^{(1)},x_{2}^{(2)}),(x_{3}^{(1)},x_{3}^{(2)}),...]}
  . Now pick some angle 
  
    
      
        Î¸
      
    
    {\displaystyle \theta }
  . Then RoPE encoding isEquivalently, if we write the 2-dimensional vectors as complex numbers 
  
    
      
        
          z
          
            m
          
        
        :=
        
          x
          
            m
          
          
            (
            1
            )
          
        
        +
        i
        
          x
          
            m
          
          
            (
            2
            )
          
        
      
    
    {\displaystyle z_{m}:=x_{m}^{(1)}+ix_{m}^{(2)}}
  , then RoPE encoding is just multiplication by an angle:For a list of 
  
    
      
        2
        n
      
    
    {\displaystyle 2n}
  -dimensional vectors, a RoPE encoder is defined by a sequence of angles 
  
    
      
        
          Î¸
          
            (
            1
            )
          
        
        ,
        .
        .
        .
        ,
        
          Î¸
          
            (
            n
            )
          
        
      
    
    {\displaystyle \theta ^{(1)},...,\theta ^{(n)}}
  . Then the RoPE encoding is applied to each pair of coordinates.
The benefit of RoPE is that the dot-product between two vectors depends on their relative location only:

for any integer 
  
    
      
        k
      
    
    {\displaystyle k}
  .
ALiBi (Attention with Linear Biases) is not a replacement for the positional encoder on the original transformer. Instead, it is an additional positional encoder that is directly plugged into the attention mechanism. Specifically, the ALiBi attention mechanism isHere, 
  
    
      
        s
      
    
    {\displaystyle s}
   is a real number ("scalar"), and 
  
    
      
        B
      
    
    {\displaystyle B}
   is the linear bias matrix defined byin other words, 
  
    
      
        
          B
          
            i
            ,
            j
          
        
        =
        j
        â
        i
      
    
    {\displaystyle B_{i,j}=j-i}
  .
ALiBi allows pretraining on short context windows, then finetuning on longer context windows. Since it is directly plugged into the attention mechanism, it can be combined with any positional encoder that is plugged into the "bottom" of the entire network (which is where the sinusoidal encoder on the original transformer, as well as RoPE and many others, are located).
Relative Position Encodings is similar to ALiBi, but more generic:where 
  
    
      
        B
      
    
    {\displaystyle B}
   is a Toeplitz matrix, that is, 
  
    
      
        
          B
          
            i
            ,
            j
          
        
        =
        
          B
          
            
              i
              â²
            
            ,
            
              j
              â²
            
          
        
      
    
    {\displaystyle B_{i,j}=B_{i',j'}}
   whenever 
  
    
      
        i
        â
        j
        =
        
          i
          â²
        
        â
        
          j
          â²
        
      
    
    {\displaystyle i-j=i'-j'}
  .

Efficient implementation
FlashAttention
FlashAttention is an algorithm that implements the transformer attention mechanism efficiently on a GPU. It performs matrix multiplications in blocks, such that each block fits within the cache of a GPU, and by careful management of the blocks it minimizes data copying between GPU caches (as data movement is slow).
An improved version, FlashAttention-2, was developed to cater to the rising demand for language models capable of handling longer context lengths. It offers enhancements in work partitioning and parallelism, enabling it to achieve up to 230 TFLOPs/s on A100 GPUs (FP16/BF16), a 2x speed increase over the original FlashAttention.
Key advancements in FlashAttention-2 include the reduction of non-matmul FLOPs, improved parallelism over the sequence length dimension, better work partitioning between GPU warps, and added support for head dimensions up to 256 and multi-query attention (MQA) and grouped-query attention (GQA).
Benchmarks revealed FlashAttention-2 to be up to 2x faster than FlashAttention and up to 9x faster than a standard attention implementation in PyTorch. Future developments include optimization for new hardware like H100 GPUs and new data types like FP8.

Multi-Query Attention
Multi-Query Attention changes the multiheaded attention mechanism. Whereas normally,
with Multi-Query Attention, there is just one 
  
    
      
        
          W
          
            K
          
        
        ,
        
          W
          
            V
          
        
      
    
    {\displaystyle W^{K},W^{V}}
  , thus:

This has a neutral effect on model quality and training speed, but increases inference speed.

Sub-quadratic transformers
Training transformer-based architectures can be expensive, especially for long inputs. Alternative architectures include the Reformer (which reduces the computational load from 
  
    
      
        O
        (
        
          N
          
            2
          
        
        )
      
    
    {\displaystyle O(N^{2})}
   to 
  
    
      
        O
        (
        N
        ln
        â¡
        N
        )
      
    
    {\displaystyle O(N\ln N)}
  ), or models like ETC/BigBird (which can reduce it to 
  
    
      
        O
        (
        N
        )
      
    
    {\displaystyle O(N)}
  ) where 
  
    
      
        N
      
    
    {\displaystyle N}
   is the length of the sequence. This is done using locality-sensitive hashing and reversible layers.Ordinary transformers require a memory size that is quadratic in the size of the context window. Attention-free transformers reduce this to a linear dependence while still retaining the advantages of a transformer by linking the key to the value.
Long Range Arena (2020) is a standard benchmark for comparing the behavior of transformer architectures over long inputs.
Random Feature Attention (2021) uses Fourier random features:where 
  
    
      
        
          w
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          w
          
            D
          
        
      
    
    {\displaystyle w_{1},...,w_{D}}
   are independent samples from the normal distribution 
  
    
      
        N
        (
        0
        ,
        
          Ï
          
            2
          
        
        I
        )
      
    
    {\displaystyle N(0,\sigma ^{2}I)}
  . This choice of parameters satisfy 
  
    
      
        
          E
        
        [
        â¨
        Ï
        (
        x
        )
        ,
        Ï
        (
        y
        )
        â©
        ]
        =
        
          e
          
            
              
                â
                x
                â
                y
                
                  â
                  
                    2
                  
                
              
              
                2
                
                  Ï
                  
                    2
                  
                
              
            
          
        
      
    
    {\displaystyle \mathbb {E} [\langle \varphi (x),\varphi (y)\rangle ]=e^{\frac {\|x-y\|^{2}}{2\sigma ^{2}}}}
  , or Consequently, the one-headed attention, with one query, can be written as where 
  
    
      
        Ï
        =
        
          d
          
            K
          
          
            1
            
              /
            
            4
          
        
      
    
    {\displaystyle \sigma =d_{K}^{1/4}}
  . Similarly for multiple queries, and for multiheaded attention.
This approximation can be computed in linear time, as we can compute the matrix 
  
    
      
        Ï
        (
        
          k
          
            i
          
        
        )
        
          v
          
            i
          
          
            T
          
        
      
    
    {\displaystyle \varphi (k_{i})v_{i}^{T}}
   first, then multiply it with the query. In essence, we have managed to obtain a more precise version of 
Performer (2022) uses the same Random Feature Attention, but 
  
    
      
        
          w
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          w
          
            D
          
        
      
    
    {\displaystyle w_{1},...,w_{D}}
   are first independently sampled from the normal distribution 
  
    
      
        N
        (
        0
        ,
        
          Ï
          
            2
          
        
        I
        )
      
    
    {\displaystyle N(0,\sigma ^{2}I)}
  , then they are Gram-Schmidt processed.

Multimodality
Transformers can also be used/adapted for modalities (input or output) beyond just text, usually by finding a way to "tokenize" the modality.
Vision transformers adapt the transformer to computer vision by breaking down input images as a series of patches, turning them into vectors, and treating them like tokens in a standard transformer.
Conformer and later Whisper follow the same pattern for speech recognition, first turning the speech signal into a spectrogram, which is then treated like an image, i.e. broken down into a series of patches, turned into vectors and treated like tokens in a standard transformer.
Perceivers by Andrew Jaegle et al. (2021) can learn from large amounts of heterogeneous data.
Regarding image outputs, Peebles et al introduced a diffusion transformer (DiT) which facilitates use of the transformer architecture for diffusion-based image production. Also, Google released a transformer-centric image generator called "Muse" based on parallel decoding and masked generative transformer technology. (Transformers played a less-central role with prior image-producing technologies, albeit still a significant one.)

See also
Perceiver â Machine learning algorithm for non-textual data
BERT (language model) â Language model developed by Google
GPT-3 â 2020 large language model
GPT-4 â 2023 text-generating language model
ChatGPT â AI chatbot developed by OpenAI
Wu Dao â Chinese multimodal artificial intelligence program
Vision transformer â Machine learning algorithm for vision processing
BLOOM (language model) â Open-access multilingual language model

References


== Further reading ==