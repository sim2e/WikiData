Cross-site leaks, also known as XS-Leaks, are a class of web security vulnerabilities. This class of vulnerabilities allow an attacker to gain access to sensitive information about a user's interactions with other websites. This is done by leveraging long-standing information leakage issues inherent to the design of the web platform, such as the use of CSS attributes or timing information related to the HTTP Cache to reveal a user's previous browsing habits.
The existence of cross-site leaks has been documented as far back as 2000. However, most modern defences against these class of attacks have been introduced relatively recently in the form of extensions to the HTTP protocol, which allow websites to instruct the browser to selectively disallow or annotate certain kinds of stateful cross-origin requests.

Background
For a web application, or web app, there are two primary components: a web browser and one or more web servers. The web browser typically interacts with the web servers via the HTTP protocol and socket connections to deliver a web application. Certain parts of the web application need to react to user input or other client-side logic; this is done by rendering HTML, CSS or executing Javascript as part of the process of delivering the website. During this process, the web app transitions between a lot of well-defined states.To securely isolate different web applications from each other, the interactions between the execution contexts of these apps are governed by the same-origin policy. A execution context in this case is considered to be equivalent to a web origin. A web application cannot reach into a different web app's execution context and arbitrarily interact with the execution state of the other web application. However, a web application can embed content from other web apps using frames or requests to third-party sites via cross-origin requests. Cross-site leaks allow attackers to break this cross-origin barrier inherent in web application contexts. By leveraging information leakage issues (side channels), an attacker can execute code to infer information about the current state of a different execution context via cross-origin requests or by embedding the victim web app in the attacking web application. This can lead to the attacker accessing information about a user's previous browsing activity.

Mechanism
The threat model of a cross-site leak relies on the attacker being able to direct the victim to a malicious website entirely or partially under the attacker's control. The attacker can accomplish this by compromising a previously good web page, by phishing the user to a web page which allows the user to load arbitrary code or by the use of a malicious advertisement on an otherwise safe web page.To perform a cross-site leak, the attacker must identify and include at least one state-dependent URL in the malicious application. This must be a URL that provides at least two different responses depending on the victim application's state. A URL can be crafted, for example, by linking to content that is only accessible to the user if they are logged into the target website. Including this state-dependent URL in the malicious application will initiate a cross-origin request to the target application. Since the request is a cross-origin request, the same-origin policy prevents the attacker from reading the contents of the response. However, using a browser leak method, the attacker can query specific identifiable characteristics of the response, such as the HTTP status code. This allows attackers to distinguish between different responses and gain insight into the victim application's state.While every method of including a URL in a web page can in theory be combined with every browser leak method, this does not work in practice since dependencies exist between different inclusion methods and browser leaks. Certain browser leak methods require specific inclusion techniques to succeed. For example, suppose the browser leak method relies on checking CSS attributes such as the width and height of an element. In that case, the inclusion technique must use an HTML element with a width and height property (such as an image element) that changes when a cross-origin request returns an invalid or a differently sized image.

Example
To demonstrate a common scenario of how a cross-site leak attack could occur, an example of a basic python based web application with a search endpoint interface implemented using the following Jinja template is taken.
The underlying application authenticates the user based on the cookies attached to the request and performs a textual search on the user's private information based on a string provided in a GET parameter. For every result returned, an icon that is loaded from a Content Delivery Network (CDN) is shown alongside the result.However, this simple functionality is vulnerable to a cross-leak attack, as shown by the following Javascript snippet.
This Javascript snippet, which can be embedded in a attacker-controlled web application, loads the victim web application inside an iframe, waits for the document to load and subsequently requests the icon from the CDN. The attacker can determine if the icon was cached by timing the amount of time it takes for the icon to be returned. Since the icon will only be cached iff the victim application returns atleast one result, the attacker can determine if the victim application returned any results for the given query.

History
The existence of cross-site leaks, interchangeably called XS-Leaks, has been known for over 23 years (as of 2023). There are research papers dating as far back as 2000 from Purdue University that describe a theoretical attack that leverages the HTTP cache to compromise the privacy of a user's browsing habits. In 2007, Andrew Bortz and Dan Boneh from Stanford University published a white paper detailing an attack that leveraged the use of timing information to determine the size of cross-site responses. In 2015, researchers from the Bar Ilan University detailed an attack called a cross-site search attack which used similar leaking methods, but used a amplification technique, where the input was crafted in a manner so as to grow the size of the responses extensively. This subsequently led to a proportional growth in  the time taken to generate the said responses, thus increasing the accuracy of the attack.Over the years, independent security researchers have published blog posts detailing various cross-site leak attacks against real-world applications. In 2009, Chris Evans detailed an attack against Yahoo! Mail via which a malicious site could search a user's inbox for sensitive information. More recently, in 2018, Luan Herrara detailed a security exploit that allowed them to exfiltrate data about security sensitive issues using the search functionality of Google's Monorail bug tracker that is actively used by open-source projects such as Chromium, Angle and Skia. In 2019, Terjanq, a Polish security researcher published a blog post detailing a cross-site search attack that allowed them to exfiltrate sensitive user information across multiple high-profile Google products.As part of its increased focus on dealing with security issues that hinge on misusing long-standing web-platform features, Google launched the XSLeaks Wiki in 2020, an attempt to create an open-knowledge database analyzing and compiling information about cross-site leak attacks.Recently, there has been some interest amongst the academic security community to standardize these attacks. In 2020, Sudhodanan et al. systematically summarized previous work in cross-site leaks and developed a tool called BASTA-COSI that could be used to detect leaky URLs for a specific website. In 2021, Knittel et al. proposed a formal model to evaluate and characterize cross-site leaks, allowing them to find multiple new leaks across various browsers. In 2022, Van Goethem et al. extended the model to include the concept components and evaluated currently available defences against these attacks. In 2023, a paper published by Rautenstrauch et al. systemizing previous research into cross-site leaks was awarded the Distinguished Paper Award at the IEEE Symposium of Security and Privacy.

Defenses
Despite being known about since 2000, most defences against cross-site leaks have been introduced relatively recently. Before the introduction of these defences, websites had two options to defend against cross-site leaks. The first was to ensure that the exact same response was returned for all application states, thwarting the attacker's ability to tell the requests apart. However, this approach was infeasible for any non-trivial website. The second approach was to create session-specific URLs that would not work outside of a user's specific session. This approach would limit any link sharing and thus was also infeasible and impractical.Most modern defences against cross-site leaks are extensions to the HTTP protocol that focus on either preventing state changes, making cross-origin requests stateless or completely isolating shared resources across multiple origins.

Completely isolating shared resources
One of the earliest and most well-known methods of performing cross-site leaks was using the HTTP Cache. This approach relied on querying the browser cache for unique resources that a victim's website might have loaded. By measuring the amount of time it took for a cross-origin request to resolve an attacking website could figure out if the resource was cached and, if so, which state the victim application was in. However, as of October 2020, most browsers have implemented HTTP Cache partitioning, drastically reducing the effectiveness of this approach. HTTP Cache partitioning works by multi-keying each cached request based on which website requested the resource. This means that if victim.com loads a resource and caches it, attacker.com will not be able to infer if the resource has been cached, and the request will instead always be treated as a cache miss unless attacker.com has previously cached the same request.Another, more developer-oriented feature that allows the isolation of execution contexts includes the Cross-Origin-Opener-Policy (COOP) header, which was originally added to address Spectre issues in the browser. It has proved useful for preventing cross-site leaks since if the header is set with asame-origin directive as part of the response, the browser will disallow cross-origin websites from being able to hold a reference to the defending website when it is opened from a third-party page.In addition to this, as part of a recent effort to mitigate cross-site leaks, Chrome, Brave, Microsoft Edge Firefox and Safari committed to implementing storage partitioning. This feature will allow all shared resources used by each site to be multi-keyed, thereby dramatically reducing the number of inclusion techniques which can infer states of a web application.

Preventing state changes
Cross-site leak attacks depend on the ability of the malicious web page to receive cross-origin responses from the victim application. By preventing the malicious application from being able to receive the cross-origin responses in the first place, the user is no longer in danger of having the state changes leaked. This approach is seen in defences such as the deprecated X-Frame-Options header as well as the newer frame-ancestors directive in Content-Security Policy headers, which allow the victim application to specify which websites can include it as an embedded frame. By disallowing the embedding of the website in untrusted contexts, the malicious app can no longer observe the response to the cross-origin requests made to the victim application using the embedded frame technique.A similar approach is taken by the Cross-Origin Resource Blocking (CORB) mechanism as well as the Cross-Origin-Resource-Policy (CORP) header, which allows a cross-origin request to succeed but blocks the loading of the content in third-party websites if there is a mismatch between the content type that was expected and the content type that was received. While this feature was originally introduced as part of a series of mitigations against the Spectre vulnerability, it has proved useful in preventing cross-origin leaks since it blocks the malicious web page from receiving the response and thus inferring state changes.

Making cross-origin requests stateless
One of the most effective approaches to mitigate cross-site leaks has been using the SameSite parameter in cookies. Once set to Lax or Strict, this parameter prevents the browser from sending cookies in most third-party requests, effectively making the request stateless. However, adoption of Same-Site cookies has been slow due to it requiring changes in the way many specialized web servers, such as authentication providers operate. In 2020, Chrome and Firefox announced that they would be turning on SameSite=Lax as the default state for cookies across all platforms. However, despite this, there are still certain cases where SameSite=Lax cookies are not respected, such as the LAX+POST mitigation by Chrome which allows a cross-origin site to use a SameSite=Lax cookie in a request iff the request is sent while navigating the page and it occurs within two minutes of the cookie being set. This has led to bypasses and workaround being found against the SameSite=Lax limitation that allow cross-site leaks to still occur.Another approach to mitigating cross-site leaks has been using Fetch metadata headers. These headers include the Sec-Fetch-Site, Sec-Fetch-Mode, Sec-Fetch-User and Sec-Fetch-Dest header, which provides information about the domain that initiated the request, details about how the request was initiated, and the destination of the request respectively to the defending web server. This allows the web server to distinguish between legitimate third-party, same-site requests and harmful cross-origin requests. By discriminating between these requests, the server can send a stateless response to malicious third-party requests and a stateful response to routine same-site requests. To prevent the abusive use of these headers, a web application is not allowed to set these headers, and they must instead only be set by the browser.

See also
Cross origin resource sharing
Same origin policy
Cross-site scripting
Cross-site request forgery

Notes
References
This article incorporates text by Tom Van Goethem, Gertjan Franken, Iskander Sanchez-Rola, David Dworken and Wouter Joosen available under the CC BY 4.0 license.

External links
"XSLeaks Wiki - Introduction". xsleaks.dev.
"XSinator - XS-Leak Browser Test Suite". xsinator.com.