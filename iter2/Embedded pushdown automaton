An embedded pushdown automaton or EPDA is a computational model for parsing languages generated by tree-adjoining grammars (TAGs). It is similar to the context-free grammar-parsing pushdown automaton, but instead of using a plain stack to store symbols, it has a stack of iterated stacks that store symbols, giving TAGs a generative capacity between context-free and context-sensitive grammars, or a subset of mildly context-sensitive grammars.
Embedded pushdown automata should not be confused with nested stack automata  which have more computational power.

History and applications
EPDAs were first described by K. Vijay-Shanker in his 1988 doctoral thesis. They have since been applied to more complete descriptions of classes of mildly context-sensitive grammars and have had important roles in refining the Chomsky hierarchy. Various subgrammars, such as the linear indexed grammar, can thus be defined.While natural languages have traditionally been analyzed using context-free grammars (see transformational-generative grammar and computational linguistics), this model does not work well for languages with crossed dependencies, such as Dutch, situations for which an EPDA is well suited. A detailed linguistic analysis is available in Joshi, Schabes (1997).

Theory
An EPDA is a finite state machine with a set of stacks that can be themselves accessed through the embedded stack. Each stack contains elements of the stack alphabet 
  
    
      
        
        Γ
      
    
    {\displaystyle \,\Gamma }
  , and so we define an element of a stack by 
  
    
      
        
        
          σ
          
            i
          
        
        ∈
        
          Γ
          
            ∗
          
        
      
    
    {\displaystyle \,\sigma _{i}\in \Gamma ^{*}}
  , where the star is the Kleene closure of the alphabet.
Each stack can then be defined in terms of its elements, so we denote the 
  
    
      
        
        j
      
    
    {\displaystyle \,j}
  th stack in the automaton using a double-dagger symbol: 
  
    
      
        
        
          Υ
          
            j
          
        
        =
        ‡
        
          σ
          
            j
          
        
        =
        {
        
          σ
          
            j
            ,
            k
          
        
        ,
        
          σ
          
            j
            ,
            k
            −
            1
          
        
        ,
        …
        ,
        
          σ
          
            j
            ,
            1
          
        
        }
      
    
    {\displaystyle \,\Upsilon _{j}=\ddagger \sigma _{j}=\{\sigma _{j,k},\sigma _{j,k-1},\ldots ,\sigma _{j,1}\}}
  , where 
  
    
      
        
        
          σ
          
            j
            ,
            k
          
        
      
    
    {\displaystyle \,\sigma _{j,k}}
   would be the next accessible symbol in the stack. The embedded stack of 
  
    
      
        
        m
      
    
    {\displaystyle \,m}
   stacks can thus be denoted by 
  
    
      
        
        {
        
          Υ
          
            j
          
        
        }
        =
        {
        ‡
        
          σ
          
            m
          
        
        ,
        ‡
        
          σ
          
            m
            −
            1
          
        
        ,
        …
        ,
        ‡
        
          σ
          
            1
          
        
        }
        ∈
        (
        ‡
        
          Γ
          
            +
          
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle \,\{\Upsilon _{j}\}=\{\ddagger \sigma _{m},\ddagger \sigma _{m-1},\ldots ,\ddagger \sigma _{1}\}\in (\ddagger \Gamma ^{+})^{*}}
  .We define an EPDA by the septuple (7-tuple)

  
    
      
        
        M
        =
        (
        Q
        ,
        Σ
        ,
        Γ
        ,
        δ
        ,
        
          q
          
            0
          
        
        ,
        
          Q
          
            
              F
            
          
        
        ,
        
          σ
          
            0
          
        
        )
      
    
    {\displaystyle \,M=(Q,\Sigma ,\Gamma ,\delta ,q_{0},Q_{\textrm {F}},\sigma _{0})}
   where
  
    
      
        
        Q
      
    
    {\displaystyle \,Q}
   is a finite set of states;

  
    
      
        
        Σ
      
    
    {\displaystyle \,\Sigma }
   is the finite set of the input alphabet;

  
    
      
        
        Γ
      
    
    {\displaystyle \,\Gamma }
   is the finite stack alphabet;

  
    
      
        
        
          q
          
            0
          
        
        ∈
        Q
      
    
    {\displaystyle \,q_{0}\in Q}
   is the start state;

  
    
      
        
        
          Q
          
            
              F
            
          
        
        ⊆
        Q
      
    
    {\displaystyle \,Q_{\textrm {F}}\subseteq Q}
   is the set of final states;

  
    
      
        
        
          σ
          
            0
          
        
        ∈
        Γ
      
    
    {\displaystyle \,\sigma _{0}\in \Gamma }
   is the initial stack symbol

  
    
      
        
        δ
        :
        Q
        ×
        Σ
        ×
        Γ
        →
        S
      
    
    {\displaystyle \,\delta :Q\times \Sigma \times \Gamma \rightarrow S}
   is the transition function, where 
  
    
      
        
        S
      
    
    {\displaystyle \,S}
   are finite subsets of 
  
    
      
        
        Q
        ×
        (
        ‡
        
          Γ
          
            +
          
        
        
          )
          
            ∗
          
        
        ×
        
          Γ
          
            ∗
          
        
        ×
        (
        ‡
        
          Γ
          
            +
          
        
        
          )
          
            ∗
          
        
      
    
    {\displaystyle \,Q\times (\ddagger \Gamma ^{+})^{*}\times \Gamma ^{*}\times (\ddagger \Gamma ^{+})^{*}}
  .Thus the transition function takes a state, the next symbol of the input string, and the top symbol of the current stack and generates the next state, the stacks to be pushed and popped onto the embedded stack, the pushing and popping of the current stack, and the stacks to be considered the current stacks in the next transition. More conceptually, the embedded stack is pushed and popped, the current stack is optionally pushed back onto the embedded stack, and any other stacks one would like are pushed on top of that, with the last stack being the one read from in the next iteration. Therefore, stacks can be pushed both above and below the current stack.
A given configuration is defined by

  
    
      
        
        C
        (
        M
        )
        =
        {
        q
        ,
        
          Υ
          
            m
          
        
        …
        
          Υ
          
            1
          
        
        ,
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        }
        ∈
        Q
        ×
        (
        ‡
        
          Γ
          
            +
          
        
        
          )
          
            ∗
          
        
        ×
        
          Σ
          
            ∗
          
        
        ×
        
          Σ
          
            ∗
          
        
      
    
    {\displaystyle \,C(M)=\{q,\Upsilon _{m}\ldots \Upsilon _{1},x_{1},x_{2}\}\in Q\times (\ddagger \Gamma ^{+})^{*}\times \Sigma ^{*}\times \Sigma ^{*}}
  where 
  
    
      
        
        q
      
    
    {\displaystyle \,q}
   is the current state, the 
  
    
      
        
        Υ
      
    
    {\displaystyle \,\Upsilon }
  s are the stacks in the embedded stack, with 
  
    
      
        
        
          Υ
          
            m
          
        
      
    
    {\displaystyle \,\Upsilon _{m}}
   the current stack, and for an input string 
  
    
      
        
        x
        =
        
          x
          
            1
          
        
        
          x
          
            2
          
        
        ∈
        
          Σ
          
            ∗
          
        
      
    
    {\displaystyle \,x=x_{1}x_{2}\in \Sigma ^{*}}
  , 
  
    
      
        
        
          x
          
            1
          
        
      
    
    {\displaystyle \,x_{1}}
   is the portion of the string already processed by the machine and 
  
    
      
        
        
          x
          
            2
          
        
      
    
    {\displaystyle \,x_{2}}
   is the portion to be processed, with its head being the current symbol read. Note that the empty string 
  
    
      
        
        ϵ
        ∈
        Σ
      
    
    {\displaystyle \,\epsilon \in \Sigma }
   is implicitly defined as a terminating symbol, where if the machine is at a final state when the empty string is read, the entire input string is accepted, and if not it is rejected. Such accepted strings are elements of the language

  
    
      
        
        L
        (
        M
        )
        =
        
          {
          
            x
            
              |
            
            {
            
              q
              
                0
              
            
            ,
            
              Υ
              
                0
              
            
            ,
            ϵ
            ,
            x
            }
            
              →
              
                M
              
              
                ∗
              
            
            {
            
              q
              
                
                  F
                
              
            
            ,
            
              Υ
              
                m
              
            
            …
            
              Υ
              
                1
              
            
            ,
            x
            ,
            ϵ
            }
          
          }
        
      
    
    {\displaystyle \,L(M)=\left\{x|\{q_{0},\Upsilon _{0},\epsilon ,x\}\rightarrow _{M}^{*}\{q_{\textrm {F}},\Upsilon _{m}\ldots \Upsilon _{1},x,\epsilon \}\right\}}
  where 
  
    
      
        
        
          q
          
            
              F
            
          
        
        ∈
        
          Q
          
            
              F
            
          
        
      
    
    {\displaystyle \,q_{\textrm {F}}\in Q_{\textrm {F}}}
   and 
  
    
      
        
        
          →
          
            M
          
          
            ∗
          
        
      
    
    {\displaystyle \,\rightarrow _{M}^{*}}
   defines the transition function applied over as many times as necessary to parse the string.
An informal description of EPDA can also be found in Joshi, Schabes (1997), Sect.7, p. 23-25.

k-order EPDA and the Weir hierarchy
A more precisely defined hierarchy of languages that correspond to the mildly context-sensitive class was defined by David J. Weir.
Based on the work of Nabil A. Khabbaz,
Weir's Control Language Hierarchy is a containment hierarchy of countable set of language classes where the Level-1 is defined as context-free, and Level-2 is the class of tree-adjoining and the other three grammars.
Following are some of the properties of Level-k languages in the hierarchy:

Level-k languages are properly contained in the Level-(k + 1) language class
Level-k languages can be parsed in 
  
    
      
        O
        (
        
          n
          
            3
            ⋅
            
              2
              
                k
                −
                1
              
            
          
        
        )
      
    
    {\displaystyle O(n^{3\cdot 2^{k-1}})}
   time
Level-k contains the language 
  
    
      
        {
        
          a
          
            1
          
          
            n
          
        
        …
        
          a
          
            
              2
              
                k
              
            
          
          
            n
          
        
        
          |
        
        n
        ≥
        0
        }
      
    
    {\displaystyle \{a_{1}^{n}\dotso a_{2^{k}}^{n}|n\geq 0\}}
  , but not 
  
    
      
        {
        
          a
          
            1
          
          
            n
          
        
        …
        
          a
          
            
              2
              
                k
                +
                1
              
            
          
          
            n
          
        
        
          |
        
        n
        ≥
        0
        }
      
    
    {\displaystyle \{a_{1}^{n}\dotso a_{2^{k+1}}^{n}|n\geq 0\}}
  
Level-k contains the language 
  
    
      
        {
        
          w
          
            
              2
              
                k
                −
                1
              
            
          
        
        
          |
        
        w
        ∈
        {
        a
        ,
        b
        
          }
          
            ∗
          
        
        }
      
    
    {\displaystyle \{w^{2^{k-1}}|w\in \{a,b\}^{*}\}}
  , but not 
  
    
      
        {
        
          w
          
            
              2
              
                k
                −
                1
              
            
            +
            1
          
        
        
          |
        
        w
        ∈
        {
        a
        ,
        b
        
          }
          
            ∗
          
        
        }
      
    
    {\displaystyle \{w^{2^{k-1}+1}|w\in \{a,b\}^{*}\}}
  Those properties correspond well (at least for small k > 1) to the conditions of mildly context-sensitive languages imposed by Joshi, and as k gets bigger, the language class becomes, in a sense, less mildly context-sensitive.

See also
combinatory categorial grammar

References
Further reading
Laura Kallmeyer (2010). Parsing Beyond Context-Free Grammars. Springer Science & Business Media. ISBN 978-3-642-14846-0.