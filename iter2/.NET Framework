The .NET Framework (pronounced as "dot net") is a proprietary software framework developed by Microsoft that runs primarily on Microsoft Windows. It was the predominant implementation of the Common Language Infrastructure (CLI) until being superseded by the cross-platform .NET project. It includes a large class library called Framework Class Library (FCL) and provides language interoperability (each language can use code written in other languages) across several programming languages. Programs written for .NET Framework execute in a software environment (in contrast to a hardware environment) named the Common Language Runtime (CLR). The CLR is an application virtual machine that provides services such as security, memory management, and exception handling. As such, computer code written using .NET Framework is called "managed code". FCL and CLR together constitute the .NET Framework.
FCL provides the user interface, data access, database connectivity, cryptography, web application development, numeric algorithms, and network communications. Programmers produce software by combining their source code with .NET Framework and other libraries. The framework is intended to be used by most new applications created for the Windows platform. Microsoft also produces an integrated development environment for .NET software called Visual Studio.
.NET Framework began as proprietary software, although the firm worked to standardize the software stack almost immediately, even before its first release. Despite the standardization efforts, developers, mainly those in the free and open-source software communities, expressed their unease with the selected terms and the prospects of any free and open-source implementation, especially regarding software patents. Since then, Microsoft has changed .NET development to more closely follow a contemporary model of a community-developed software project, including issuing an update to its patent promising to address the concerns.In April 2019, Microsoft released .NET Framework 4.8, the last version of the framework as a proprietary offering. Only monthly security and reliability bug fixes to that version have been released since then. No further changes to that version are planned.

History
Microsoft began developing .NET Framework in the late 1990s, originally under the name of Next Generation Windows Services (NGWS), as part of the .NET strategy. By early 2000, the first beta versions of .NET 1.0 were released.
In August 2000, Microsoft, and Intel worked to standardize Common Language Infrastructure (CLI) and C#. By December 2001, both were ratified ECMA standards. International Organization for Standardization (ISO) followed in April 2003. The current version of ISO standards are ISO/IEC 23271:2012 and ISO/IEC 23270:2006.While Microsoft and their partners hold patents for CLI and C#, ECMA and ISO require that all patents essential to implementation be made available under "reasonable and non-discriminatory terms". The firms agreed to meet these terms, and to make the patents available royalty-free. However, this did not apply to the part of the .NET Framework not covered by ECMA-ISO standards, which included Windows Forms, ADO.NET, and ASP.NET. Patents that Microsoft holds in these areas may have deterred non-Microsoft implementations of the full framework.On October 3, 2007, Microsoft announced that the source code for .NET Framework 3.5 libraries was to become available under the Microsoft Reference Source License (Ms-RSL). The source code repository became available online on January 16, 2008, and included BCL, ASP.NET, ADO.NET, Windows Forms, WPF, and XML. Scott Guthrie of Microsoft promised that LINQ, WCF, and WF libraries were being added.The .NET Compact Framework and .NET Micro Framework variants of the .NET Framework provided support for other Microsoft platforms such as Windows Mobile, Windows CE and other resource-constrained embedded devices. Silverlight provided support for web browsers via plug-ins.

In November 2014, Microsoft also produced an update to its patent grants, which further extends the scope beyond its prior pledges. Prior projects like Mono existed in a legal grey area because Microsoft's earlier grants applied only to the technology in "covered specifications", including strictly the 4th editions each of ECMA-334 and ECMA-335. The new patent promise, however, places no ceiling on the specification version, and even extends to any .NET runtime technologies documented on MSDN that have not been formally specified by the ECMA group, if a project chooses to implement them. This allows Mono and other projects to maintain feature parity with modern .NET features that have been introduced since the 4th edition was published without being at risk of patent litigation over the implementation of those features. The new grant does maintain the restriction that any implementation must maintain minimum compliance with the mandatory parts of the CLI specification.On March 31, 2016, Microsoft announced at Microsoft Build that they will completely relicense Mono under an MIT License even in scenarios where formerly a commercial license was needed. Microsoft also supplemented its prior patent promise for Mono, stating that they will not assert any "applicable patents" against parties that are "using, selling, offering for sale, importing, or distributing Mono." It was announced that the Mono Project was contributed to the .NET Foundation. These developments followed the acquisition of Xamarin, which began in February 2016 and was finished on March 18, 2016.Microsoft's press release highlights that the cross-platform commitment now allows for a fully open-source, modern server-side .NET stack. Microsoft released the source code for WPF, Windows Forms and WinUI on December 4, 2018.

Architecture
Common Language Infrastructure
Common Language Infrastructure (CLI) provides a language-neutral platform for application development and execution. By implementing the core aspects of .NET Framework within the scope of CLI, these functions will not be tied to one language but will be available across the many languages supported by the framework.

Common Language Runtime
.NET Framework includes the Common Language Runtime (CLR). It serves as the execution engine of .NET Framework and offers many services such as memory management, type safety, exception handling, garbage collection, security and thread management. All programs written for .NET Framework are executed by the CLR.
Programs written for .NET Framework are compiled into Common Intermediate Language code (CIL), as opposed to being directly compiled into machine code. During execution, an architecture-specific just-in-time compiler (JIT) turns the CIL code into machine code.

Assemblies
Compiled CIL code is stored in CLI assemblies. As mandated by the specification, assemblies are stored in Portable Executable (PE) file format, common on Windows platform for all dynamic-link library (DLL) and executable EXE files. Each assembly consists of one or more files, one of which must contain a manifest bearing the metadata for the assembly. The complete name of an assembly (not to be confused with the file name on disk) contains its simple text name, version number, culture, and public key token. Assemblies are considered equivalent if they share the same complete name.
A private key can also be used by the creator of the assembly for strong naming. The public key token determines the real-world identity of the assembly's signer. Only who knows their private key (of the double-key cryptography system) can sign assemblies that have the same strong name as a prior version assembly. Strong naming is required to add assemblies to Global Assembly Cache.
Starting with Visual Studio 2015, .NET Native compilation technology allows for the compilation of .NET code of Universal Windows Platform apps directly to machine code rather than CIL code, but the app must be written in either C# or Visual Basic.NET.

Class library
.NET Framework includes an implementation of the CLI foundational Standard Libraries. The .NET Framework Class Library (FCL) is organized in a hierarchy of namespaces. Most of the built-in application programming interfaces (APIs) are part of either System.* or Microsoft.* namespaces. These class libraries implement many common functions, such as file reading and writing, graphic rendering, database interaction, and XML document manipulation. The class libraries are available for all CLI compliant languages. The FCL implements the CLI Base Class Library (BCL) and other class librariesâ€”some are specified by CLI and other are Microsoft specific.
BCL includes a small subset of the entire class library and is the core set of classes that serve as the basic API of CLR. For .NET Framework most classes considered being part of BCL reside in mscorlib.dll, System.dll and System.Core.dll. BCL classes are available in .NET Framework as well as in CLI's alternative implementations including .NET Compact Framework, Microsoft Silverlight, .NET Core and Mono.
FCL refers to the entire class library that ships with .NET Framework. It includes BCL, an expanded set of libraries, including Windows Forms, ASP.NET, and Windows Presentation Foundation (WPF), and also extensions to the base class libraries ADO.NET, Language Integrated Query (LINQ), Windows Communication Foundation (WCF), and Workflow Foundation (WF). FCL is much larger in scope than standard libraries for languages like C++, and comparable in scope to standard libraries of Java.
With the introduction of alternative CLI's implementations (e.g., Silverlight), Microsoft introduced the concept of Portable Class Libraries (PCL) allowing a consuming library to run on more than one implementation. With the further proliferation of implementations, the PCL approach failed to scale (PCLs are defined intersections of API surface between two or more implementations). As the next evolutionary step of PCL, the .NET Standard Library was created retroactively based on the System.Runtime.dll based APIs found in UWP and Silverlight. New CLI's implementations are encouraged to implement a version of the Standard Library allowing them to run existent third-party libraries with no need of creating new versions of them. The .NET Standard Library allows an independent evolution of the library and app model layers within the .NET architecture.NuGet is the package manager for all .NET platforms. It is used to retrieve third-party libraries into a .NET project with a global library feed at NuGet.org. Private feeds can be maintained separately, e.g., by a build server or a file system directory.

C++/CLI
Microsoft introduced C++/CLI in Visual Studio 2005, which is a language and means of compiling Visual C++ programs to run within the .NET Framework. Some parts of the C++ program still run within an unmanaged Visual C++ Runtime, while specially modified parts are translated into CIL code and run with the .NET Framework's CLR.
Assemblies compiled using the C++/CLI compiler are termed mixed-mode assemblies since they contain native and managed code in the same DLL. Such assemblies are more complex to reverse engineer since .NET decompilers such as .NET Reflector reveal only the managed code.

Design principle
Interoperability
Because computer systems commonly require interaction between newer and older applications, .NET Framework provides means to access functions implemented in newer and older programs that execute outside .NET environment. Access to Component Object Model (COM) components is provided in System.Runtime.InteropServices and System.EnterpriseServices namespaces of the framework. Access to other functions is via Platform Invocation Services (P/Invoke). Access to .NET functions from native applications is via the reverse P/Invoke function.

Language independence
.NET Framework introduces a Common Type System (CTS) that defines all possible data types and programming constructs supported by CLR and how they may or may not interact conforming to CLI specifications. Because of this feature, .NET Framework supports the exchange of types and object instances between libraries and applications written using any conforming CLI language.

Type safety
CTS and the CLR used in .NET Framework also enforce type safety. This prevents ill-defined casts, wrong method invocations, and memory size issues when accessing an object. This also makes most CLI languages statically typed (with or without type inference). However, starting with .NET Framework 4.0, the Dynamic Language Runtime extended the CLR, allowing dynamically typed languages to be implemented atop the CLI.

Portability
While Microsoft has never implemented the full framework on any system except Microsoft Windows, it has engineered the framework to be cross-platform, and implementations are available for other operating systems (see Silverlight and Â§ Alternative implementations). Microsoft submitted the specifications for CLI (which includes the Base Class Libraries, CTS, and CIL), C#, and C++/CLI to both Ecma International (ECMA) and International Organization for Standardization (ISO), making them available as official standards. This makes it possible for third parties to create compatible implementations of the framework and its languages on other platforms.
Core cross-plarform .NET (formerly .NET Core) is officially available also for many Linux distributions and MacOS.

Security
.NET Framework has its own security mechanism with two general features: Code Access Security (CAS), and validation and verification. CAS is based on evidence that is associated with a specific assembly. Typically the evidence is the source of the assembly (whether it is installed on the local machine or has been downloaded from the Internet). CAS uses evidence to determine the permissions granted to the code. When calling code demands that it be granted a specific permission, CLR performs a call stack walk checking every assembly of each method in the call stack for the required permission; if any assembly is not granted the permission, it will throw a security exception.
Managed CIL bytecode is easier to reverse-engineer than native code, unless obfuscated. .NET decompiler programs enable developers with no reverse-engineering skills to view the source code behind unobfuscated .NET assemblies. In contrast, apps compiled to native machine code are much harder to reverse-engineer, and source code is almost never produced successfully, mainly because of compiler optimizations and lack of reflection. This creates concerns in the business community over the possible loss of trade secrets and the bypassing of license control mechanisms. To mitigate this, Microsoft has included Dotfuscator Community Edition with Visual Studio .NET since 2002. Third-party obfuscation tools are also available from vendors such as VMware, V.i. Labs, Turbo, and Red Gate Software. Method-level encryption tools for .NET code are available from vendors such as SafeNet.

Memory management
CLR frees the developer from the burden of managing memory (allocating and freeing up when done); it handles memory management itself by detecting when memory can be safely freed. Instantiations of .NET types (objects) are allocated from the managed heap; a pool of memory managed by CLR. As long as a reference to an object exists, which may be either direct, or via a graph of objects, the object is considered to be in use. When no reference to an object exists, and it cannot be reached or used, it becomes garbage, eligible for collection.
.NET Framework includes a garbage collector (GC) which runs periodically, on a separate thread from the application's thread, that enumerates all the unusable objects and reclaims the memory allocated to them. It is a non-deterministic, compacting, mark-and-sweep garbage collector. GC runs only when a set amount of memory has been used or there is enough pressure for memory on the system. Since it is not guaranteed when the conditions to reclaim memory are reached, GC runs are non-deterministic. Each .NET application has a set of roots, which are pointers to objects on the managed heap (managed objects). These include references to static objects, objects defined as local variables or method parameters currently in scope, and objects referred to by CPU registers. When GC runs, it pauses the application and then, for each object referred to in the root, it recursively enumerates all the objects reachable from the root objects and marks them as reachable. It uses CLI metadata and reflection to discover the objects encapsulated by an object, and then recursively walk them. It then enumerates all the objects on the heap (which were initially allocated contiguously) using reflection. All objects not marked as reachable are garbage. This is the mark phase. Since the memory held by garbage is of no consequence, it is considered free space. However, this leaves chunks of free space between objects which were initially contiguous. The objects are then compacted together to make free space on the managed heap contiguous again. Any reference to an object invalidated by moving the object is updated by GC to reflect the new location. The application is resumed after garbage collection ends. The latest version of .NET framework uses concurrent garbage collection along with user code, making pauses unnoticeable, because it is done in the background.The garbage collector used by .NET Framework is also generational. Objects are assigned a generation. Newly created objects are tagged Generation 0. Objects that survive one garbage collection are tagged Generation 1. Generation 1 objects that survive another collection are Generation 2. The framework uses up to Generation 2 objects. Higher generation objects are garbage collected less often than lower generation objects. This raises the efficiency of garbage collection, as older objects tend to have longer lifetimes than newer objects. By ignoring older objects in most collection runs, fewer checks and compaction operations are needed in total.

Performance
When an application is first launched, the .NET Framework compiles the CIL code into executable code using its just-in-time compiler, and caches the executable program into the .NET Native Image Cache. Due to caching, the application launches faster for subsequent launches, although the first launch is usually slower. To speed up the first launch, developers may use the Native Image Generator utility to manually ahead-of-time compile and cache any .NET application.The garbage collector, which is integrated into the environment, can introduce unanticipated delays of execution over which the developer has little direct control. "In large applications, the number of objects that the garbage collector needs to work with can become very large, which means it can take a very long time to visit and rearrange all of them.".NET Framework provides support for calling Streaming SIMD Extensions (SSE) via managed code from April 2014 in Visual Studio 2013 Update 2. However, Mono has provided support for SIMD Extensions as of version 2.2 within the Mono.Simd namespace in 2009. Mono's lead developer Miguel de Icaza has expressed hope that this SIMD support will be adopted by CLR's ECMA standard. Streaming SIMD Extensions have been available in x86 CPUs since the introduction of the Pentium III. Some other architectures such as ARM and MIPS also have SIMD extensions. In case the CPU lacks support for those extensions, the instructions are simulated in software.

Alternative implementations
.NET Framework was the predominant implementation of CLI, until the release of .NET. Other implementations for parts of the framework exist. Although the runtime engine is described by an ECMA-ISO specification, other implementations of it may be encumbered by patent issues; ISO standards may include the disclaimer, "Attention is drawn to the possibility that some of the elements of this document may be the subject of patent rights. ISO shall not be held responsible for identifying any or all such patent rights." It is harder to develop alternatives to FCL, which is not described by an open standard and may be subject to copyright restrictions. Also, parts of FCL have Windows-specific functions and behavior, so implementation on non-Windows platforms can be problematic.
Some alternative implementations of parts of the framework are listed here.

.NET Micro Framework is a .NET platform for extremely resource-constrained devices. It includes a small version of CLR and supports development in C# (though some developers were able to use VB.NET, albeit with an amount of hacking, and with limited functionalities) and debugging (in an emulator or on hardware), both using Microsoft Visual Studio. It also features a subset of .NET Framework Class Library (about 70 classes with about 420 methods), a GUI framework loosely based on WPF, and additional libraries specific to embedded applications.
Mono is an implementation of CLI and FCL, and provides added functions. It is licensed as free software under the MIT License. It includes support for ASP.NET, ADO.NET, and Windows Forms libraries for a wide range of architectures and operating systems. It also includes C# and VB.NET compilers.
Portable.NET (part of DotGNU) provides an implementation of CLI, parts of FCL, and a C# compiler. It supports a variety of CPUs and operating systems. The project was discontinued, with the last stable release in 2009.
Microsoft Shared Source Common Language Infrastructure is a non-free implementation of CLR. However, the last version runs on Windows XP SP2 only, and has not been updated since 2006. Thus, it does not contain all features of version 2.0 of .NET Framework.
CrossNet is an implementation of CLI and parts of FCL. It is free software using an open source MIT License.

Licensing
Microsoft managed code frameworks and their components are licensed as follows:

See also
Microsoft Foundation Class Library (MFC), an object-oriented abstraction used to ease Windows-based application programming prior to .NET Framework
.NET (formerly .NET Core)
List of CLI languages
Standard Libraries (CLI), the .NET standard libraries
Base Class Library (BCL)

Notes
References
External links

Official website
Overview of .NET Framework (MSDN)
.NET Github repository