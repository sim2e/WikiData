In computer architecture, instructions per cycle (IPC), commonly called instructions per clock, is one aspect of a processor's performance: the average number of instructions executed for each clock cycle.  It is the multiplicative inverse of cycles per instruction.

Explanation
While early generations of CPUs carried out all the steps to execute an instruction sequentially, modern CPUs can do many things in parallel. As it is impossible to just keep doubling the speed of the clock, instruction pipelining and superscalar  processor design have evolved so CPUs can use a variety of execution units in parallel - looking ahead through the incoming instructions in order to optimise them. This leads to the instructions per cycle completed being much higher than 1 and is responsible for much of the speed improvements in subsequent CPU generations.

Calculation of IPC
The calculation of IPC is done through running a set piece of code, calculating the number of machine-level instructions required to complete it, then using high-performance timers to calculate the number of clock cycles required to complete it on the actual hardware. The final result comes from dividing the number of instructions by the number of CPU clock cycles. 
The number of instructions per second and floating point operations per second for a processor can be derived by multiplying the number of instructions per cycle with the clock rate (cycles per second given in Hertz) of the processor in question.  The number of instructions per second is an approximate indicator of the likely performance of the processor.
The number of instructions executed per clock is not a constant for a given processor; it depends on how the particular software being run interacts with the processor, and indeed the entire machine, particularly the memory hierarchy.  However, certain processor features tend to lead to designs that have higher-than-average IPC values; the presence of multiple arithmetic logic units (an ALU is a processor subsystem that can perform elementary arithmetic and logical operations), and short pipelines.  When comparing different instruction sets, a simpler instruction set may lead to a higher IPC figure than an implementation of a more complex instruction set using the same chip technology; however, the more complex instruction set may be able to achieve more useful work with fewer instructions. As such comparing IPC figures between different instruction sets (for example x86 vs ARM) is usually meaningless.

Factors governing IPC
A given level of instructions per second can be achieved with a high IPC and a low clock speed (like the AMD Athlon and early Intel's Core Series), or from a low IPC and high clock speed (like the Intel Pentium 4 and to a lesser extent the AMD Bulldozer). Both are valid processor designs, and the choice between the two is often dictated by history, engineering constraints, or marketing pressures. However, a high IPC with a high frequency will always give the best performance.

Computer speed
The useful work that can be done with any computer depends on many factors besides the processor speed.  These factors include the instruction set architecture, the processor's microarchitecture, and the computer system organization (such as the design of the disk storage system and the capabilities and performance of other attached devices), the efficiency of the operating system, and the high-level design of application software.
For computer users and purchasers, application benchmarks, rather than instructions per cycle, are typically a much more useful indication of system performance.  However, IPC does provide an example of why clock speed is not the only factor relevant to computer performance.

See also
Instructions per second
Cycles per instruction
FLOPS
Megahertz myth
Benchmark (computing)


== References ==