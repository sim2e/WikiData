The history of software configuration management (SCM) in computing can be traced back as early as the 1950s, when CM (for Configuration Management), originally for hardware development and production control, was being applied to software development.  The first software configuration management was most likely done manually.  Eventually, software tools were written to manage software changes.  History records tend to be based on tools and companies, and lend concepts to a secondary plane.

Timeline
Early 1960s or even late 1950s: CDC UPDATE and IBM IEB_UPDATE.
Late 1960s into 1970s: The Librarian is released by Applied Data Research and provides an alternative to keeping programs on punched card decks for the IBM mainframe market.
Late 1960s, early 1970s: Professor Leon Pressor at the University of California, Santa Barbara produced a thesis on change and configuration control.  This concept was a response to a contract he was working on with a defense contractor who made aircraft engines for the US Navy.
Early 1970s: Unix make.
By 1970 CDC update was an advanced product.
Circa 1972: Bell Labs paper describing the original diff algorithm.
1972, with an IEEE paper in 1975: source code control system, SCCS, Marc Rochkind Bell Labs. Originally programmed in SNOBOL for OS/360; subsequently rewritten in C for Unix (used diff for comparing files).
1970s: Lisle, Illinois-based Pansophic Systems offered PANVALET, which was an early source code control system for the mainframe market.
1975: Professor Pressor's work eventually grew into a commercially available product called Change and Configuration Control (CCC) which was sold by the SoftTool corporation.
Revision Control System (RCS, Walter Tichy).
Early 1980s: patch (around 1985, Larry Wall).
1984: Aide-de-Camp
1986: Concurrent Version System (CVS).
2000: Subversion initiated by CollabNet.
Early 2000s (decade): distributed revision control systems like BitKeeper and GNU arch become viable.

Background
Until the 1980s, SCM could only be understood as CM applied to software development. Some basic concepts such as identification and baseline (well-defined point in the evolution of a project) were already clear, but what was at stake was a set of techniques oriented towards the control of the activity, and using formal processes, documents, request forms, control boards etc.
It is only after this date that the use of software tools applying directly to software artefacts representing the actual resources, has allowed SCM to grow as an autonomous entity (from traditional CM).
The use of different tools has actually led to very distinct emphases.

traditional CM for Software, typically around Change Management (examples: Continuus, CVS or ClearCase UCM)
line oriented management, based on patches or Change Sets
focused on Derived Objects and Build Management (example: Base ClearCase/clearmake)

Another view
First generation
SCCS (first released in 1973) and DSEE (considered a predecessor of Atria ClearCase), described in 1984, are two other notable VCS software tools. These tools, along with Revision Control System (RCS), are generally considered the first generation of VCS as automated software tools.

Second generation
After the first generation VCS, tools such as CVS and Subversion, which feature a locally centralized repository, could be considered as the second generation VCS. Specifically, CVS (Concurrent Versions System) was developed on top of RCS structure, improving scalability of the tool for larger groups, and later PRCS, a simpler CVS-like tool which also uses RCS-like files, but improves upon the delta compression by using Xdelta instead.
By 2006 or so, Subversion was considered to be the most popular and widely in use VCS tool from this generation and filled important weaknesses of CVS. Later SVK developed with the goal of remote contribution feature, but still the foundation of its design were similar to its predecessors.

Third generation
As Internet connectivity improved and geographically distributed software development became more common, tools emerged that did not rely on a shared central project repository. These allow users to maintain independent repositories (or forks) of a project and communicate revisions via changesets.
BitKeeper, Git, Monotone, darcs, Mercurial, and bzr
are some examples of third generation version control systems.

See also
Revision control


== References ==