Garbled circuit is a cryptographic protocol that enables two-party secure computation in which two mistrusting parties can jointly evaluate a function over their private inputs without the presence of a trusted third party. In the garbled circuit protocol, the function has to be described as a Boolean circuit.
The history of garbled circuits is complicated. The invention of garbled circuit was credited to Andrew Yao, as Yao introduced the idea in the oral presentation of a paper in FOCS'86. This was documented by Oded Goldreich in 2003. The first written document about this technique was by Goldreich, Micali, and
Wigderson in STOC'87. The term "garbled circuit" was first used by Beaver, Micali, and Rogaway in STOC'90. Yao's protocol solving Yao's Millionaires' Problem was the beginning example of secure computation, yet it is not directly related to garbled circuits.

Background
Oblivious transfer
In the garbled circuit protocol, we make use of oblivious transfer. In the oblivious transfer, a string is transferred between a sender and a receiver in the following way: a sender has two strings 
  
    
      
        
          S
          
            0
          
        
      
    
    {\displaystyle S_{0}}
   and 
  
    
      
        
          S
          
            1
          
        
      
    
    {\displaystyle S_{1}}
  . The receiver chooses 
  
    
      
        b
        ∈
        {
        0
        ,
        1
        }
      
    
    {\displaystyle b\in \{0,1\}}
   and the sender sends 
  
    
      
        
          S
          
            b
          
        
      
    
    {\displaystyle S_{b}}
   with the oblivious transfer protocol such that

the receiver doesn't gain any information about the unsent string 
  
    
      
        
          S
          
            (
            1
            −
            b
            )
          
        
      
    
    {\displaystyle S_{(1-b)}}
  ,
the value of 
  
    
      
        b
      
    
    {\displaystyle b}
   is not exposed to the sender.Note that while the receiver doesn't know the 
  
    
      
        
          S
          
            0
          
        
        ,
        
          S
          
            1
          
        
      
    
    {\displaystyle S_{0},S_{1}}
   values, in practice the receiver knows some information about what 
  
    
      
        
          S
          
            b
          
        
      
    
    {\displaystyle S_{b}}
   encodes so that the receiver is not blindly choosing 
  
    
      
        b
      
    
    {\displaystyle b}
  . That is, if 
  
    
      
        
          S
          
            0
          
        
      
    
    {\displaystyle S_{0}}
   encodes a false value, 
  
    
      
        
          S
          
            1
          
        
      
    
    {\displaystyle S_{1}}
   encodes a true value and the receiver wants to get the encoded true value, the receiver chooses 
  
    
      
        b
        =
        1
      
    
    {\displaystyle b=1}
  .
The oblivious transfer can be built using asymmetric cryptography like the RSA cryptosystem.

Definitions and notations
Operator 
  
    
      
        ∥
      
    
    {\displaystyle \parallel }
   is string concatenation. Operator 
  
    
      
        ⊕
      
    
    {\displaystyle \oplus }
   is bit-wise XOR. k is a security parameter and the length of keys. It should be greater than 80 and is usually set at 128.

Garbled circuit protocol
The protocol consists of 6 steps as follows:

The underlying function (e.g., in the millionaires' problem, comparison function) is described as a Boolean circuit with 2-input gates. The circuit is known to both parties. This step can be done beforehand by a third-party.
Alice garbles (encrypts) the circuit. We call Alice the garbler.
Alice sends the garbled circuit to Bob along with her encrypted input.
In order to calculate the circuit, Bob needs to garble his own input as well. To this end, he needs Alice to help him, because only the garbler knows how to encrypt. Finally, Bob can encrypt his input through oblivious transfer. In terms of the definition from above, Bob is the receiver and Alice the sender at this oblivious transfer.
Bob evaluates (decrypts) the circuit and obtains the encrypted outputs. We call Bob the evaluator.
Alice and Bob communicate to learn the output.

Circuit generation
The Boolean circuit for small functions can be generated by hand. It is conventional to make the circuit out of 2-input XOR and AND gates. It is important that the generated circuit has the minimum number of AND gates (see Free XOR optimization). There are methods that generate the optimized circuit in term of number of AND gates using logic synthesis technique. The circuit for the Millionaires' Problem is a digital comparator circuit (which is a chain of full adders working as a subtractor and outputting the carry flag). A full adder circuit can be implemented using only one AND gate and some XOR gates. This means the total number of AND gates for the circuit of the Millionaires' Problem is equal to the bit-width of the inputs.

Garbling
Alice (garbler) encrypts the Boolean circuit in this step to obtain a garbled circuit. Alice assigns two randomly generated strings called labels to each wire in the circuit: one for Boolean semantic 0 and one for 1. (The label is k-bit long where k the security parameter and is usually set to 128.) Next, she goes to all the gates in the circuit and replaces 0 and 1 in the truth tables with the corresponding labels. The table below shows the truth table for an AND gate with two inputs 
  
    
      
        
          w
          
            a
          
        
        ,
        
          w
          
            b
          
        
      
    
    {\displaystyle w^{a},w^{b}}
   and output 
  
    
      
        
          w
          
            c
          
        
      
    
    {\displaystyle w^{c}}
  :

Alice replaced 0 and 1 with the corresponding labels:

She then encrypts the output entry of the truth table with the corresponding two input labels. The encrypted table is called garbled table. This is done such that one can decrypt the garbled table only if he has the correct two input labels. In the table below, 
  
    
      
        E
        n
        
          c
          
            k
          
        
        (
        X
        )
      
    
    {\displaystyle Enc_{k}(X)}
   is a double-key symmetric encryption in which k is the secret key and X is the value to be encrypted (see Fixed-Key Blockcipher).

After this, Alice randomly permutes the table such that the output value cannot be determined from the row. The protocol's name, garbled, is derived from this random permutation.

Data transfer
Alice sends the computed garbled tables for all gates in the circuit to Bob. Bob needs input labels to open the garbled tables. Thus, Alice chooses the labels corresponding to her input 
  
    
      
        a
      
    
    {\displaystyle a}
   and sends them to Bob. For example, if Alice's input is 
  
    
      
        
          a
        
        =
        
          a
          
            4
          
        
        
          a
          
            3
          
        
        
          a
          
            2
          
        
        
          a
          
            1
          
        
        
          a
          
            0
          
        
        =
        01101
      
    
    {\displaystyle \mathbf {a} =a_{4}a_{3}a_{2}a_{1}a_{0}=01101}
  , then she sends 
  
    
      
        
          X
          
            0
          
          
            
              a
              
                4
              
            
          
        
      
    
    {\displaystyle X_{0}^{a_{4}}}
  , 
  
    
      
        
          X
          
            1
          
          
            
              a
              
                3
              
            
          
        
      
    
    {\displaystyle X_{1}^{a_{3}}}
  , 
  
    
      
        
          X
          
            1
          
          
            
              a
              
                2
              
            
          
        
      
    
    {\displaystyle X_{1}^{a_{2}}}
  , 
  
    
      
        
          X
          
            0
          
          
            
              a
              
                1
              
            
          
        
      
    
    {\displaystyle X_{0}^{a_{1}}}
  , and 
  
    
      
        
          X
          
            1
          
          
            
              a
              
                0
              
            
          
        
      
    
    {\displaystyle X_{1}^{a_{0}}}
   to Bob. Bob will not learn anything about Alice's input, 
  
    
      
        
          a
        
      
    
    {\displaystyle \mathbf {a} }
  , since the labels are randomly generated by Alice and they look like random strings to Bob.
Bob needs the labels corresponding to his input as well. He receives his labels through oblivious transfers for each bit of his input. For example, if Bob's input is 
  
    
      
        
          b
        
        =
        
          b
          
            4
          
        
        
          b
          
            3
          
        
        
          b
          
            2
          
        
        
          b
          
            1
          
        
        
          b
          
            0
          
        
        =
        10100
      
    
    {\displaystyle \mathbf {b} =b_{4}b_{3}b_{2}b_{1}b_{0}=10100}
  , Bob first asks for 
  
    
      
        
          b
          
            0
          
        
        =
        0
      
    
    {\displaystyle b_{0}=0}
   between Alice's labels 
  
    
      
        
          X
          
            0
          
          
            
              b
              
                0
              
            
          
        
      
    
    {\displaystyle X_{0}^{b_{0}}}
   and 
  
    
      
        
          X
          
            1
          
          
            
              b
              
                0
              
            
          
        
      
    
    {\displaystyle X_{1}^{b_{0}}}
  . Through a 1-out-of-2 oblivious transfer, he receives 
  
    
      
        
          X
          
            0
          
          
            
              b
              
                0
              
            
          
        
      
    
    {\displaystyle X_{0}^{b_{0}}}
   and so on. After the oblivious transfers, Alice will not learn anything about Bob's input and Bob will not learn anything about the other labels.

Evaluation
After the data transfer, Bob has the garbled tables and the input labels. He goes through all gates one by one and tries to decrypt the rows in their garbled tables. He is able to open one row for each table and retrieve the corresponding output label: 
  
    
      
        
          X
          
            c
          
        
        =
        D
        e
        
          c
          
            
              X
              
                a
              
            
            ,
            
              X
              
                b
              
            
          
        
        (
        g
        a
        r
        b
        l
        e
        d
        _
        t
        a
        b
        l
        e
        [
        i
        ]
        )
      
    
    {\displaystyle X^{c}=Dec_{X^{a},X^{b}}(garbled\_table[i])}
  , where 
  
    
      
        0
        ≤
        i
        ≤
        3
      
    
    {\displaystyle 0\leq i\leq 3}
  . He continues the evaluation until he reaches to the output labels.

Revealing output
After the evaluation, Bob obtains the output label, 
  
    
      
        
          X
          
            c
          
        
      
    
    {\displaystyle X^{c}}
  , and Alice knows its mapping to Boolean value since she has both labels: 
  
    
      
        
          X
          
            0
          
          
            c
          
        
      
    
    {\displaystyle X_{0}^{c}}
   and 
  
    
      
        
          X
          
            1
          
          
            c
          
        
      
    
    {\displaystyle X_{1}^{c}}
  . Either Alice can share her information to Bob or Bob can reveal the output to Alice such that one or both of them learn the output.

Optimization
Point-and-permute
In this optimization, Alice generates a random bit, 
  
    
      
        s
      
    
    {\displaystyle s}
  , called select bit for each wire 
  
    
      
        w
      
    
    {\displaystyle w}
  . She sets the first bit of label 0, 
  
    
      
        
          X
          
            0
          
          
            a
          
        
      
    
    {\displaystyle X_{0}^{a}}
   to 
  
    
      
        s
      
    
    {\displaystyle s}
   and the first bit of label 1, 
  
    
      
        
          X
          
            1
          
          
            a
          
        
      
    
    {\displaystyle X_{1}^{a}}
  , to 
  
    
      
        
          
            
              s
              ¯
            
          
        
      
    
    {\displaystyle {\bar {s}}}
   (NOT of 
  
    
      
        s
      
    
    {\displaystyle s}
  ). She does the same for wire 
  
    
      
        
          w
          
            b
          
        
      
    
    {\displaystyle w^{b}}
  . She then, instead of randomly permuting, sorts the garbled table according to the inputs select bits. This way, Bob does not need to test all four rows of the table to find the correct one, since he receives the pointer bits with each wire label and can find the correct row and decrypt it with one attempt. This reduces the evaluation load by 4 times. It also does not reveal anything about the output value because the select bits are randomly generated.

Row reduction
This optimization reduces the size of garbled tables from 4 rows to 3 rows. Here, instead of generating a label for the output wire of a gate randomly, Alice generates it using a function of the input labels. She generates the output labels such that the first entry of the garbled table becomes all 0 and no longer needs to be sent:
  
    
      
        
          
            
              
              
                E
                n
                
                  c
                  
                    
                      X
                      
                        0
                      
                      
                        a
                      
                    
                    ,
                    
                      X
                      
                        0
                      
                      
                        b
                      
                    
                  
                
                (
                
                  X
                  
                    0
                  
                  
                    c
                  
                
                )
                =
                0
              
            
            
              
              
                
                  X
                  
                    0
                  
                  
                    c
                  
                
                =
                D
                e
                
                  c
                  
                    
                      X
                      
                        0
                      
                      
                        a
                      
                    
                    ,
                    
                      X
                      
                        0
                      
                      
                        b
                      
                    
                  
                
                (
                0
                )
                .
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}&Enc_{X_{0}^{a},X_{0}^{b}}(X_{0}^{c})=0\\&X_{0}^{c}=Dec_{X_{0}^{a},X_{0}^{b}}(0).\end{aligned}}}

Free XOR
In this optimization, Alice generates a global random (k-1)-bit value 
  
    
      
        R
      
    
    {\displaystyle R}
   which is kept secret. During the garbling of the input gates 
  
    
      
        
          w
          
            a
          
        
      
    
    {\displaystyle w^{a}}
   and 
  
    
      
        
          w
          
            b
          
        
      
    
    {\displaystyle w^{b}}
  , she only generates the labels 
  
    
      
        (
        
          X
          
            0
          
          
            a
          
        
        ,
        
          X
          
            0
          
          
            b
          
        
        )
      
    
    {\displaystyle (X_{0}^{a},X_{0}^{b})}
   and computes the other labels as 
  
    
      
        
          X
          
            1
          
          
            a
          
        
        =
        
          X
          
            0
          
          
            a
          
        
        ⊕
        (
        R
        ∥
        1
        )
      
    
    {\displaystyle X_{1}^{a}=X_{0}^{a}\oplus (R\parallel 1)}
   and 
  
    
      
        
          X
          
            1
          
          
            b
          
        
        =
        
          X
          
            0
          
          
            b
          
        
        ⊕
        (
        R
        ∥
        1
        )
      
    
    {\displaystyle X_{1}^{b}=X_{0}^{b}\oplus (R\parallel 1)}
  . Using these values, the label of an XOR gate's output wire 
  
    
      
        
          w
          
            c
          
        
      
    
    {\displaystyle w^{c}}
   with input wires 
  
    
      
        
          w
          
            a
          
        
      
    
    {\displaystyle w^{a}}
  , 
  
    
      
        
          w
          
            b
          
        
      
    
    {\displaystyle w^{b}}
   is set to 
  
    
      
        
          X
          
            c
          
        
        =
        
          X
          
            a
          
        
        ⊕
        
          X
          
            b
          
        
      
    
    {\displaystyle X^{c}=X^{a}\oplus X^{b}}
  . The proof of security in the Random Oracle Model for this optimization is given in the Free-XOR paper.

Implication
Free XOR optimization implies an important point that the amount of data transfer (communication) and number of encryption and decryption (computation) of the garbled circuit protocol relies only on the number of AND gates in the Boolean circuit not the XOR gates. Thus, between two Boolean circuits representing the same function, the one with the smaller number of AND gates is preferred.

Fixed-key blockcipher
This method allows to efficiently garble and evaluate AND gates using fixed-key AES, instead of costly cryptographic hash function like SHA-2. In this garbling scheme which is compatible with the Free XOR and Row Reduction techniques, the output key 
  
    
      
        
          X
          
            c
          
        
      
    
    {\displaystyle X^{c}}
   is encrypted with the input token 
  
    
      
        
          X
          
            a
          
        
      
    
    {\displaystyle X^{a}}
   and 
  
    
      
        
          X
          
            b
          
        
      
    
    {\displaystyle X^{b}}
   using the encryption function 
  
    
      
        E
        n
        c
        (
        
          X
          
            a
          
        
        ,
        
          X
          
            b
          
        
        ,
        T
        ,
        
          X
          
            c
          
        
        )
        =
        π
        (
        K
        )
        ⊕
        K
        ⊕
        
          X
          
            c
          
        
      
    
    {\displaystyle Enc(X^{a},X^{b},T,X^{c})=\pi (K)\oplus K\oplus X^{c}}
  , where 
  
    
      
        K
        =
        2
        
          X
          
            a
          
        
        ⊕
        4
        
          X
          
            b
          
        
        ⊕
        T
      
    
    {\displaystyle K=2X^{a}\oplus 4X^{b}\oplus T}
  , 
  
    
      
        π
      
    
    {\displaystyle \pi }
   is a fixed-key block cipher (e.g., instantiated with AES), and 
  
    
      
        T
      
    
    {\displaystyle T}
   is a unique-per-gate number (e.g., gate identifier) called tweak.

Half And
This optimization reduce the size of garbled table for AND gates from 3 row in Row Reduction to 2 rows. It is shown that this is the theoretical minimum for the number of rows in the garbled table, for a certain class of garbling techniques.

Security
The Yao's Garbled Circuit is secure against a semi-honest adversary. This type of adversary follows the protocol and does not do any malicious behavior, but it tries to violate the privacy of the other party's input by scrutinizing the messages transmitted in the protocol.
It is more challenging to make this protocol secure against a malicious adversary that deviates from the protocol. One of the first solutions to make the protocol secure against malicious adversary is to use zero-knowledge proof to prevent malicious activities during the protocol. For years, this approach was considered more as theoretical solution than a practical solution because of complexity overheads of it. But, it is shown that it is possible to use it with just a small overhead. Another approach is using several GC for a circuit and verifying the correctness of a subset of them and then using the rest for the computation with the hope that if the garbler was malicious, it would be detected during the verification phase. Another solution is to make the garbling scheme authenticated such that the evaluator can verify the garbled circuit.

See also
Cryptography
RSA
Secure multi-party computation
Yao's Millionaires' Problem

References
Further reading
"Yao's Garbled Circuit" (PDF). CS598. illinois.edu. Retrieved 18 October 2016.