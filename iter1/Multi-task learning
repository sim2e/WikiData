Multi-task learning (MTL) is a subfield of machine learning in which multiple learning tasks are solved at the same time, while exploiting commonalities and differences across tasks. This can result in improved learning efficiency and prediction accuracy for the task-specific models, when compared to training the models separately. Early versions of MTL were called "hints".
In a widely cited 1997 paper, Rich Caruana gave the following characterization:Multitask Learning is an approach to inductive transfer that improves generalization by using the domain information contained in the training signals of related tasks as an inductive bias. It does this by learning tasks in parallel while using a shared representation; what is learned for each task can help other tasks be learned better.
In the classification context, MTL aims to improve the performance of multiple classification tasks by learning them jointly. One example is a spam-filter, which can be treated as distinct but related classification tasks across different users. To make this more concrete, consider that different people have different distributions of features which distinguish spam emails from legitimate ones, for example an English speaker may find that all emails in Russian are spam, not so for Russian speakers. Yet there is a definite commonality in this classification task across users, for example one common feature might be text related to money transfer. Solving each user's spam classification problem jointly via MTL can let the solutions inform each other and improve performance. Further examples of settings for MTL include multiclass classification and multi-label classification.Multi-task learning works because regularization induced by requiring an algorithm to perform well on a related task can be superior to regularization that prevents overfitting by penalizing all complexity uniformly. One situation where MTL may be particularly helpful is if the tasks share significant commonalities and are generally slightly under sampled. However, as discussed below, MTL has also been shown to be beneficial for learning unrelated tasks.

Methods
Task grouping and overlap
Within the MTL paradigm, information can be shared across some or all of the tasks. Depending on the structure of task relatedness, one may want to share information selectively across the tasks. For example, tasks may be grouped or exist in a hierarchy, or be related according to some general metric. Suppose, as developed more formally below, that the parameter vector modeling each task is a linear combination of some underlying basis. Similarity in terms of this basis can indicate the relatedness of the tasks. For example, with sparsity, overlap of nonzero coefficients across tasks indicates commonality. A task grouping then corresponds to those tasks lying in a subspace generated by some subset of basis elements, where tasks in different groups may be disjoint or overlap arbitrarily in terms of their bases. Task relatedness can be imposed a priori or learned from the data. Hierarchical task relatedness can also be exploited implicitly without assuming a priori knowledge or learning relations explicitly. For example, the explicit learning of sample relevance across tasks can be done to guarantee the effectiveness of joint learning across multiple domains.

Exploiting unrelated tasks
One can attempt learning a group of principal tasks using a group of auxiliary tasks, unrelated to the principal ones. In many applications, joint learning of unrelated tasks which use the same input data can be beneficial. The reason is that prior knowledge about task relatedness can lead to sparser and more informative representations for each task grouping, essentially by screening out idiosyncrasies of the data distribution. Novel methods which builds on a prior multitask methodology by favoring a shared low-dimensional representation within each task grouping have been proposed. The programmer can impose a penalty on tasks from different groups which encourages the two representations to be orthogonal. Experiments on synthetic and real data have indicated that incorporating unrelated tasks can result in significant improvements over standard multi-task learning methods.

Transfer of knowledge
Related to multi-task learning is the concept of knowledge transfer. Whereas traditional multi-task learning implies that a shared representation is developed concurrently across tasks, transfer of knowledge implies a sequentially shared representation. Large scale machine learning projects such as the deep convolutional neural network GoogLeNet, an image-based object classifier, can develop robust representations which may be useful to further algorithms learning related tasks. For example, the pre-trained model can be used as a feature extractor to perform pre-processing for another learning algorithm. Or the pre-trained model can be used to initialize a model with similar architecture which is then fine-tuned to learn a different classification task.

Group online adaptive learning
Traditionally Multi-task learning and transfer of knowledge are applied to stationary learning settings. Their extension to non-stationary environments is termed Group online adaptive learning (GOAL). Sharing information could be particularly useful if learners operate in continuously changing environments, because a learner could benefit from previous experience of another learner to quickly adapt to their new environment. Such group-adaptive learning has numerous applications, from predicting financial time-series, through content recommendation systems, to visual understanding for adaptive autonomous agents.

Mathematics
Reproducing Hilbert space of vector valued functions (RKHSvv)
The MTL problem can be cast within the context of RKHSvv (a complete inner product space of vector-valued functions equipped with a reproducing kernel). In particular, recent focus has been on cases where task structure can be identified via a separable kernel, described below. The presentation here derives from Ciliberto et al., 2015.

RKHSvv concepts
Suppose the training data set is 
  
    
      
        
          
            
              S
            
          
          
            t
          
        
        =
        {
        (
        
          x
          
            i
          
          
            t
          
        
        ,
        
          y
          
            i
          
          
            t
          
        
        )
        
          }
          
            i
            =
            1
          
          
            
              n
              
                t
              
            
          
        
      
    
    {\displaystyle {\mathcal {S}}_{t}=\{(x_{i}^{t},y_{i}^{t})\}_{i=1}^{n_{t}}}
  , with 
  
    
      
        
          x
          
            i
          
          
            t
          
        
        ∈
        
          
            X
          
        
      
    
    {\displaystyle x_{i}^{t}\in {\mathcal {X}}}
  , 
  
    
      
        
          y
          
            i
          
          
            t
          
        
        ∈
        
          
            Y
          
        
      
    
    {\displaystyle y_{i}^{t}\in {\mathcal {Y}}}
  , where t indexes task, and 
  
    
      
        t
        ∈
        1
        ,
        .
        .
        .
        ,
        T
      
    
    {\displaystyle t\in 1,...,T}
  . Let 
  
    
      
        n
        =
        
          ∑
          
            t
            =
            1
          
          
            T
          
        
        
          n
          
            t
          
        
      
    
    {\displaystyle n=\sum _{t=1}^{T}n_{t}}
  . In this setting there is a consistent input and output space and the same loss function 
  
    
      
        
          
            L
          
        
        :
        
          R
        
        ×
        
          R
        
        →
        
          
            R
          
          
            +
          
        
      
    
    {\displaystyle {\mathcal {L}}:\mathbb {R} \times \mathbb {R} \rightarrow \mathbb {R} _{+}}
   for each task: . This results in the regularized machine learning problem: 

where 
  
    
      
        
          
            H
          
        
      
    
    {\displaystyle {\mathcal {H}}}
   is a vector valued reproducing kernel Hilbert space with functions 
  
    
      
        f
        :
        
          
            X
          
        
        →
        
          
            
              Y
            
          
          
            T
          
        
      
    
    {\displaystyle f:{\mathcal {X}}\rightarrow {\mathcal {Y}}^{T}}
   having components 
  
    
      
        
          f
          
            t
          
        
        :
        
          
            X
          
        
        →
        
          
            Y
          
        
      
    
    {\displaystyle f_{t}:{\mathcal {X}}\rightarrow {\mathcal {Y}}}
  .
The reproducing kernel for the space 
  
    
      
        
          
            H
          
        
      
    
    {\displaystyle {\mathcal {H}}}
   of functions   
  
    
      
        f
        :
        
          
            X
          
        
        →
        
          
            R
          
          
            T
          
        
      
    
    {\displaystyle f:{\mathcal {X}}\rightarrow \mathbb {R} ^{T}}
   is a symmetric matrix-valued function 
  
    
      
        Γ
        :
        
          
            X
          
        
        ×
        
          
            X
          
        
        →
        
          
            R
          
          
            T
            ×
            T
          
        
      
    
    {\displaystyle \Gamma :{\mathcal {X}}\times {\mathcal {X}}\rightarrow \mathbb {R} ^{T\times T}}
    , such that 
  
    
      
        Γ
        (
        ⋅
        ,
        x
        )
        c
        ∈
        
          
            H
          
        
      
    
    {\displaystyle \Gamma (\cdot ,x)c\in {\mathcal {H}}}
   and the following reproducing property holds: 

 The reproducing kernel gives rise to a representer theorem showing that any solution to equation 1 has the form:

Separable kernels
The form of the kernel Γ induces both the representation of the feature space and structures the output across tasks. A natural simplification is to choose a separable kernel, which factors into separate kernels on the input space X and on the tasks 
  
    
      
        {
        1
        ,
        .
        .
        .
        ,
        T
        }
      
    
    {\displaystyle \{1,...,T\}}
  . In this case the kernel relating scalar components 
  
    
      
        
          f
          
            t
          
        
      
    
    {\displaystyle f_{t}}
   and 
  
    
      
        
          f
          
            s
          
        
      
    
    {\displaystyle f_{s}}
   is given by 
  
    
      
        γ
        (
        (
        
          x
          
            i
          
        
        ,
        t
        )
        ,
        (
        
          x
          
            j
          
        
        ,
        s
        )
        )
        =
        k
        (
        
          x
          
            i
          
        
        ,
        
          x
          
            j
          
        
        )
        
          k
          
            T
          
        
        (
        s
        ,
        t
        )
        =
        k
        (
        
          x
          
            i
          
        
        ,
        
          x
          
            j
          
        
        )
        
          A
          
            s
            ,
            t
          
        
      
    
    {\textstyle \gamma ((x_{i},t),(x_{j},s))=k(x_{i},x_{j})k_{T}(s,t)=k(x_{i},x_{j})A_{s,t}}
  . For vector valued functions  
  
    
      
        f
        ∈
        
          
            H
          
        
      
    
    {\displaystyle f\in {\mathcal {H}}}
    we can write 
  
    
      
        Γ
        (
        
          x
          
            i
          
        
        ,
        
          x
          
            j
          
        
        )
        =
        k
        (
        
          x
          
            i
          
        
        ,
        
          x
          
            j
          
        
        )
        A
      
    
    {\displaystyle \Gamma (x_{i},x_{j})=k(x_{i},x_{j})A}
  , where k is a scalar reproducing kernel, and A is a symmetric positive semi-definite 
  
    
      
        T
        ×
        T
      
    
    {\displaystyle T\times T}
   matrix. Henceforth denote 
  
    
      
        
          S
          
            +
          
          
            T
          
        
        =
        {
        
          PSD matrices
        
        }
        ⊂
        
          
            R
          
          
            T
            ×
            T
          
        
      
    
    {\displaystyle S_{+}^{T}=\{{\text{PSD matrices}}\}\subset \mathbb {R} ^{T\times T}}
   .
This factorization property, separability, implies the input feature space representation does not vary by task. That is, there is no interaction between the input kernel and the task kernel. The structure on tasks is represented solely by A. Methods for non-separable kernels Γ is a current field of research.
For the separable case, the representation theorem is reduced to 
  
    
      
        f
        (
        x
        )
        =
        
          ∑
          
            i
            =
            1
          
          
            N
          
        
        k
        (
        x
        ,
        
          x
          
            i
          
        
        )
        A
        
          c
          
            i
          
        
      
    
    {\textstyle f(x)=\sum _{i=1}^{N}k(x,x_{i})Ac_{i}}
  . The model output on the training data is then KCA , where K is the 
  
    
      
        n
        ×
        n
      
    
    {\displaystyle n\times n}
   empirical kernel matrix with entries 
  
    
      
        
          K
          
            i
            ,
            j
          
        
        =
        k
        (
        
          x
          
            i
          
        
        ,
        
          x
          
            j
          
        
        )
      
    
    {\textstyle K_{i,j}=k(x_{i},x_{j})}
  , and C  is the 
  
    
      
        n
        ×
        T
      
    
    {\displaystyle n\times T}
   matrix of rows 
  
    
      
        
          c
          
            i
          
        
      
    
    {\displaystyle c_{i}}
  .
With the separable kernel, equation  1 can be rewritten as

where V is a (weighted) average of L applied entry-wise to Y and KCA. (The weight is zero if 
  
    
      
        
          Y
          
            i
          
          
            t
          
        
      
    
    {\displaystyle Y_{i}^{t}}
   is a missing observation).
Note the second term in P can be derived as follows:

  
    
      
        
          
            
              
                ‖
                f
                
                  ‖
                  
                    
                      H
                    
                  
                  
                    2
                  
                
              
              
                
                =
                
                  
                    ⟨
                    
                      
                        ∑
                        
                          i
                          =
                          1
                        
                        
                          n
                        
                      
                      k
                      (
                      ⋅
                      ,
                      
                        x
                        
                          i
                        
                      
                      )
                      A
                      
                        c
                        
                          i
                        
                      
                      ,
                      
                        ∑
                        
                          j
                          =
                          1
                        
                        
                          n
                        
                      
                      k
                      (
                      ⋅
                      ,
                      
                        x
                        
                          j
                        
                      
                      )
                      A
                      
                        c
                        
                          j
                        
                      
                    
                    ⟩
                  
                  
                    
                      H
                    
                  
                
              
            
            
              
              
                
                =
                
                  ∑
                  
                    i
                    ,
                    j
                    =
                    1
                  
                  
                    n
                  
                
                ⟨
                k
                (
                ⋅
                ,
                
                  x
                  
                    i
                  
                
                )
                A
                
                  c
                  
                    i
                  
                
                ,
                k
                (
                ⋅
                ,
                
                  x
                  
                    j
                  
                
                )
                A
                
                  c
                  
                    j
                  
                
                
                  ⟩
                  
                    
                      H
                    
                  
                
              
              
                
                  (bilinearity)
                
              
            
            
              
              
                
                =
                
                  ∑
                  
                    i
                    ,
                    j
                    =
                    1
                  
                  
                    n
                  
                
                ⟨
                k
                (
                
                  x
                  
                    i
                  
                
                ,
                
                  x
                  
                    j
                  
                
                )
                A
                
                  c
                  
                    i
                  
                
                ,
                
                  c
                  
                    j
                  
                
                
                  ⟩
                  
                    
                      
                        R
                      
                      
                        T
                      
                    
                  
                
              
              
                
                  (reproducing property)
                
              
            
            
              
              
                
                =
                
                  ∑
                  
                    i
                    ,
                    j
                    =
                    1
                  
                  
                    n
                  
                
                k
                (
                
                  x
                  
                    i
                  
                
                ,
                
                  x
                  
                    j
                  
                
                )
                
                  c
                  
                    i
                  
                  
                    ⊤
                  
                
                A
                
                  c
                  
                    j
                  
                
                =
                t
                r
                (
                K
                C
                A
                
                  C
                  
                    ⊤
                  
                
                )
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\|f\|_{\mathcal {H}}^{2}&=\left\langle \sum _{i=1}^{n}k(\cdot ,x_{i})Ac_{i},\sum _{j=1}^{n}k(\cdot ,x_{j})Ac_{j}\right\rangle _{\mathcal {H}}\\&=\sum _{i,j=1}^{n}\langle k(\cdot ,x_{i})Ac_{i},k(\cdot ,x_{j})Ac_{j}\rangle _{\mathcal {H}}&{\text{(bilinearity)}}\\&=\sum _{i,j=1}^{n}\langle k(x_{i},x_{j})Ac_{i},c_{j}\rangle _{\mathbb {R} ^{T}}&{\text{(reproducing property)}}\\&=\sum _{i,j=1}^{n}k(x_{i},x_{j})c_{i}^{\top }Ac_{j}=tr(KCAC^{\top })\end{aligned}}}

Known task structure
Task structure representations
There are three largely equivalent ways to represent task structure: through a regularizer; through an output metric, and through an output mapping.

Task structure examples
Via the regularizer formulation, one can represent a variety of task structures easily. 

Letting 
  
    
      
        
          A
          
            †
          
        
        =
        γ
        
          I
          
            T
          
        
        +
        (
        γ
        −
        λ
        )
        
          
            1
            T
          
        
        
          1
        
        
          
            1
          
          
            ⊤
          
        
      
    
    {\textstyle A^{\dagger }=\gamma I_{T}+(\gamma -\lambda ){\frac {1}{T}}\mathbf {1} \mathbf {1} ^{\top }}
   (where 
  
    
      
        
          I
          
            T
          
        
      
    
    {\displaystyle I_{T}}
   is the TxT identity matrix, and 
  
    
      
        
          1
        
        
          
            1
          
          
            ⊤
          
        
      
    
    {\textstyle \mathbf {1} \mathbf {1} ^{\top }}
   is the TxT matrix of ones) is equivalent to letting Γ control the variance 
  
    
      
        
          ∑
          
            t
          
        
        
          |
        
        
          |
        
        
          f
          
            t
          
        
        −
        
          
            
              f
              ¯
            
          
        
        
          |
        
        
          
            |
          
          
            
              
                
                  H
                
              
              
                k
              
            
          
        
      
    
    {\textstyle \sum _{t}||f_{t}-{\bar {f}}||_{{\mathcal {H}}_{k}}}
    of tasks from their mean 
  
    
      
        
          
            1
            T
          
        
        
          ∑
          
            t
          
        
        
          f
          
            t
          
        
      
    
    {\textstyle {\frac {1}{T}}\sum _{t}f_{t}}
  . For example, blood levels of some biomarker may be taken on T patients at 
  
    
      
        
          n
          
            t
          
        
      
    
    {\displaystyle n_{t}}
   time points during the course of a day and interest may lie in regularizing the variance of the predictions across patients.
Letting 
  
    
      
        
          A
          
            †
          
        
        =
        α
        
          I
          
            T
          
        
        +
        (
        α
        −
        λ
        )
        M
      
    
    {\displaystyle A^{\dagger }=\alpha I_{T}+(\alpha -\lambda )M}
   , where 
  
    
      
        
          M
          
            t
            ,
            s
          
        
        =
        
          
            1
            
              
                |
              
              
                G
                
                  r
                
              
              
                |
              
            
          
        
        
          I
        
        (
        t
        ,
        s
        ∈
        
          G
          
            r
          
        
        )
      
    
    {\displaystyle M_{t,s}={\frac {1}{|G_{r}|}}\mathbb {I} (t,s\in G_{r})}
   is equivalent to letting 
  
    
      
        α
      
    
    {\displaystyle \alpha }
   control the variance measured with respect to a group mean: 
  
    
      
        
          ∑
          
            r
          
        
        
          ∑
          
            t
            ∈
            
              G
              
                r
              
            
          
        
        
          |
        
        
          |
        
        
          f
          
            t
          
        
        −
        
          
            1
            
              
                |
              
              
                G
                
                  r
                
              
              
                |
              
            
          
        
        
          ∑
          
            s
            ∈
            
              G
              
                r
              
            
            )
          
        
        
          f
          
            s
          
        
        
          |
        
        
          |
        
      
    
    {\displaystyle \sum _{r}\sum _{t\in G_{r}}||f_{t}-{\frac {1}{|G_{r}|}}\sum _{s\in G_{r})}f_{s}||}
  . (Here 
  
    
      
        
          |
        
        
          G
          
            r
          
        
        
          |
        
      
    
    {\displaystyle |G_{r}|}
   the cardinality of group r, and 
  
    
      
        
          I
        
      
    
    {\displaystyle \mathbb {I} }
   is the indicator function). For example, people in different political parties (groups) might be regularized together with respect to predicting the favorability rating of a politician. Note that this penalty reduces to the first when all tasks are in the same group.
Letting 
  
    
      
        
          A
          
            †
          
        
        =
        δ
        
          I
          
            T
          
        
        +
        (
        δ
        −
        λ
        )
        L
      
    
    {\displaystyle A^{\dagger }=\delta I_{T}+(\delta -\lambda )L}
  , where 
  
    
      
        L
        =
        D
        −
        M
      
    
    {\displaystyle L=D-M}
   is the Laplacian for the graph with adjacency matrix M giving pairwise similarities of tasks. This is equivalent to giving a larger penalty to the distance separating tasks t and s when they are more similar (according to the weight 
  
    
      
        
          M
          
            t
            ,
            s
          
        
      
    
    {\displaystyle M_{t,s}}
  ,) i.e. 
  
    
      
        δ
      
    
    {\displaystyle \delta }
   regularizes 
  
    
      
        
          ∑
          
            t
            ,
            s
          
        
        
          |
        
        
          |
        
        
          f
          
            t
          
        
        −
        
          f
          
            s
          
        
        
          |
        
        
          
            |
          
          
            
              
                
                  H
                
              
              
                k
              
            
          
          
            2
          
        
        
          M
          
            t
            ,
            s
          
        
      
    
    {\displaystyle \sum _{t,s}||f_{t}-f_{s}||_{{\mathcal {H}}_{k}}^{2}M_{t,s}}
  .
All of the above choices of A also induce the additional regularization term  
  
    
      
        λ
        
          ∑
          
            t
          
        
        
          |
        
        
          |
        
        f
        
          |
        
        
          
            |
          
          
            
              
                
                  H
                
              
              
                k
              
            
          
          
            2
          
        
      
    
    {\textstyle \lambda \sum _{t}||f||_{{\mathcal {H}}_{k}}^{2}}
   which penalizes complexity in f more broadly.

Learning tasks together with their structure
Learning problem P can be generalized to admit learning task matrix A as follows:

Choice of 
  
    
      
        F
        :
        
          S
          
            +
          
          
            T
          
        
        →
        
          
            R
          
          
            +
          
        
      
    
    {\displaystyle F:S_{+}^{T}\rightarrow \mathbb {R} _{+}}
   must be designed to learn matrices A of a given type. See "Special cases" below.

Optimization of Q
Restricting to the case of convex losses and coercive penalties Ciliberto et al. have shown that although Q is not convex jointly in C and A, a related problem is jointly convex.
Specifically on the convex set 
  
    
      
        
          
            C
          
        
        =
        {
        (
        C
        ,
        A
        )
        ∈
        
          
            R
          
          
            n
            ×
            T
          
        
        ×
        
          S
          
            +
          
          
            T
          
        
        
          |
        
        R
        a
        n
        g
        e
        (
        
          C
          
            ⊤
          
        
        K
        C
        )
        ⊆
        R
        a
        n
        g
        e
        (
        A
        )
        }
      
    
    {\displaystyle {\mathcal {C}}=\{(C,A)\in \mathbb {R} ^{n\times T}\times S_{+}^{T}|Range(C^{\top }KC)\subseteq Range(A)\}}
  , the equivalent problem

is convex with the same minimum value. And if 
  
    
      
        (
        
          C
          
            R
          
        
        ,
        
          A
          
            R
          
        
        )
      
    
    {\displaystyle (C_{R},A_{R})}
   is a minimizer for R then 
  
    
      
        (
        
          C
          
            R
          
        
        
          A
          
            R
          
          
            †
          
        
        ,
        
          A
          
            R
          
        
        )
      
    
    {\displaystyle (C_{R}A_{R}^{\dagger },A_{R})}
   is a minimizer for Q.
R may be solved by a barrier method on a closed set by introducing the following perturbation:

The perturbation via the barrier 
  
    
      
        
          δ
          
            2
          
        
        t
        r
        (
        
          A
          
            †
          
        
        )
      
    
    {\displaystyle \delta ^{2}tr(A^{\dagger })}
   forces the objective functions to be equal to 
  
    
      
        +
        ∞
      
    
    {\displaystyle +\infty }
   on the boundary of 
  
    
      
        
          R
          
            n
            ×
            T
          
        
        ×
        
          S
          
            +
          
          
            T
          
        
      
    
    {\displaystyle R^{n\times T}\times S_{+}^{T}}
   .
S can be solved with a block coordinate descent method, alternating in C and A. This results in a sequence of minimizers 
  
    
      
        (
        
          C
          
            m
          
        
        ,
        
          A
          
            m
          
        
        )
      
    
    {\displaystyle (C_{m},A_{m})}
   in S that converges to the solution in R as 
  
    
      
        
          δ
          
            m
          
        
        →
        0
      
    
    {\displaystyle \delta _{m}\rightarrow 0}
  , and hence gives the solution to Q.

Special cases
Spectral penalties - Dinnuzo et al suggested setting F as the Frobenius norm 
  
    
      
        
          
            t
            r
            (
            
              A
              
                ⊤
              
            
            A
            )
          
        
      
    
    {\displaystyle {\sqrt {tr(A^{\top }A)}}}
  . They optimized Q directly using block coordinate descent, not accounting for difficulties at the boundary of 
  
    
      
        
          
            R
          
          
            n
            ×
            T
          
        
        ×
        
          S
          
            +
          
          
            T
          
        
      
    
    {\displaystyle \mathbb {R} ^{n\times T}\times S_{+}^{T}}
  .
Clustered tasks learning - Jacob et al suggested to learn A in the setting where T  tasks are organized in R disjoint clusters. In this case let 
  
    
      
        E
        ∈
        {
        0
        ,
        1
        
          }
          
            T
            ×
            R
          
        
      
    
    {\displaystyle E\in \{0,1\}^{T\times R}}
   be the matrix with 
  
    
      
        
          E
          
            t
            ,
            r
          
        
        =
        
          I
        
        (
        
          task 
        
        t
        ∈
        
          group 
        
        r
        )
      
    
    {\displaystyle E_{t,r}=\mathbb {I} ({\text{task }}t\in {\text{group }}r)}
  . Setting 
  
    
      
        M
        =
        I
        −
        
          E
          
            †
          
        
        
          E
          
            T
          
        
      
    
    {\displaystyle M=I-E^{\dagger }E^{T}}
  , and  
  
    
      
        U
        =
        
          
            1
            T
          
        
        
          
            11
          
          
            ⊤
          
        
      
    
    {\displaystyle U={\frac {1}{T}}\mathbf {11} ^{\top }}
  , the task matrix 
  
    
      
        
          A
          
            †
          
        
      
    
    {\displaystyle A^{\dagger }}
    can be parameterized as a function of 
  
    
      
        M
      
    
    {\displaystyle M}
  : 
  
    
      
        
          A
          
            †
          
        
        (
        M
        )
        =
        
          ϵ
          
            M
          
        
        U
        +
        
          ϵ
          
            B
          
        
        (
        M
        −
        U
        )
        +
        ϵ
        (
        I
        −
        M
        )
      
    
    {\displaystyle A^{\dagger }(M)=\epsilon _{M}U+\epsilon _{B}(M-U)+\epsilon (I-M)}
   , with terms that penalize the average, between clusters variance and within clusters variance respectively of the task predictions. M is not convex, but there is a convex relaxation 
  
    
      
        
          
            
              S
            
          
          
            c
          
        
        =
        {
        M
        ∈
        
          S
          
            +
          
          
            T
          
        
        :
        I
        −
        M
        ∈
        
          S
          
            +
          
          
            T
          
        
        ∧
        t
        r
        (
        M
        )
        =
        r
        }
      
    
    {\displaystyle {\mathcal {S}}_{c}=\{M\in S_{+}^{T}:I-M\in S_{+}^{T}\land tr(M)=r\}}
  . In this formulation,  
  
    
      
        F
        (
        A
        )
        =
        
          I
        
        (
        A
        (
        M
        )
        ∈
        {
        A
        :
        M
        ∈
        
          
            
              S
            
          
          
            C
          
        
        }
        )
      
    
    {\displaystyle F(A)=\mathbb {I} (A(M)\in \{A:M\in {\mathcal {S}}_{C}\})}
  .

Generalizations
Non-convex penalties - Penalties can be constructed such that A is constrained to be a graph Laplacian, or that A has low rank factorization. However these penalties are not convex, and the analysis of the barrier method proposed by Ciliberto et al. does not go through in these cases.
Non-separable kernels - Separable kernels are limited, in particular they do not account for structures in the interaction space between the input and output domains jointly. Future work is needed to develop models for these kernels.

Applications
Spam filtering
Using the principles of MTL, techniques for collaborative spam filtering that facilitates personalization have been proposed. In large scale open membership email systems, most users do not label enough messages for an individual local classifier to be effective, while the data is too noisy to be used for a global filter across all users. A hybrid global/individual classifier can be effective at absorbing the influence of users who label emails very diligently from the general public. This can be accomplished while still providing sufficient quality to users with few labeled instances.

Web search
Using boosted decision trees, one can enable implicit data sharing and regularization. This learning method can be used on web-search ranking data sets. One example is to use ranking data sets from several countries. Here, multitask learning is particularly helpful as data sets from different countries vary largely in size because of the cost of editorial judgments. It has been demonstrated that learning various tasks jointly can lead to significant improvements in performance with surprising reliability.

Software package
The Multi-Task Learning via StructurAl Regularization (MALSAR) Matlab package  implements the following multi-task learning algorithms:

Mean-Regularized Multi-Task Learning
Multi-Task Learning with Joint Feature Selection
Robust Multi-Task Feature Learning
Trace-Norm Regularized Multi-Task Learning
Alternating Structural Optimization
Incoherent Low-Rank and Sparse Learning
Robust Low-Rank Multi-Task Learning
Clustered Multi-Task Learning
Multi-Task Learning with Graph Structures

See also
References
External links
The Biosignals Intelligence Group at UIUC
Washington University in St. Louis Depart. of Computer Science

Software
The Multi-Task Learning via Structural Regularization Package
Online Multi-Task Learning Toolkit (OMT) A general-purpose online multi-task learning toolkit based on conditional random field models and stochastic gradient descent training (C#, .NET)