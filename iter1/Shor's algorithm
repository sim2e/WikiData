Shor's algorithm is a quantum algorithm for finding the prime factors of an integer. It was developed in 1994 by the American mathematician Peter Shor. It is one of the few known quantum algorithms with compelling potential applications and strong evidence of superpolynomial speedup compared to best known classical (that is, non-quantum) algorithms. On the other hand, factoring numbers of practical significance requires far more qubits than available in the near future. Another concern is that noise in quantum circuits may undermine results, requiring additional qubits for quantum error correction.
Shor proposed multiple similar algorithms solving the factoring problem, the discrete logarithm problem, and the period finding problem. "Shor's algorithm" usually refers to his algorithm solving factoring, but may also refer to each of the three. The discrete logarithm algorithm and the factoring algorithm are instances of the period finding algorithm, and all three are instances of the hidden subgroup problem.
On a quantum computer, to factor an integer 
  
    
      
        N
      
    
    {\displaystyle N}
  , Shor's algorithm runs in polynomial time, meaning the time taken is polynomial in 
  
    
      
        log
        ⁡
        N
      
    
    {\displaystyle \log N}
  , the size of the integer given as input. Specifically, it takes quantum gates of order 
  
    
      
        O
        
        
          (
          
            (
            log
            ⁡
            N
            
              )
              
                2
              
            
            (
            log
            ⁡
            log
            ⁡
            N
            )
            (
            log
            ⁡
            log
            ⁡
            log
            ⁡
            N
            )
          
          )
        
      
    
    {\displaystyle O\!\left((\log N)^{2}(\log \log N)(\log \log \log N)\right)}
   using fast multiplication, or even 
  
    
      
        O
        
        
          (
          
            (
            log
            ⁡
            N
            
              )
              
                2
              
            
            (
            log
            ⁡
            log
            ⁡
            N
            )
          
          )
        
      
    
    {\displaystyle O\!\left((\log N)^{2}(\log \log N)\right)}
   utilizing the asymptotically fastest multiplication algorithm currently known due to Harvey and Van Der Hoven, thus demonstrating that the integer factorization problem can be efficiently solved on a quantum computer and is consequently in the complexity class BQP. This is significantly faster than the most efficient known classical factoring algorithm, the general number field sieve, which works in sub-exponential time: 
  
    
      
        O
        
        
          (
          
            e
            
              1.9
              (
              log
              ⁡
              N
              
                )
                
                  1
                  
                    /
                  
                  3
                
              
              (
              log
              ⁡
              log
              ⁡
              N
              
                )
                
                  2
                  
                    /
                  
                  3
                
              
            
          
          )
        
      
    
    {\displaystyle O\!\left(e^{1.9(\log N)^{1/3}(\log \log N)^{2/3}}\right)}
  .

Feasibility and impact
If a quantum computer with a sufficient number of qubits could operate without succumbing to quantum noise and other quantum-decoherence phenomena, then Shor's algorithm could be used to break public-key cryptography schemes, such as

The RSA scheme
The Finite Field Diffie-Hellman key exchange
The Elliptic Curve Diffie-Hellman key exchangeRSA is based on the assumption that factoring large integers is computationally intractable. As far as is known, this assumption is valid for classical (non-quantum) computers; no classical algorithm is known that can factor integers in polynomial time. However, Shor's algorithm shows that factoring integers is efficient on an ideal quantum computer, so it may be feasible to defeat RSA by constructing a large quantum computer. It was also a powerful motivator for the design and construction of quantum computers, and for the study of new quantum-computer algorithms. It has also facilitated research on new cryptosystems that are secure from quantum computers, collectively called post-quantum cryptography.

Physical implementation
Given the high error rates of contemporary quantum computers and too few qubits to use quantum error correction, laboratory demonstrations obtain correct results only in a fraction of attempts.
In 2001, Shor's algorithm was demonstrated by a group at IBM, who factored 
  
    
      
        15
      
    
    {\displaystyle 15}
   into 
  
    
      
        3
        ×
        5
      
    
    {\displaystyle 3\times 5}
  , using an NMR implementation of a quantum computer with seven qubits. After IBM's implementation, two independent groups implemented Shor's algorithm using photonic qubits, emphasizing that multi-qubit entanglement was observed when running the Shor's algorithm circuits. In 2012, the factorization of 
  
    
      
        15
      
    
    {\displaystyle 15}
   was performed with solid-state qubits. Later, in 2012, the factorization of 
  
    
      
        21
      
    
    {\displaystyle 21}
   was achieved. In 2019, an attempt was made to factor the number 
  
    
      
        35
      
    
    {\displaystyle 35}
   using Shor's algorithm on an IBM Q System One, but the algorithm failed because of accumulating errors.  Though larger numbers have been factored by quantum computers using other algorithms, these algorithms are similar to classical brute-force checking of factors, so unlike Shor's algorithm, they are not expected to ever perform better than classical factoring algorithms.Theoretical analyses of Shor's algorithm assume a quantum computer free of noise and errors. However, near-term practical implementations will have to deal with such undesired phenomena (when more qubits are available, Quantum error correction can help). In 2023, Jin-Yi Cai studied the impact of noise and concluded that "Shor's Algorithm Does Not Factor Large Integers in the Presence of Noise."

Algorithm
The problem that we are trying to solve is: given an odd composite number 
  
    
      
        N
      
    
    {\displaystyle N}
  , find its integer factors.
To achieve this, Shor's algorithm consists of two parts:

A classical reduction of the factoring problem to the problem of order-finding. This reduction is similar to that used for other factoring algorithms, such as the quadratic sieve.
A quantum algorithm to solve the order-finding problem.

Classical reduction
A complete factoring algorithm is possible if we're able to efficiently factor arbitrary 
  
    
      
        N
      
    
    {\displaystyle N}
   into just two integers 
  
    
      
        p
      
    
    {\displaystyle p}
   and 
  
    
      
        q
      
    
    {\displaystyle q}
   greater than 1, since if either 
  
    
      
        p
      
    
    {\displaystyle p}
   or 
  
    
      
        q
      
    
    {\displaystyle q}
   are not prime then the factoring algorithm can in turn be run on those until only primes remain.
A basic observation is that, using Euclid's algorithm, we can always compute the GCD between two integers efficiently. In particular, this means we can check efficiently whether 
  
    
      
        N
      
    
    {\displaystyle N}
   is even, in which case 2 is trivially a factor. Let us thus assume that 
  
    
      
        N
      
    
    {\displaystyle N}
   is odd for the remainder of this discussion. Afterwards, we can use efficient classical algorithms to check if 
  
    
      
        N
      
    
    {\displaystyle N}
   is a prime power. For prime powers, efficient classical factorization algorithms exist, hence the rest of the quantum algorithm may assume that 
  
    
      
        N
      
    
    {\displaystyle N}
   is not a prime power.
If those easy cases do not produce a nontrivial factor of 
  
    
      
        N
      
    
    {\displaystyle N}
  , the algorithm proceeds to handle the remaining case. We pick a random integer 
  
    
      
        2
        ≤
        a
        <
        N
      
    
    {\displaystyle 2\leq a<N}
  . A possible nontrivial divisor of 
  
    
      
        N
      
    
    {\displaystyle N}
   can be found by computing 
  
    
      
        gcd
        (
        a
        ,
        N
        )
      
    
    {\displaystyle \gcd(a,N)}
  , which can be done classically and efficiently using the Euclidean algorithm. If this produces a nontrivial factor (meaning 
  
    
      
        gcd
        (
        a
        ,
        N
        )
        ≠
        1
      
    
    {\displaystyle \gcd(a,N)\neq 1}
  ), the algorithm is finished, and the other nontrivial factor is 
  
    
      
        
          
            N
            
              gcd
              (
              a
              ,
              N
              )
            
          
        
      
    
    {\textstyle {\frac {N}{\gcd(a,N)}}}
  . If a nontrivial factor was not identified, then that means that 
  
    
      
        N
      
    
    {\displaystyle N}
   and the choice of 
  
    
      
        a
      
    
    {\displaystyle a}
   are coprime. Here, the algorithm runs the quantum subroutine, which will return the order 
  
    
      
        r
      
    
    {\displaystyle r}
   of 
  
    
      
        a
      
    
    {\displaystyle a}
  , meaning

  
    
      
        
          a
          
            r
          
        
        ≡
        1
        
          mod
          
            N
          
        
        .
      
    
    {\displaystyle a^{r}\equiv 1{\bmod {N}}.}
  The quantum subroutine requires that 
  
    
      
        a
      
    
    {\displaystyle a}
   and 
  
    
      
        N
      
    
    {\displaystyle N}
   are coprime, which is true since at this point in the algorithm, 
  
    
      
        gcd
        (
        a
        ,
        N
        )
      
    
    {\displaystyle \gcd(a,N)}
   did not produce a nontrivial factor of 
  
    
      
        N
      
    
    {\displaystyle N}
  . It can be seen from the equivalence that 
  
    
      
        N
      
    
    {\displaystyle N}
   divides 
  
    
      
        
          a
          
            r
          
        
        −
        1
      
    
    {\displaystyle a^{r}-1}
  , written 
  
    
      
        N
        ∣
        
          a
          
            r
          
        
        −
        1
      
    
    {\displaystyle N\mid a^{r}-1}
  . This can be factored using difference of squares: Since we have factored the expression in this way, the algorithm doesn't work for odd 
  
    
      
        r
      
    
    {\displaystyle r}
   (because 
  
    
      
        
          a
          
            r
            
              /
            
            2
          
        
      
    
    {\displaystyle a^{r/2}}
   must be an integer), meaning the algorithm would have to restart with a new 
  
    
      
        a
      
    
    {\displaystyle a}
  . Hereafter we can therefore assume 
  
    
      
        r
      
    
    {\displaystyle r}
   is even. It cannot be the case that 
  
    
      
        N
        ∣
        
          a
          
            r
            
              /
            
            2
          
        
        −
        1
      
    
    {\displaystyle N\mid a^{r/2}-1}
  , since this would imply 
  
    
      
        
          a
          
            r
            
              /
            
            2
          
        
        ≡
        1
        
          mod
          
            N
          
        
      
    
    {\displaystyle a^{r/2}\equiv 1{\bmod {N}}}
  , which would contradictorily imply that 
  
    
      
        
          
            r
            2
          
        
      
    
    {\textstyle {\frac {r}{2}}}
   would be the order of 
  
    
      
        a
      
    
    {\displaystyle a}
  , which was already 
  
    
      
        r
      
    
    {\displaystyle r}
  . At this point, it may or may not be the case that 
  
    
      
        N
        ∣
        
          a
          
            r
            
              /
            
            2
          
        
        +
        1
      
    
    {\displaystyle N\mid a^{r/2}+1}
  . If it is not true that 
  
    
      
        N
        ∣
        
          a
          
            r
            
              /
            
            2
          
        
        +
        1
      
    
    {\displaystyle N\mid a^{r/2}+1}
  , then that means we are able to find a nontrivial factor of 
  
    
      
        N
      
    
    {\displaystyle N}
  . We computeIf 
  
    
      
        d
        =
        1
      
    
    {\displaystyle d=1}
  , then that means 
  
    
      
        N
        ∣
        
          a
          
            r
            
              /
            
            2
          
        
        +
        1
      
    
    {\displaystyle N\mid a^{r/2}+1}
   was true, and a nontrivial factor of 
  
    
      
        N
      
    
    {\displaystyle N}
   cannot be achieved from 
  
    
      
        a
      
    
    {\displaystyle a}
  , and the algorithm must restart with a new 
  
    
      
        a
      
    
    {\displaystyle a}
  . Otherwise, we have found a nontrivial factor of 
  
    
      
        N
      
    
    {\displaystyle N}
  , with the other being 
  
    
      
        
          
            N
            d
          
        
      
    
    {\textstyle {\frac {N}{d}}}
  , and the algorithm is finished. For this step, it is also equivalent to compute 
  
    
      
        gcd
        (
        N
        ,
        
          a
          
            r
            
              /
            
            2
          
        
        +
        1
        )
      
    
    {\displaystyle \gcd(N,a^{r/2}+1)}
  ; it will produce a nontrivial factor if 
  
    
      
        gcd
        (
        N
        ,
        
          a
          
            r
            
              /
            
            2
          
        
        −
        1
        )
      
    
    {\displaystyle \gcd(N,a^{r/2}-1)}
   is nontrivial, and will not if it's trivial (where 
  
    
      
        N
        ∣
        
          a
          
            r
            
              /
            
            2
          
        
        +
        1
      
    
    {\displaystyle N\mid a^{r/2}+1}
  ).

The algorithm restated shortly follows: let 
  
    
      
        N
      
    
    {\displaystyle N}
   be odd, and not a prime power. We want to output two nontrivial factors of 
  
    
      
        N
      
    
    {\displaystyle N}
  .It has been shown that this will be likely to succeed after a few runs. In practice, a single call to the quantum order-finding subroutine is enough to completely factor 
  
    
      
        N
      
    
    {\displaystyle N}
   with very high probability of success if one uses a more advanced reduction.

Quantum order-finding subroutine
The goal of the quantum subroutine of Shor's algorithm is, given coprime integers 
  
    
      
        N
      
    
    {\displaystyle N}
   and 
  
    
      
        1
        <
        a
        <
        N
      
    
    {\displaystyle 1<a<N}
  , to find the order 
  
    
      
        r
      
    
    {\displaystyle r}
   of 
  
    
      
        a
      
    
    {\displaystyle a}
   modulo 
  
    
      
        N
      
    
    {\displaystyle N}
  , which is the smallest positive integer such that 
  
    
      
        
          a
          
            r
          
        
        ≡
        1
        
          
          (
          mod
          
          N
          )
        
      
    
    {\displaystyle a^{r}\equiv 1{\pmod {N}}}
  . To achieve this, Shor's algorithm uses a quantum circuit involving two registers. The second register uses 
  
    
      
        n
      
    
    {\displaystyle n}
   qubits, where 
  
    
      
        n
      
    
    {\displaystyle n}
   is the smallest integer such that 
  
    
      
        N
        ≤
        
          2
          
            n
          
        
      
    
    {\displaystyle N\leq 2^{n}}
  . The size of the first register determines how accurate of an approximation the circuit produces. It can be shown that using 
  
    
      
        2
        n
        +
        1
      
    
    {\displaystyle 2n+1}
   qubits gives sufficient accuracy to find 
  
    
      
        r
      
    
    {\displaystyle r}
  . The exact quantum circuit depends on the parameters 
  
    
      
        a
      
    
    {\displaystyle a}
   and 
  
    
      
        N
      
    
    {\displaystyle N}
  , which define the problem.
The algorithm consists of two main steps:

Use quantum phase estimation with unitary 
  
    
      
        U
      
    
    {\displaystyle U}
   representing the operation of multiplying by 
  
    
      
        a
      
    
    {\displaystyle a}
   (modulo 
  
    
      
        N
      
    
    {\displaystyle N}
  ), and input state 
  
    
      
        
          |
        
        0
        
          ⟩
          
            ⊗
            2
            n
            +
            1
          
        
        ⊗
        
          |
        
        1
        ⟩
      
    
    {\displaystyle |0\rangle ^{\otimes 2n+1}\otimes |1\rangle }
   (where the second register is 
  
    
      
        
          |
        
        1
        ⟩
      
    
    {\displaystyle |1\rangle }
   made from 
  
    
      
        n
      
    
    {\displaystyle n}
   qubits). The eigenvalues of this 
  
    
      
        U
      
    
    {\displaystyle U}
   encode information about the period, and 
  
    
      
        
          |
        
        1
        ⟩
      
    
    {\displaystyle |1\rangle }
   can be seen to be writable as a sum of its eigenvectors. Thanks to these properties, the quantum phase estimation stage gives as output a random integer of the form 
  
    
      
        
          
            j
            r
          
        
        
          2
          
            2
            n
            +
            1
          
        
      
    
    {\displaystyle {\frac {j}{r}}2^{2n+1}}
   for random 
  
    
      
        j
        =
        0
        ,
        1
        ,
        .
        .
        .
        ,
        r
        −
        1
      
    
    {\displaystyle j=0,1,...,r-1}
  .
Use the continued fractions algorithm to extract the period 
  
    
      
        r
      
    
    {\displaystyle r}
   from the measurement outcomes obtained in the previous stage. This is a procedure to post-process (with a classical computer) the measurement data obtained from measuring the output quantum states, and retrieve the period.The connection with quantum phase estimation was not discussed in the original formulation of Shor's algorithm, but was later proposed by Kitaev.

Quantum phase estimation
In general the quantum phase estimation algorithm, for any unitary 
  
    
      
        U
      
    
    {\displaystyle U}
   and eigenstate 
  
    
      
        
          |
        
        ψ
        ⟩
      
    
    {\displaystyle |\psi \rangle }
   such that 
  
    
      
        U
        
          |
        
        ψ
        ⟩
        =
        
          e
          
            2
            π
            i
            θ
          
        
        
          |
        
        ψ
        ⟩
      
    
    {\displaystyle U|\psi \rangle =e^{2\pi i\theta }|\psi \rangle }
  , sends inputs states 
  
    
      
        
          |
        
        0
        ⟩
        
          |
        
        ψ
        ⟩
      
    
    {\displaystyle |0\rangle |\psi \rangle }
   into output states close to 
  
    
      
        
          |
        
        ϕ
        ⟩
        
          |
        
        ψ
        ⟩
      
    
    {\displaystyle |\phi \rangle |\psi \rangle }
  , where 
  
    
      
        ϕ
      
    
    {\displaystyle \phi }
   is an integer close to 
  
    
      
        
          2
          
            2
            n
            +
            1
          
        
        θ
      
    
    {\displaystyle 2^{2n+1}\theta }
  . In other words, it sends each eigenstate 
  
    
      
        
          |
        
        
          ψ
          
            j
          
        
        ⟩
      
    
    {\displaystyle |\psi _{j}\rangle }
   of 
  
    
      
        U
      
    
    {\displaystyle U}
   into a state close to the associated eigenvalue. For the purposes of quantum order-finding, we employ this strategy using the unitary defined by the actionThe action of 
  
    
      
        U
      
    
    {\displaystyle U}
   on states 
  
    
      
        
          |
        
        k
        ⟩
      
    
    {\displaystyle |k\rangle }
   with 
  
    
      
        N
        ≤
        k
        <
        
          2
          
            n
          
        
      
    
    {\displaystyle N\leq k<2^{n}}
   is not crucial to the functioning of the algorithm, but needs to be included to ensure the overall transformation is a well-defined quantum gate. Implementing the circuit for quantum phase estimation with 
  
    
      
        U
      
    
    {\displaystyle U}
   requires being able to efficiently implement the gates 
  
    
      
        
          U
          
            
              2
              
                j
              
            
          
        
      
    
    {\displaystyle U^{2^{j}}}
  . This can be accomplished via modular exponentiation, which is the slowest part of the algorithm.
The gate thus defined satisfies 
  
    
      
        
          U
          
            r
          
        
        =
        I
      
    
    {\displaystyle U^{r}=I}
  , which immediately implies that its eigenvalues are the 
  
    
      
        r
      
    
    {\displaystyle r}
  -th roots of unity 
  
    
      
        
          ω
          
            r
          
          
            k
          
        
        =
        
          e
          
            2
            π
            i
            k
            
              /
            
            r
          
        
      
    
    {\displaystyle \omega _{r}^{k}=e^{2\pi ik/r}}
  . Furthermore, each eigenvalue 
  
    
      
        
          ω
          
            r
          
          
            k
          
        
      
    
    {\displaystyle \omega _{r}^{k}}
   has an eigenvector of the form 
  
    
      
        
          |
        
        
          ψ
          
            j
          
        
        ⟩
        =
        
          r
          
            −
            1
            
              /
            
            2
          
        
        
          ∑
          
            k
            =
            0
          
          
            r
            −
            1
          
        
        
          ω
          
            r
          
          
            −
            k
            j
          
        
        
          |
        
        
          a
          
            k
          
        
        ⟩
      
    
    {\textstyle |\psi _{j}\rangle =r^{-1/2}\sum _{k=0}^{r-1}\omega _{r}^{-kj}|a^{k}\rangle }
  , and these eigenvectors are such that

where the last identity follows from the geometric series formula, which implies 
  
    
      
        
          ∑
          
            j
            =
            0
          
          
            r
            −
            1
          
        
        
          ω
          
            r
          
          
            j
            k
          
        
        =
        0
      
    
    {\textstyle \sum _{j=0}^{r-1}\omega _{r}^{jk}=0}
  .
Using quantum phase estimation on an input state 
  
    
      
        
          |
        
        0
        
          ⟩
          
            ⊗
            2
            n
            +
            1
          
        
        
          |
        
        
          ψ
          
            j
          
        
        ⟩
      
    
    {\displaystyle |0\rangle ^{\otimes 2n+1}|\psi _{j}\rangle }
   would result in an output 
  
    
      
        
          |
        
        
          ϕ
          
            j
          
        
        ⟩
        
          |
        
        
          ψ
          
            j
          
        
        ⟩
      
    
    {\displaystyle |\phi _{j}\rangle |\psi _{j}\rangle }
   with each 
  
    
      
        
          ϕ
          
            j
          
        
      
    
    {\displaystyle \phi _{j}}
   representing a superposition of integers that approximate 
  
    
      
        
          2
          
            2
            n
            +
            1
          
        
        j
        
          /
        
        r
      
    
    {\displaystyle 2^{2n+1}j/r}
  , with the most accurate measurement having a chance of 
  
    
      
        
          
            4
            
              π
              
                2
              
            
          
        
        ≈
        40.55
      
    
    {\textstyle {\frac {4}{\pi ^{2}}}\approx 40.55}
   of being measured (which can be made arbitrarily high using extra qubits). Thus using as input 
  
    
      
        
          |
        
        0
        
          ⟩
          
            ⊗
            2
            n
            +
            1
          
        
        
          |
        
        1
        ⟩
      
    
    {\displaystyle |0\rangle ^{\otimes 2n+1}|1\rangle }
   instead, the output is a superposition of such states with 
  
    
      
        j
        =
        0
        ,
        .
        .
        .
        ,
        r
        −
        1
      
    
    {\displaystyle j=0,...,r-1}
  . In other words, using this input amounts to running quantum phase estimation on a superposition of eigenvectors of 
  
    
      
        U
      
    
    {\displaystyle U}
  . More explicitly, the quantum phase estimation circuit implements the transformationMeasuring the first register, we now have a balanced probability 
  
    
      
        1
        
          /
        
        r
      
    
    {\displaystyle 1/r}
   to find each 
  
    
      
        
          |
        
        
          ϕ
          
            j
          
        
        ⟩
      
    
    {\displaystyle |\phi _{j}\rangle }
  , each one giving an integer approximation to 
  
    
      
        
          2
          
            2
            n
            +
            1
          
        
        j
        
          /
        
        r
      
    
    {\displaystyle 2^{2n+1}j/r}
  , which can be divided by 
  
    
      
        
          2
          
            2
            n
            +
            1
          
        
      
    
    {\displaystyle 2^{2n+1}}
   to get a decimal approximation for 
  
    
      
        j
        
          /
        
        r
      
    
    {\displaystyle j/r}
  .

Continued fraction algorithm to retrieve the period
Then, we apply the continued fractions algorithm to find integers 
  
    
      
        b
      
    
    {\textstyle b}
   and 
  
    
      
        c
      
    
    {\textstyle c}
  , where 
  
    
      
        
          
            b
            c
          
        
      
    
    {\textstyle {\frac {b}{c}}}
   gives the best fraction approximation for the approximation measured from the circuit, for 
  
    
      
        b
        ,
        c
        <
        N
      
    
    {\textstyle b,c<N}
   and coprime 
  
    
      
        b
      
    
    {\textstyle b}
   and 
  
    
      
        c
      
    
    {\textstyle c}
  . The number of qubits in the first register, 
  
    
      
        2
        n
        +
        1
      
    
    {\displaystyle 2n+1}
  , which determines the accuracy of the approximation, guarantees thatgiven the best approximation from the superposition of 
  
    
      
        
          |
        
        
          ϕ
          
            j
          
        
        ⟩
      
    
    {\textstyle |\phi _{j}\rangle }
   was measured (which can be made arbitrarily likely by using extra bits and truncating the output). However, while 
  
    
      
        b
      
    
    {\textstyle b}
   and 
  
    
      
        c
      
    
    {\textstyle c}
   are coprime, it may be the case that 
  
    
      
        j
      
    
    {\textstyle j}
   and 
  
    
      
        r
      
    
    {\textstyle r}
   are not coprime. Because of that, 
  
    
      
        b
      
    
    {\textstyle b}
   and 
  
    
      
        c
      
    
    {\textstyle c}
   may have lost some factors that were in 
  
    
      
        j
      
    
    {\textstyle j}
   and 
  
    
      
        r
      
    
    {\textstyle r}
  . This can be remedied by rerunning the quantum subroutine an arbitrary number of times, to produce a list of fraction approximationswhere 
  
    
      
        s
      
    
    {\textstyle s}
   is the number of times the algorithm was run. Each 
  
    
      
        
          c
          
            k
          
        
      
    
    {\textstyle c_{k}}
   will have different factors taken out of it because the circuit will (likely) have measured multiple different possible values of 
  
    
      
        j
      
    
    {\textstyle j}
  . To recover the actual 
  
    
      
        r
      
    
    {\textstyle r}
   value, we can take the least common multiple of each 
  
    
      
        
          c
          
            k
          
        
      
    
    {\textstyle c_{k}}
  :The least common multiple will be the order 
  
    
      
        r
      
    
    {\textstyle r}
   of the original integer 
  
    
      
        a
      
    
    {\textstyle a}
   with high probability.

Choosing the size of the first register
Phase estimation requires choosing the size of the first register to determine the accuracy of the algorithm, and for the quantum subroutine of Shor's algorithm, 
  
    
      
        2
        n
        +
        1
      
    
    {\displaystyle 2n+1}
   qubits is sufficient to guarantee that the optimal bitstring measured from phase estimation (meaning the 
  
    
      
        
          |
        
        k
        ⟩
      
    
    {\displaystyle |k\rangle }
   where 
  
    
      
        k
        
          /
        
        
          2
          
            2
            n
            +
            1
          
        
      
    
    {\textstyle k/2^{2n+1}}
   is the most accurate approximation of the phase from phase estimation) will allow the actual value of 
  
    
      
        r
      
    
    {\displaystyle r}
   to be recovered.
Each 
  
    
      
        
          |
        
        
          ϕ
          
            j
          
        
        ⟩
      
    
    {\displaystyle |\phi _{j}\rangle }
   before measurement in Shor's algorithm represents a superposition of integers approximating 
  
    
      
        
          2
          
            2
            n
            +
            1
          
        
        j
        
          /
        
        r
      
    
    {\displaystyle 2^{2n+1}j/r}
  . Let 
  
    
      
        
          |
        
        k
        ⟩
      
    
    {\displaystyle |k\rangle }
   represent the most optimal integer in 
  
    
      
        
          |
        
        
          ϕ
          
            j
          
        
        ⟩
      
    
    {\displaystyle |\phi _{j}\rangle }
  . The following theorem guarantees that the continued fractions algorithm will recover 
  
    
      
        j
        
          /
        
        r
      
    
    {\displaystyle j/r}
   from 
  
    
      
        k
        
          /
        
        
          2
          
            2
            
              n
            
            +
            1
          
        
      
    
    {\displaystyle k/2^{2{n}+1}}
  :

 As 
  
    
      
        k
      
    
    {\displaystyle k}
   is the optimal bitstring from phase estimation, 
  
    
      
        k
        
          /
        
        
          2
          
            2
            
              n
            
            +
            1
          
        
      
    
    {\displaystyle k/2^{2{n}+1}}
   is accurate to 
  
    
      
        j
        
          /
        
        r
      
    
    {\displaystyle j/r}
   by 
  
    
      
        2
        n
        +
        1
      
    
    {\displaystyle 2n+1}
   bits. Thus,which implys that the continued fractions algorithm will recover 
  
    
      
        j
      
    
    {\displaystyle j}
   and 
  
    
      
        r
      
    
    {\displaystyle r}
   (or with their greatest common divisor taken out).

The bottleneck
The runtime bottleneck of Shor's algorithm is quantum modular exponentiation, which is by far slower than the quantum Fourier transform and classical pre-/post-processing. There are several approaches to constructing and optimizing circuits for modular exponentiation. The simplest and (currently) most practical approach is to mimic conventional arithmetic circuits with reversible gates, starting with ripple-carry adders. Knowing the base and the modulus of exponentiation facilitates further optimizations. Reversible circuits typically use on the order of 
  
    
      
        
          n
          
            3
          
        
      
    
    {\displaystyle n^{3}}
   gates for 
  
    
      
        n
      
    
    {\displaystyle n}
   qubits. Alternative techniques asymptotically improve gate counts by using quantum Fourier transforms, but are not competitive with fewer than 600 qubits owing to high constants.

Period finding and discrete logarithms
Shor's algorithms for the discrete log and the order finding problems are instances of an algorithm solving the period finding problem.. All three are instances of the hidden subgroup problem.

Shor's algorithm for discrete logarithms
Given a group 
  
    
      
        G
      
    
    {\displaystyle G}
   with order 
  
    
      
        p
      
    
    {\displaystyle p}
   and generator 
  
    
      
        g
        ∈
        G
      
    
    {\displaystyle g\in G}
  , suppose we know that 
  
    
      
        x
        =
        
          g
          
            r
          
        
        ∈
        G
      
    
    {\displaystyle x=g^{r}\in G}
  , for some 
  
    
      
        r
        ∈
        
          
            Z
          
          
            p
          
        
      
    
    {\displaystyle r\in \mathbb {Z} _{p}}
  , and we wish to compute 
  
    
      
        r
      
    
    {\displaystyle r}
  , which is the discrete logarithm: 
  
    
      
        r
        =
        
          
            log
            
              g
            
          
        
        (
        x
        )
      
    
    {\displaystyle r={\log _{g}}(x)}
  . Consider the abelian group 
  
    
      
        
          
            Z
          
          
            p
          
        
        ×
        
          
            Z
          
          
            p
          
        
      
    
    {\displaystyle \mathbb {Z} _{p}\times \mathbb {Z} _{p}}
  , where each factor corresponds to modular addition of values. Now, consider the function

  
    
      
        f
        :
        
          
            Z
          
          
            p
          
        
        ×
        
          
            Z
          
          
            p
          
        
        →
        G
        
        ;
        
        f
        (
        a
        ,
        b
        )
        =
        
          g
          
            a
          
        
        
          x
          
            −
            b
          
        
        .
      
    
    {\displaystyle f\colon \mathbb {Z} _{p}\times \mathbb {Z} _{p}\to G\;;\;f(a,b)=g^{a}x^{-b}.}
  This gives us an abelian hidden subgroup problem, where 
  
    
      
        f
      
    
    {\displaystyle f}
   corresponds to a group homomorphism. The kernel corresponds to the multiples of 
  
    
      
        (
        r
        ,
        1
        )
      
    
    {\displaystyle (r,1)}
  . So, if we can find the kernel, we can find 
  
    
      
        r
      
    
    {\displaystyle r}
  . A quantum algorithm for solving this problem exists. This algorithm is, like the factor-finding algorithm, due to Peter Shor and both are implemented by creating a superposition through using Hadamard gates, followed by implementing 
  
    
      
        f
      
    
    {\displaystyle f}
   as a quantum transform, followed finally by a quantum Fourier transform. Due to this, the quantum algorithm for computing the discrete logarithm is also occasionally referred to as "Shor's Algorithm."
The order-finding problem can also be viewed as a hidden subgroup problem. To see this, consider the group of integers under addition, and for a given 
  
    
      
        a
        ∈
        
          Z
        
      
    
    {\displaystyle a\in \mathbb {Z} }
   such that: 
  
    
      
        
          a
          
            r
          
        
        =
        1
      
    
    {\displaystyle a^{r}=1}
  , the function

  
    
      
        f
        :
        
          Z
        
        →
        
          Z
        
        
        ;
        
        f
        (
        x
        )
        =
        
          a
          
            x
          
        
        ,
        
        f
        (
        x
        +
        r
        )
        =
        f
        (
        x
        )
        .
      
    
    {\displaystyle f\colon \mathbb {Z} \to \mathbb {Z} \;;\;f(x)=a^{x},\;f(x+r)=f(x).}
  For any finite abelian group 
  
    
      
        G
      
    
    {\displaystyle G}
  , a quantum algorithm exists for solving the hidden subgroup for 
  
    
      
        G
      
    
    {\displaystyle G}
   in polynomial time.

See also
GEECM, a factorization algorithm said to be "often much faster than Shor's"
Grover's algorithm

References
Further reading
Nielsen, Michael A. & Chuang, Isaac L. (2010), Quantum Computation and Quantum Information, 10th Anniversary Edition, Cambridge University Press, ISBN 9781107002173.
Phillip Kaye, Raymond Laflamme, Michele Mosca, An introduction to quantum computing, Oxford University Press, 2007, ISBN 0-19-857049-X
"Explanation for the man in the street" by Scott Aaronson, "approved" by Peter Shor. (Shor wrote "Great article, Scott! That’s the best job of explaining quantum computing to the man on the street that I’ve seen."). An alternate metaphor for the QFT was presented in one of the comments. Scott Aaronson suggests the following 12 references as further reading (out of "the 10105000 quantum algorithm tutorials that are already on the web."):
Shor, Peter W. (1997), "Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer", SIAM J. Comput., 26 (5): 1484–1509, arXiv:quant-ph/9508027v2, Bibcode:1999SIAMR..41..303S, doi:10.1137/S0036144598347011. Revised version of the original paper by Peter Shor ("28 pages, LaTeX. This is an expanded version of a paper that appeared in the Proceedings of the 35th Annual Symposium on Foundations of Computer Science, Santa Fe, NM, Nov. 20--22, 1994. Minor revisions made January, 1996").
Quantum Computing and Shor's Algorithm, Matthew Hayward's Quantum Algorithms Page, 2005-02-17, imsa.edu, LaTeX2HTML version of the original LaTeX document, also available as PDF or postscript document.
Quantum Computation and Shor's Factoring Algorithm, Ronald de Wolf, CWI and University of Amsterdam, January 12, 1999, 9 page postscript document.
Shor's Factoring Algorithm, Notes from Lecture 9 of Berkeley CS 294–2, dated 4 Oct 2004, 7 page postscript document.
Chapter 6 Quantum Computation Archived 2020-04-30 at the Wayback Machine, 91 page postscript document, Caltech, Preskill, PH229.
Quantum computation: a tutorial by Samuel L. Braunstein.
The Quantum States of Shor's Algorithm, by Neal Young, Last modified: Tue May 21 11:47:38 1996.
III. Breaking RSA Encryption with a Quantum Computer: Shor's Factoring Algorithm, Lecture notes on Quantum computation, Cornell University, Physics 481–681, CS 483; Spring, 2006 by N. David Mermin. Last revised 2006-03-28, 30 page PDF document.
Lavor, C.; Manssur, L. R. U.; Portugal, R. (2003). "Shor's Algorithm for Factoring Large Integers". arXiv:quant-ph/0303175.
Lomonaco, Jr (2000). "Shor's Quantum Factoring Algorithm". arXiv:quant-ph/0010034.  This paper is a written version of a one-hour lecture given on Peter Shor's quantum factoring algorithm. 22 pages.
Chapter 20 Quantum Computation, from Computational Complexity: A Modern Approach, Draft of a book: Dated January 2007, Sanjeev Arora and Boaz Barak, Princeton University. Published as Chapter 10 Quantum Computation of Sanjeev Arora, Boaz Barak, "Computational Complexity: A Modern Approach", Cambridge University Press, 2009, ISBN 978-0-521-42426-4
A Step Toward Quantum Computing: Entangling 10 Billion Particles Archived 2011-01-20 at the Wayback Machine, from "Discover Magazine", Dated January 19, 2011.
Josef Gruska - Quantum Computing Challenges also in Mathematics unlimited: 2001 and beyond, Editors Björn Engquist, Wilfried Schmid, Springer, 2001, ISBN 978-3-540-66913-5

External links
Version 1.0.0 of libquantum: contains a C language implementation of Shor's algorithm with their simulated quantum computer library, but the width variable in shor.c should be set to 1 to improve the runtime complexity.
PBS Infinite Series created two videos explaining the math behind Shor's algorithm, "How to Break Cryptography" and "Hacking at Quantum Speed with Shor's Algorithm".